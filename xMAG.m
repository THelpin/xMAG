(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
xAct`xMAG`$Version={"0.1.0",{2021,05,06}}


(* ::Input::Initialization:: *)
xAct`xMAG`$xTensorVersionExpected={"1.1.4",{2020,2,16}};
xAct`xMAG`$xTrasVersionExpected={"1.0.6",{2014,10,30}};


(* ::Input::Initialization:: *)
(* xMAG: Metric-Affine Gravity framework *)

(* Copyright (C) 2020 T. Helpin *)

(* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License,or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

*)


(* ::Input::Initialization:: *)
(* :Title: xMAG *)

(* :Author: Thomas Helpin *)

(* :Summary: Metric-Affine Gravity framework. *)

(* :Brief Discussion: TraceFree is a package to demonstrate using xTension. It adds an option, TraceFree, to DefTensor to declare a tensor trace-free at the time of definition. *)
  
(* :Context: xAct`xMAG` *)

(* :Package Version: 0.1.0 *)

(* :Copyright: T.Helpin (2020) *)

(* :History: TODO *)

(* :Keywords: TODO *)

(* :Source: xMAG.nb *)

(* :Warning: TODO *)

(* :Mathematica Version: 8.0 and later *)

(* :Limitations: *)
	
(* :Acknowledgements: *)


(* ::Input::Initialization:: *)
If[Unevaluated[xAct`xCore`Private`$LastPackage]===xAct`xCore`Private`$LastPackage,xAct`xCore`Private`$LastPackage="xAct`xMAG`"];


(* ::Input::Initialization:: *)
Off[General::nostdvar]
Off[General::nostdopt]
BeginPackage["xAct`xMAG`",{"xAct`xTras`","xAct`xTensor`","xAct`xPerm`","xAct`xCore`","xAct`ExpressionManipulation`","xAct`TraceFree`","xAct`xBrauer`"}]


(* ::Input::Initialization:: *)
If[Not@OrderedQ@Map[Last,{$xTensorVersionExpected,xAct`xTensor`$Version}],Throw@Message[General::versions,"xTensor",xAct`xTensor`$Version,$xTensorVersionExpected]]

If[Not@OrderedQ@Map[Last,{$xTrasVersionExpected,xAct`xTras`$Version}],Throw@Message[General::versions,"xTras",xAct`xTras`$Version,$xTrasVersionExpected]]


(* ::Input::Initialization:: *)
Print[xAct`xCore`Private`bars]
Print["Package xAct`xMAG`  version ",$Version[[1]],", ",$Version[[2]]];
Print["Copyright (C) 2020, Thomas Helpin, under the General Public License."];


(* ::Input::Initialization:: *)
Off[General::shdw]
xAct`xForm`Disclaimer[]:=Print["These are points 11 and 12 of the General Public License:\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM `AS IS\.b4 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."]
On[General::shdw]


(* ::Input::Initialization:: *)
If[xAct`xCore`Private`$LastPackage==="xAct`xMAG`",
Unset[xAct`xCore`Private`$LastPackage];
Print[xAct`xCore`Private`bars];
Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];
Print[xAct`xCore`Private`bars]]


(* ::Input::Initialization:: *)
GiveOutputString[Acceleration,vector_]:=GiveOutputString[Acceleration]


(* ::Input::Initialization:: *)
(*** VERSIONS ***)
$Version::usage="$Version is a global variable giving the version of the package xMAG in use.";
$xTensorVersionExpected::usage="$xTensorVersionExpected is a global variable giving the oldest possible version of the package xTensor which is required by the version of the package xMAG in use.";
$xTrasVersionExpected::usage="$xTrasVersionExpected is a global variable giving the oldest possible version of the package xPert which is required by the version of the package xMAG in use.";


(* ::Input::Initialization:: *)
(**************************************************************************************************************)
(**************************************** Convienient functions ***********************************************)
(**************************************************************************************************************)
SafeCanonical::usage="SafeCanonical[e] is ToCanonical with the option UseMetricOnVBundle -> None";
SCanonical::usage="Extended version of ToCanonical using xTensor functions SeparateMetric and ContractMetric";
ToFunction::usage="ToFunction[exp1==exp2,function] Automatically transforms an equality between two tensorial expressions into a function using ToRule function of xTensor.";
InverseMakeRule::usage="InverseMakeRule[rule] inverse the rule when it is possible.";
LeviCivitaQ::usage="LeviCivitaQ[cd,g] gives true if cd is the Levi-Civita connection associated to the metric g.";
NonMetricityQ::usage="NonMetricityQ[cd,g] gives True if cd is not metric compatible with respect g. False otherwise.";


(**************************************************************************************************************)
(********************* Options for the extension of the xTensor/xTras DefCovD *********************************)
(**************************************************************************************************************)
DefMAGTensors::usage="MAGTensorsDef is an option for DefCovD. Use MAGTensorsDef -> metric, or MAGTensorsDef -> Null. 
Its default value is Null.\ 
When torsion is false MAGTensorsDef trigger the definition of DisformationCD[a,-b,-c] which is symmetric in the last two indices.
When torsion is true but CD is metric compatible (see : FromMetric option of DefCovD) then MAGTensorsDef trigger the definition of ContorsionCD[a,-b,-c] 
which is antisymmetric in the first and last indices. In the general case MAGTensorsDef trigger the definition of DistortionCD[a,-b,-c]
which has no index symmetry and of DisformationCD[a,-b,-c] and ContorsionCD[a,-b,-c].";
GradMetricToNonMetricityRule::usage="The rules from covd[-a]metric[-b,-c] to nonmetricity[-a,-b,-c].";
SetGradMetricToNonMetricityRule::usage="SetNonMetricityRules[covd,metric] uses AutomaticRules to make the rules from cov[-a]metric[-b,-c] to nonmetricity[-a,-b,-c] automatic.";
AutoNonMetricityQ::usage =
"AutoNonMetricityQ[cd] gives True if the cd[-a]@g[-b,-c] is automatically transformed into the nonmetricity tensor \
It is also a boolean option for DefCovD specifying whether cd[-a]@g[-b,-c] should be automatically transformed. The default is True.";
(**************************************************************************************************************)
(************ Extended "Non-Riemannian" connection tensors define in the extension of DefCovD *****************)
(**************************************************************************************************************)
Distortion::usage =
	"Distortion is a reserved word in xMAG. It is used to generated the name \
of the Distortion tensor.";
DistortionTrace::usage =
	"DistortionTrace[covd][n] returns the n trace vector of the distortion tensor associated to the covariant \
derivative covd.";
TFDistortion::usage =
	"TFDistortion[covd] returns the Traceless distortion tensor associated to a connection covd acting on a tangent bundle.";
TFDistortionToDistortion::usage="TFDistortionToDistortion[expr, covd] expands expr expressing all TFDistortion tensors of covd in terms\
 of the Distortion of covd.";
DistortionToTFDistortion::usage="DistortionToTFDistortion[expr, covd] expands expr expressing all Distortion tensors of covd in terms\
 of the TFDistortion of covd.";
Disformation::usage =
	"Disformation is a reserved word in xMAG. It is used to generated the name \
of the Disformation tensor.";
TFDisformation::usage ="TFDisformation[covd] returns the traceless Disformation tensor associated to a connection covd acting on a tangent bundle.";
TFDisformationToDisformation::usage="TFDisformationToDisformation[expr,covd] expands expr expressing all TFDisformation tensors of covd in terms\
 of the Disformation of covd.";
DisformationToTFDisformation::usage="DisformationToTFDisformation[expr, covd] expands expr expressing all Disformation tensors of covd in terms\
 of the TFDisformation and other tensors of covd.";
DisformationTrace::usage =
	"DisformationTrace[covd][n] returns the n trace vector of the disformation tensor associated to the covariant \
derivative covd.";
Contorsion::usage =
	"Contorsion is a reserved word in xMAG. It is used to generated the name \
of the Contorsion tensor.";
TFContorsion::usage ="TFContorsion[covd] returns the traceless Contorsion tensor associated to a connection covd acting on a tangent bundle.";
TFContorsionToContorsion::usage="TFContorsionToContorsion[expr, covd] expands expr expressing all TFContorsion tensors of covd in terms\
 of the Contorsion and other tensors of covd.";
ContorsionToTFContorsion::usage="ContorsionToTFContorsion[expr, covd] expands expr expressing all Contorsion tensors of covd in terms\
 of the TFContorsion and other tensors of covd.";
NonMetricity::usage =
	"NonMetricity is a reserved word in xMAG. It is used to generated the name \
of the nonmetricity tensor.";
TFNonMetricity::usage ="TFNonMetricity[covd] returns the Traceless NonMetricity tensor associated to a connection covd acting on a tangent bundle.";
TFNonMetricityToNonMetricity::usage="TFNonMetricityToNonMetricity[expr, covd] expands expr expressing all TFNonMetricity tensors of covd in terms of the NonMetricity\
 and other tensors of covd.";
NonMetricityToTFNonMetricity::usage="NonMetricityToTFNonMetricity[expr, covd] expands expr expressing all NonMetricity tensors of covd in terms of the TFNonMetricity\
 and other tensors of covd.";
WeylVector::usage ="WeylVector is a reserved word in xMAG. It is used to generated the name \
of the WeylVector vector.";
WeylCoVector::usage ="WeylCoVector is a reserved word in xMAG. It is used to generated the name \
of the WeylCoVector vector.";
TFTorsion::usage ="TFTorsion[covd] returns the Traceless Torsion tensor associated to a connection covd acting on a tangent bundle.";
TFTorsionToTorsion::usage="TFTorsionToTorsion[expr, covd] expands expr expressing all TFTorsion tensors of covd in terms of the Torsion and other tensors of covd.";
TorsionToTFTorsion::usage="TorsionToTFTorsion[expr, covd] expands expr expressing all Torsion tensors of covd in terms of the TFTorsion and other tensors of covd.";
TorsionVector::usage ="TorsionVector is a reserved word in xMAG. It is used to generated the name \
of the TorsionVector vector.";
(**************************************************************************************************************)
(************* Extended "Non-Riemannian" curvature tensors define in the extension of DefCovD *****************)
(**************************************************************************************************************)
Homothetic::usage =
	"Homothetic is a reserved word in xMAG. It is used to generated the name \
of one of the traces of the Riemann tensor known as the Homothetic tensor. This tensor is defines with DefCovD";
CoRicci::usage =
	"CoRicci is a reserved word in xMAG. It is used to generated the name \
of one of the traces of the Riemann tensor known as the CoRicci tensor. This tensor is defines with DefCovD";
TFRicci::usage="TFRicci[covd] returns the Traceless Ricci curvature tensor associated to a connection covd acting on a tangent bundle.";
TFCoRicci::usage =
	"TFCoRicci[covd] returns the Traceless CoRicci curvature tensor associated to a connection covd acting on a tangent bundle.";
CoRicciToTFCoRicci::usage="CoRicciToTFCoRicci[expr, covd] expands expr expressing all CoRicci tensors of covd in terms of the TFCoRicci and other tensors of covd.
 If the second argument is a list of covariant derivatives the command is applied sequentially on expr. RicciToTFRicci[expr] expands all Ricci tensors.";
TFCoRicciToCoRicci::usage="TFCoRicciToCoRicci[expr, covd] expands expr expressing all TFCoRicci tensors of covd in terms of the CoRicci and other tensors of covd. 
If the second argument is a list of covariant derivatives the command is applied sequentially on expr TFCoRicciToRicci[expr] expands all TFCoRicci tensors.";
(**************************************************************************************************************)
(**************** ConnectionRelations which is similar to CurvatureRelations in xTensor ***********************)
(**************************************************************************************************************)
ConnectionRelations::usage="ConnectionRelations is a Boolean option for DefCovD giving whether automatic rules relating the connection tensors (Distortion/Torsion/NonMetricity) \
 of a newly define covariant derivative should be defined or not. Its default value is True.\
ConnectionRelations[covd, Distortion] gives a list of the relations between the contracted Distortion of covd and the Trace vectors. ConnectionRelations[covd,Torsion] yield\
yield the corresponding rule for the torsion and ConnectionRelations[covd,NonMetricity] for NonMetricity.";
ConnectionRelationsQ::usage="ConnectionRelationsQ[CD] returns True if all of the connections \
relations for the covariant derivative CD have been set as automatic rules, and False otherwise.";
ClearConnectionRelations::usage="ClearConnectionRelations[CD] removes the automatic connection \
relations for the covariant derivative CD.";
SetConnectionRelations::usage="SetConnectionRelations[CD] sets the automatic connection \
relations for the covariant derivative CD.";
(**************************************************************************************************************)
(***************************** Function related to the general connection *************************************)
(**************************************************************************************************************)
MAGChristoffelTensorStart::usage="ChristoffelToDistortionStart[CD,g] start the automatic transformation of ChristoffelcdCD to the distortionCD tensor where cd is the metric compatible connection associated to the metric g.";
MAGChristoffelTensorStop::usage="ChristoffelToDistortionStop[CD,g] stop the automatic transformation of ChristoffelcdCD to the distortionCD tensor where cd is the metric compatible connection associated to the metric g.";
BreakDistortion::usage="BreakDistortion[exp,cd,metric] transforms all occurences of Distortioncd in exp into NonMetricitycd and Torsioncd terms";
BreakDisformation::usage="BreakDisformation[exp,cd,metric] transforms all occurences of Disformation in exp into the sum of nonmetricity tensors";
BreakContorsion::usage="BreakBreakContorsion[exp,cd,metric] transforms all occurences of Disformation in exp into the sum of torsion tensors";
ToDistortion::usage="ToDistortion[exp,CD,g] decomposes the curvature tensors and covariant derivative associated to CD in exp into curvature tensors and
covariant derivative associated with metric g plus terms proportional to the distortion tensors.\
It's also transforms non metricity, torsion, disformation and contorsion tensors into the distortion tensor.";
(**************************************************************************************************************)
(******************** Function related to the trace decomposition of a tensor *********************************)
(**************************************************************************************************************)
TraceFreeQ::usage="TraceFreeQ[tensor[inds],met] returns True if the contraction with the metric met of any pair of the indices of tensor is zero.";
TracesToRiemann::usage="TracesToRiemann[exp,cd,metric] transforms the CoRicci and Homothetic tensors into the metric trace and contractions of the Riemann tensor";
RiemannToWeyl::usage="RiemannToWeyl[expr, covd] expands expr expressing all Riemann tensors of covd in terms of the Weyl and other tensors of covd.\
 If the second argument is a list of covariant derivatives the command is applied sequentially on expr. RiemannToWeyl[expr] expands all Riemann tensors.";
WeylToRiemann::usage="WeylToRiemann[expr, covd] expands expr expressing all Weyl tensors of covd in terms of the Riemann and other tensors of covd.\
 If the second argument is a list of covariant derivatives the command is applied sequentially on expr. WeylToRiemann[expr] expands all Weyl tensors.";
(**************************************************************************************************************)
(************* Irreducible decomposition of a tensor under the action of the orthogonal group *****************)
(**************************************************************************************************************)
IRDMethod::usage="IRDMethod is an option of DefIRD. It can be set to either YoungProject or SNYoungProject.\
When IRDMethod is set to YoungProject DefIRD[tens[inds],..] projects tens on irreps using the Young operators.\
When IRDMethod is set to SNYoungProject DefIRD[tens[inds],..] projects tens on irreps using the Semi Normal Young units.";
DefIRD::usage="DefIRD[tens[inds],List] defines the irreducible tensors under the action of the orthogonal group \
	associated to the traceless part of the tensor tens. List has to be a list of integer from 1 to the number of \
	indices of tens. List tells DefIRD how to map the inds of tens to the standard young tableau labelling the 
	irreducible reprensations of GL(d). DefIRD[tens[inds],List] also defines IRDRules[tens] and IRDMapping[tens].
	IRDMapping[tens] stores the mapping between standard Young tableaux and the defined irreducibles tensors.";
IRDRules::usage="IRDRules[tensor] return a list of rules for the irreducible decomposition of tensor under the action \
 of the orthogonal group. For these rules to be defined one should first call DefIRD[tensor[inds],...].";
IRDMapping::usage="IRDMapping[tensor] returns a list corresponding to the mapping between standard Young tableaux\
and the irreducibles tensors defined with DefIRD[tensor[inds],...].";
UndefIRD::usage="UndefIRD[tens] undefines irreducible tensors, IRDMapping[tens] and IRDRules[tens] which were defined\
with DefIRD[tens].";
(**************************************************************************************************************)
(****************************** Linear/Projective Transformations *********************************************)
(**************************************************************************************************************) 
LinearVector::usage="Head for vectors involved in linear transformations of the distortion tensor.";
LinearTransformations::usage="Return the set of rules corresponding to linear transformations of the distortion tensor.";
LinearTransform::usage="LinearTransform[n,exp] applies the linear transformation of type n to exp.";
ProjectiveTransformation::usage="Return the set of rules corresponding to the projective transformation of the distortion tensor.";
ProjectiveTransform::usage="ProjectiveTransform[exp,CD,g] applies the projective transformation to all 
occurences of the distortion tensor appearing in the modified expr.";
ProjectiveQ::usage="ProjectiveQ[exp,CD,g] return true if exp is projective invariant, false otherwise.";
(**************************************************************************************************************)
(****************************** ADM Decomposition in Metric Affine Gravity : (In developement) *********************************************)
(**************************************************************************************************************) 
DefDistortionADMComp::usage="DefDistortionADMComp[CD,h] defines the ADM component components of the distortion tensor associated to CD with h being the induced metric on the 3D spacelike hypersurface.";
UndefDistortionADMComp::usage="UndefDistortionADMComp[CD,h] undefines the ADM component components of the distortion tensor associated to CD with h being the induced metric on the 3D spacelike hypersurface.";
DistortionToADMStart::usage="DistortionToADMStart[CD,h] start the automatic conversion of the contraction of the distortion tensor with induced metric h and normal vector to the ADM components defines with DefDistortionADMComp[CD,h].";
DistortionToADMStop::usage="DistortionToADMStart[CD,h] stop the automatic conversion of the contraction of the distortion tensor with induced metric h and normal vector to the ADM components defines with DefDistortionADMComp[CD,h].";
DistortionToADM::usage="DistortionToADM[expr,CD,h] transforms all occurences of the distortion tensor into its ADM decomposition using the tensors defines with DefDistortionADMComp[CD,h].";

Extrinsic::usage =
	"Extrinsic is a reserved word in xMAG. It is used to generated the name of the MAG extrinsic tensors.";
DefMAGExtrinsicTensors::usage="DefMAGExtrinsicTensors[CD,h] defines the generalized extrinsicic tensors associated to CD on the 3D spacelike hypersurface.";
UndefMAGExtrinsicTensors::usage="UndefMAGExtrinsicTensors[CD,h] undefines the generalized extrinsicic tensors associated to CD on the 3D spacelike hypersurface.";
DistortionADMToExtrinsicStart::usage="DistortionADMToExtrinsicStart[CD,h] start the automatic conversion of the ADM components of the distortion tensor to the generalized extrinsic curvature.";
DistortionADMToExtrinsicStop::usage="DistortionADMToExtrinsicStop[CD,h] stop the automatic conversion of the ADM components of the distortion tensor to the generalized extrinsic curvature.";
ExtrinsicToDistortionADM::usage="ExtrinsicToDistortionADM[expr,CD,h] transforms all occurences of the generalized extrinsic curvatures appearing in expr into the corresponding ADM components of the distortion tensor.";

DefMAGAccelerationTensors::usage="DefMAGAccelerationTensors[CD,h] defines the generalized acceleration tensors associated to CD.";
UndefMAGAccelerationTensors::usage="MAGAccelerationTensors[CD,h] undefines the generalized acceleration tensors associated to CD.";
DistortionADMToAccelerationStart::usage="DistortionADMToAccelerationStart[CD,h] start the automatic conversion of the ADM components of the distortion tensor to the generalized acceleration tensors associated to CD.";
DistortionADMToAccelerationStop::usage="DistortionADMToAccelerationStop[CD,h] stop the automatic conversion of the ADM components of the distortion tensor to the generalized acceleration tensors associated to CD.";
AccelerationToDistortionADM::usage="AccelerationToDistortionADM[expr,CD,h] transforms all occurences of the generalized accelerations appearing in expr into the corresponding ADM components of the distortion tensor.";
FromADMToDistortion::usage="FromADMToDistortion[expr,CD,h] transforms all ADM components of the distortion tensor and also acceleration components and extrinsic curvature appearing\
 in expr into the distortion tensor contracted with the induced metric h and the normal vector.";

(** Non Riemannian part of curvature tensors **)
NRiemann::usage =
	"NRiemann is a reserved word in xMAG. It is used to generated the name \
of Non-Riemannian part of the Riemann tensor.StartTraceDecomposition";	
NWeyl::usage =
	"NWeyl is a reserved word in xMAG. It is used to generated the name \
of Non Riemannian part of the Generalized Weyl tensor.";	




(* ::Input::Initialization:: *)
(*** Non-Riemannian decomposition of the Riemann tensor ***)
StartNonRiemannianDecomposition::usage="StartNonRiemannianDecomposition[cd,metric] defines the necessary tensors and rules for the Non-Riemannian decomposition of the Riemann tensor";
BreakMAGRiemann::usage="BreakMAGRiemann[exp,cd,metric] decomposes the Riemann tensor into metric part and Non-Riemannian part";
BreakMAGWeyl::usage="BreakMAGWeyl[exp,cd,metric] decomposes the Riemann tensor into metric part and Non-Riemannian part";




(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Input::Initialization:: *)
SCanonical[e_,metric_]:=ContractMetric[e//SeparateMetric[metric]//ToCanonical,metric]//ToCanonical
SCanonical[e_]:=e//SeparateMetric[]//ToCanonical//ContractMetric//ToCanonical


(* ::Input::Initialization:: *)
(* Borrowed from Francesco Torsello: See  arXiv:1904.10464   *)
SafeCanonical[e_]:=ToCanonical[e, UseMetricOnVBundle -> None]


(* ::Input::Initialization:: *)
Options[ToFunction]={Verbose->True};
ToFunction[expr:(_Equal|_Rule|_RuleDelayed),Function_,options___]:=Module[{rule,verbose,optionstr},
{verbose}=OptionValue[{ToFunction},{options},{Verbose}];
optionstr=Options[ToRule];
rule=ToRule[expr,optionstr];
Function[e_]:=e/.rule;
If[verbose===True,
Print["** Defining function  "<>ToString[Function]]]
]


(* ::Input::Initialization:: *)
LeviCivitaQ[covd_?CovDQ,metric_?MetricQ]:=Module[
{ torsionQ=TorsionQ[covd],
met=MetricOfCovD[covd],
metricQ= MetricOfCovD[covd]=!= Null
},
If[!TorsionQ[covd]&&(metricQ),
	If[ToString[met]==ToString[metric],True,False],False]]


(* ::Input::Initialization:: *)
LeviCivitaQ[covd_?CovDQ]:=LeviCivitaQ[covd,$Metrics[[1]]]


(* ::Input::Initialization:: *)
NonMetricityQ[covd_?CovDQ,metric_?MetricQ]:=If[MetricOfCovD[covd]===metric,False]
NonMetricityQ[covd_?CovDQ]:=NonMetricityQ[covd,$Metrics[[1]]]


(* ::Input::Initialization:: *)
Options[InverseMakeRule]={PatternIndices->All,TestIndices->True,MetricOn->All,UseSymmetries->True,Verbose->False,ContractMetrics->True,Evaluate->False};
InverseMakeRule[rule_,options:OptionsPattern[]]:=Module[{head1=Head[rule[[1,1]]],head2=Head[rule[[2,2]]],ind1=Map[If[First[#]=!=-1,First@First[#],-First@@Last[#]]&,List@@rule[[1,1]]],ind2=List@@rule[[2,2]],tens1,tens2},
If[head2===Plus,Throw["non invertible rule"]];
tens1=head1@@ind1;
tens2=head2@@ind2;
ToRule[tens2==tens1,options]
]


Unprotect[xAct`xTensor`DefCovD];
If[FreeQ[Options[xAct`xTensor`DefCovD], DefMAGTensors], 
	Options[xAct`xTensor`DefCovD] ^= Append[Options[xAct`xTensor`DefCovD], DefMAGTensors -> Null];
, 
	Null;
];
Protect[xAct`xTensor`DefCovD];
Unprotect[xAct`xTensor`DefCovD];

If[FreeQ[Options[xAct`xTensor`DefCovD],ConnectionRelations], 
	Options[xAct`xTensor`DefCovD] ^= Append[Options[xAct`xTensor`DefCovD], ConnectionRelations -> False];
, 
	Null;
];
Protect[xAct`xTensor`DefCovD];

Unprotect[xAct`xTensor`DefCovD];
If[FreeQ[Options[xAct`xTensor`DefCovD], AutoNonMetricityQ], 
	Options[xAct`xTensor`DefCovD] ^= Append[Options[xAct`xTensor`DefCovD], AutoNonMetricityQ-> True];
, 
	Null;
];
Protect[xAct`xTensor`DefCovD];


(* ::Input::Initialization:: *)
Set[CovDTensorQ[#],True]&/@{Distortion,DistortionTrace,TFDistortion,Disformation,DisformationTrace,TFDisformation,Contorsion,TFContorsion,NonMetricity,TFNonMetricity,WeylVector,WeylCoVector,TFTorsion,TorsionVector,CoRicci,TFCoRicci,Homothetic,Weyl,NRiemann,NWeyl,LinearVector};
CovDTensorQ[_]=False;


(* ::Input::Initialization:: *)
Distortion[covd_]:=ToExpression[StringJoin[ToString[Distortion],ToString[covd]]];
Disformation[covd_]:=ToExpression[StringJoin[ToString[Disformation],ToString[covd]]];
Contorsion[covd_]:=ToExpression[StringJoin[ToString[Contorsion],ToString[covd]]];
NonMetricity[covd_]:=ToExpression[StringJoin[ToString[NonMetricity],ToString[covd]]];
WeylVector[covd_]:=ToExpression[StringJoin[ToString[WeylVector],ToString[covd]]];
WeylCoVector[covd_]:=ToExpression[StringJoin[ToString[WeylCoVector],ToString[covd]]];
TorsionVector[covd_]:=ToExpression[StringJoin[ToString[TorsionVector],ToString[covd]]];
CoRicci[covd_]:=ToExpression[StringJoin[ToString[CoRicci],ToString[covd]]];
Homothetic[covd_]:=ToExpression[StringJoin[ToString[Homothetic],ToString[covd]]];
TFCoRicci[covd_]:=ToExpression[StringJoin[ToString[TFCoRicci],ToString[covd]]];


(* ::Input::Initialization:: *)
(** Extended parts curvature tensors **)
PrintAsCharacter[Ricci]="\!\(\*OverscriptBox[\(R\), \((1)\)]\)";
PrintAsCharacter[CoRicci]="\!\(\*OverscriptBox[\(R\), \((2)\)]\)";
PrintAsCharacter[Homothetic]="\!\(\*OverscriptBox[\(R\), \((3)\)]\)";
PrintAsCharacter[TFRicci]="\!\(\*OverscriptBox[\(S\), \((1)\)]\)";
PrintAsCharacter[TFCoRicci]="\!\(\*OverscriptBox[\(S\), \((2)\)]\)";
(** Non Riemannian part of curvature tensors **)
PrintAsCharacter[NRiemann]="N";
PrintAsCharacter[NWeyl]="\!\(\*OverscriptBox[\(N\), \((W)\)]\)";
(** Tensors related to the general connection **)
PrintAsCharacter[Distortion]="C";
PrintAsCharacter[DistortionTrace]="C";
PrintAsCharacter[TFDistortion]="\!\(\*OverscriptBox[\(C\), \((tf)\)]\)";
PrintAsCharacter[Disformation]="D";
PrintAsCharacter[DisformationTrace]="D";
PrintAsCharacter[TFDisformation]="\!\(\*OverscriptBox[\(D\), \((tf)\)]\)";
PrintAsCharacter[Contorsion]="K";
PrintAsCharacter[TFContorsion]="\!\(\*OverscriptBox[\(K\), \((tf)\)]\)";
PrintAsCharacter[NonMetricity]="Q";
PrintAsCharacter[TFNonMetricity]="\!\(\*OverscriptBox[\(Q\), \((tf)\)]\)";
PrintAsCharacter[WeylVector]="Q";
PrintAsCharacter[WeylCoVector]="\!\(\*OverscriptBox[\(Q\), \(~\)]\)";
PrintAsCharacter[TFTorsion]="\!\(\*OverscriptBox[\(T\), \((tf)\)]\)";
PrintAsCharacter[TorsionVector]="T";


(* ::Input::Initialization:: *)
GiveOutputString[tensor_Symbol?CovDTensorQ,covd_]:=StringJoin[PrintAsCharacter[tensor],"[",SymbolOfCovD[covd][[2]],"]"];


(* ::Input::Initialization:: *)
xTension["xMAG`",TFRicci,"End"]:=xMAGxTensorTFRicci;
xMAGxTensorTFRicci[covd_Symbol?CovDQ]:=GiveSymbol[TFRicci,covd];


(* ::Input::Initialization:: *)
DistortionTrace[covd_][comp_]:=ToExpression[StringJoin[ToString[DistortionTrace],ToString[covd],ToString[comp]]];
DisformationTrace[covd_][comp_]:=ToExpression[StringJoin[ToString[DisformationTrace],ToString[covd],ToString[comp]]];


(* ::Input::Initialization:: *)
(** Some Output format **)
Format[Parenthesis[e_]]:=DisplayForm@RowBox[{"(",MakeBoxes@e,")"}];
xMAGPrint[xMAGsymbol_,character_,xTensorSymbol_]:=Module[{},
If[character===Null,Return[ToString[Overscript[ToExpression[PrintAsCharacter[xMAGsymbol]],Parenthesis[DisplayForm[ToExpression[PrintAsCharacter[xTensorSymbol]]]]],StandardForm]],
Return[ToString[Overscript[ToExpression[PrintAsCharacter[xMAGsymbol]],Parenthesis[DisplayForm[character]DisplayForm[ToExpression[PrintAsCharacter[xTensorSymbol]]]]],StandardForm]]
];
];
xMAGPrint[xMAGsymbol_,character_]:=ToString[Overscript[ToExpression[PrintAsCharacter[xMAGsymbol]],Parenthesis[DisplayForm[character]]],StandardForm];
xMAGIRDPrint[xMAGsymbol_,covd_,character_]:=StringJoin[ToString[Overscript[ToExpression[PrintAsCharacter[xMAGsymbol]],Parenthesis[DisplayForm[character]]],StandardForm],"[",SymbolOfCovD[covd][[2]],"]"];


(* ::Input::Initialization:: *)
ConnectionRelations[]:=Apply[Join,Map[ConnectionRelations,$CovDs]];
ConnectionRelations[covd_Symbol?CovDQ]:=Join[ConnectionRelations[covd,Distortion],ConnectionRelations[covd,NonMetricity],ConnectionRelations[covd,Torsion]];
ConnectionRelations[___]:={};


(* ::Input::Initialization:: *)
ClearConnectionRelations[cd_?(TorsionQ[#]&&NonMetricityQ[#]&),options___?OptionQ]:=(ClearAutomaticRules[Evaluate[GiveSymbol[Distortion,cd]],ConnectionRelations[cd,Distortion],options];
ClearAutomaticRules[Evaluate[GiveSymbol[Torsion,cd]],ConnectionRelations[cd,Torsion],options];
ClearAutomaticRules[Evaluate[GiveSymbol[NonMetricity,cd]],ConnectionRelations[cd,NonMetricity],options];
cd/: ConnectionRelationsQ[cd]:=False;
);

ClearConnectionRelations[cd_?(!TorsionQ[#]&&NonMetricityQ[#]&),options___?OptionQ]:=(ClearAutomaticRules[Evaluate[GiveSymbol[Disformation,cd]],ConnectionRelations[cd,Distortion],options];
ClearAutomaticRules[Evaluate[GiveSymbol[NonMetricity,cd]],ConnectionRelations[cd,NonMetricity],options];
cd/: ConnectionRelationsQ[cd]:=False;
);

ClearConnectionRelations[cd_?(TorsionQ[#]&&!NonMetricityQ[#]&),options___?OptionQ]:=(ClearAutomaticRules[Evaluate[GiveSymbol[Contorsion,cd]],ConnectionRelations[cd,Distortion],options];
ClearAutomaticRules[Evaluate[GiveSymbol[Torsion,cd]],ConnectionRelations[cd,Torsion],options];
cd/: ConnectionRelationsQ[cd]:=False;
);


(* ::Input::Initialization:: *)
SetConnectionRelations[cd_?(TorsionQ[#]&&NonMetricityQ[#]&),options___?OptionQ]:=(AutomaticRules[Evaluate[GiveSymbol[Distortion,cd]],ConnectionRelations[cd,Distortion],options];
AutomaticRules[Evaluate[GiveSymbol[Torsion,cd]],ConnectionRelations[cd,Torsion],options];
AutomaticRules[Evaluate[GiveSymbol[NonMetricity,cd]],ConnectionRelations[cd,NonMetricity],options];
cd/: ConnectionRelationsQ[cd]:=True;
);

SetConnectionRelations[cd_?(!TorsionQ[#]&&NonMetricityQ[#]&),options___?OptionQ]:=(AutomaticRules[Evaluate[GiveSymbol[Disformation,cd]],ConnectionRelations[cd,Distortion],options];
AutomaticRules[Evaluate[GiveSymbol[NonMetricity,cd]],ConnectionRelations[cd,NonMetricity],options];
cd/: ConnectionRelationsQ[cd]:=True;
);

SetConnectionRelations[cd_?(TorsionQ[#]&&!NonMetricityQ[#]&),options___?OptionQ]:=(AutomaticRules[Evaluate[GiveSymbol[Contorsion,cd]],ConnectionRelations[cd,Distortion],options];
AutomaticRules[Evaluate[GiveSymbol[Torsion,cd]],ConnectionRelations[cd,Torsion],options];
cd/: ConnectionRelationsQ[cd]:=True;
);


(* ::Input::Initialization:: *)
ClearCurvatureRelations[xAct`xTras`Private`cd_?CovDQ/;!NonMetricityQ[xAct`xTras`Private`cd],xAct`xTras`Private`options___?OptionQ]:=(ClearAutomaticRules[Evaluate[GiveSymbol[Ricci,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,Ricci],xAct`xTras`Private`options];ClearAutomaticRules[Evaluate[GiveSymbol[Riemann,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,Riemann],xAct`xTras`Private`options];ClearAutomaticRules[Evaluate[GiveSymbol[SymRiemann,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,SymRiemann],xAct`xTras`Private`options];
CurvatureRelationsQ[xAct`xTras`Private`cd]=False;);
ClearCurvatureRelations[xAct`xTras`Private`cd_?CovDQ/;NonMetricityQ[xAct`xTras`Private`cd],xAct`xTras`Private`options___?OptionQ]:=(ClearAutomaticRules[Evaluate[GiveSymbol[Ricci,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,Ricci],xAct`xTras`Private`options];
ClearAutomaticRules[Evaluate[GiveSymbol[CoRicci,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,CoRicci],xAct`xTras`Private`options];
ClearAutomaticRules[Evaluate[GiveSymbol[Riemann,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,Riemann],xAct`xTras`Private`options];
CurvatureRelationsQ[xAct`xTras`Private`cd]=False;);

SetCurvatureRelations[xAct`xTras`Private`cd_?CovDQ/;!NonMetricityQ[xAct`xTras`Private`cd],xAct`xTras`Private`options___?OptionQ]:=(AutomaticRules[Evaluate[GiveSymbol[Ricci,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,Ricci],xAct`xTras`Private`options];AutomaticRules[Evaluate[GiveSymbol[Riemann,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,Riemann],xAct`xTras`Private`options];AutomaticRules[Evaluate[GiveSymbol[SymRiemann,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,SymRiemann],xAct`xTras`Private`options];
CurvatureRelationsQ[xAct`xTras`Private`cd]=True;);
SetCurvatureRelations[xAct`xTras`Private`cd_?CovDQ/;NonMetricityQ[xAct`xTras`Private`cd],xAct`xTras`Private`options___?OptionQ]:=(AutomaticRules[Evaluate[GiveSymbol[Ricci,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,Ricci],xAct`xTras`Private`options];
AutomaticRules[Evaluate[GiveSymbol[CoRicci,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,CoRicci],xAct`xTras`Private`options];AutomaticRules[Evaluate[GiveSymbol[Riemann,xAct`xTras`Private`cd]],CurvatureRelations[xAct`xTras`Private`cd,Riemann],xAct`xTras`Private`options];
CurvatureRelationsQ[xAct`xTras`Private`cd]=True;);


MAGDefTensors[covd_?CovDQ[ind_],metric_?MetricQ,options___?OptionQ]:=With[
	{vb=VBundleOfMetric[metric],M=BaseOfVBundle@VBundleOfMetric[metric],indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 4],
	metricQ= (FromMetric/. CheckOptions[options] /. Options[DefCovD]) =!= Null,magtdQ= (DefMAGTensors/. CheckOptions[options] /. Options[DefCovD]) =!= Null,
	torsionQ= Torsion/. CheckOptions[options] /. Options[DefCovD],definfo= DefInfo /. CheckOptions[options] /. Options[DefCovD],
	curvrels= CurvatureRelations /. CheckOptions[options] /. Options[DefCovD],cd=CovDOfMetric[metric],
	connectionrels= ConnectionRelations /. CheckOptions[options] /. Options[DefCovD],
	autoVecNM=AutoVecNonMetricityQ/. CheckOptions[options] /. Options[DefCovD],autoNMQ=OptionValue[DefCovD,{options},AutoNonMetricityQ],
	autoVectorsion=AutoVecTorsionQ/. CheckOptions[options] /. Options[DefCovD]},
	With[{dimM=DimOfManifold[M],info= If[definfo =!= False, $DefInfoQ, False],riemann=GiveSymbol[Riemann,covd],
			weylmag=GiveSymbol[Weyl,covd],Nriemann=GiveSymbol[NRiemann,covd],
			Nweylmag=GiveSymbol[NWeyl,covd],homothetic=GiveSymbol[Homothetic,covd],coricci=GiveSymbol[CoRicci,covd],tfcoricci=GiveSymbol[TFCoRicci,covd],
			tfricci=GiveSymbol[TFRicci,covd],ricci=GiveSymbol[Ricci,covd],ricciscalar=GiveSymbol[RicciScalar,covd],distortion= GiveSymbol[Distortion,covd],
			tfdistortion=GiveSymbol[TFDistortion,covd],distortiont1=GiveSymbol[DistortionTrace,covd,1],distortiont2=GiveSymbol[DistortionTrace,covd,2],
			distortiont3=GiveSymbol[DistortionTrace,covd,3],tfnonmetricity=GiveSymbol[TFNonMetricity,covd],tftorsion=GiveSymbol[TFTorsion,covd],
			disformation= GiveSymbol[Disformation,covd],tfdisformation= GiveSymbol[TFDisformation,covd],
			disformation1=GiveSymbol[DisformationTrace,covd,1],disformation2=GiveSymbol[DisformationTrace,covd,2],contorsion=GiveSymbol[Contorsion,covd],
			tfcontorsion= GiveSymbol[TFContorsion,covd],nonmetricity=GiveSymbol[NonMetricity,covd],
			torsion=GiveSymbol[Torsion,covd],torsionvec=GiveSymbol[TorsionVector,covd],weylvec=GiveSymbol[WeylVector,covd],coweylvec= GiveSymbol[WeylCoVector,covd],
			a= indices[[1]],b= indices[[2]],c= indices[[3]],d= indices[[4]]
		},
		If[magtdQ,
		If[!metricQ,
		(*** MAG Weyl tensor ***)
		DefTensor[weylmag[-a,-b,-c,d],M,Antisymmetric[{-a,-b}],TraceFree->{-a,-b,-c,d},PrintAs -> GiveOutputString[Weyl,covd],
						Master-> covd, DefInfo -> If[info, {"Totally traceless generalized Weyl tensor",""}, False],TensorID->{Weyl,covd}];
		(**** Trace free part of the Ricci tensor ****)
		DefTensor[tfricci[-a,-b],DependenciesOfCovD[covd],TraceFree->{-a,-b},
							PrintAs:>GiveOutputString[TFRicci,covd],Master->covd, DefInfo -> If[info, {"trace free part of the Ricci tensor",""}, False],TensorID->{TFRicci,covd}];
		(**** RicciScalar *****)
		DefTensor[ricciscalar[],M, PrintAs -> GiveOutputString[RicciScalar,covd],
						Master-> covd, DefInfo -> If[info, {"Ricci scalar",""}, False],TensorID->{RicciScalar,covd}];
		];
		(****** Definition of the non Riemannian parts of curvature tensors ********)				
		DefTensor[Nriemann[-a,-b,-c,d],M,Antisymmetric[{-a,-b}],PrintAs -> GiveOutputString[NRiemann,covd],
						Master-> covd, DefInfo -> If[info, {"non-Riemannian part of the Riemann tensor",""}, False]];
						
(***************************************************************************************************************)	
(************************* When the connection has torsion and nonmetricity ************************************)
(***************************************************************************************************************)	
		If[!metricQ && torsionQ,
		NonMetricityQ[covd,metric]=True;
		(***********************************************)	
		(*************** Curvature tensors *************)
		(***********************************************)		
		DefTensor[Nweylmag[-a,-b,-c,d],M,Antisymmetric[{-a,-b}],TraceFree->{-a,-b,-c,d},PrintAs -> GiveOutputString[NWeyl,covd],
						Master-> covd, DefInfo -> If[info, {"non-Riemannian part of the generalized Weyl tensor",""}, False]];
		DefTensor[coricci[-a,-b],M,PrintAs -> GiveOutputString[CoRicci,covd],
						Master-> covd, DefInfo -> If[info, {"CoRicci tensor",""}, False],TensorID->{CoRicci,covd}];
		DefTensor[tfcoricci[-a,-b],DependenciesOfCovD[covd],TraceFree->{-a,-b},
							PrintAs:>GiveOutputString[TFCoRicci,covd],Master->covd, DefInfo -> If[info, {"trace free part of the Co-Ricci tensor",""}, False],
							TensorID->{TFCoRicci,covd}];
		DefTensor[homothetic[-a,-b],M,Antisymmetric[{-a,-b}],PrintAs -> GiveOutputString[Homothetic,covd],
						Master-> covd, DefInfo -> If[info, {"Homothetic tensor",""}, False],TensorID->{Homothetic,covd}];
		(***********************************************)	
		(************** Connection tensors *************)
		(***********************************************)	
		DefTensor[distortion[a,-b,-c],M,PrintAs -> GiveOutputString[Distortion,covd],
						Master-> covd, DefInfo -> If[info, {"distortion tensor",""}, False],TensorID->{Distortion,covd}];
		DefTensor[tfdistortion[a,-b,-c],DependenciesOfCovD[covd],TraceFree->{a,-b,-c},
							PrintAs:>GiveOutputString[TFDistortion,covd],Master->covd, DefInfo -> If[info, {"trace free part of the Distortion tensor",""}, False]
							,TensorID->{TFDistortion,covd}];
		DefTensor[distortiont1[a],M,PrintAs-> xMAGPrint[DistortionTrace,1]];
		DefTensor[distortiont2[-a],M,PrintAs-> xMAGPrint[DistortionTrace,2]];	
		DefTensor[distortiont3[-a],M,PrintAs-> xMAGPrint[DistortionTrace,3]];						
	
		DefTensor[disformation[a,-b,-c],M,Symmetric[{2,3}],PrintAs -> GiveOutputString[Disformation,covd],
						Master-> covd, DefInfo -> If[info, {"symmetric disformation tensor",""}, False],TensorID->{Disformation,covd}];
		DefTensor[nonmetricity[-a,-b,-c],M,Symmetric[{2,3}],PrintAs -> GiveOutputString[NonMetricity,covd],
						Master-> covd, DefInfo -> If[info, {"symmetric NonMetricity tensor",""}, False],TensorID->{NonMetricity,covd}];
		DefTensor[tfnonmetricity[-a,-b,-c],M,Symmetric[{2,3}],TraceFree->{-a,-b,-c},PrintAs -> GiveOutputString[TFNonMetricity,covd],
						Master-> covd, DefInfo -> If[info, {"trace free part of the NonMetricity tensor",""}, False],TensorID->{TFNonMetricity,covd}];
		DefTensor[tftorsion[a,-b,-c],M,Antisymmetric[{2,3}],TraceFree->{a,-b,-c},PrintAs -> GiveOutputString[TFTorsion,covd],
						Master-> covd, DefInfo -> If[info, {"trace free part of the Torsion tensor",""}, False],TensorID->{TFTorsion,covd}];
		DefTensor[weylvec[a],M,PrintAs -> GiveOutputString[WeylVector,covd],
						Master-> covd, DefInfo -> If[info, {"Weyl vector",""}, False],TensorID->{WeylVector,covd}];	
		DefTensor[coweylvec[-a],M,PrintAs -> GiveOutputString[WeylCoVector,covd],
						Master-> covd, DefInfo -> If[info, {"Weyl co-vector",""}, False],TensorID->{WeylCoVector,covd}];									
		DefTensor[contorsion[a,-b,-c],M,Antisymmetric[{1,3}],ForceSymmetries->True,PrintAs -> GiveOutputString[Contorsion,covd],
						Master-> covd, DefInfo -> If[info, {"antisymmetric contorsion tensor",""}, False],TensorID->{Contorsion,covd}];	
		DefTensor[torsionvec[-a],M,PrintAs -> GiveOutputString[TorsionVector,covd],
						Master-> covd, DefInfo -> If[info, {"torsion vector",""}, False],TensorID->{TorsionVector,covd}];
		(***********************************************)	
		(************** TraceFree rules ****************)
		(***********************************************)
		CoRicciToTFCoRicciRules[covd]=MakeRule[{coricci[-a,-b],tfcoricci[-a,-b]+ ricciscalar[]metric[-a,-b]/dimM},MetricOn->All,ContractMetrics->True];
		TFCoRicciToCoRicciRules[covd]=MakeRule[{tfricci[-a,-b],coricci[-a,-b]-ricciscalar[]metric[-a,-b]/dimM},MetricOn->All,ContractMetrics->True];
		RicciToTFRicciRules[covd]=MakeRule[{ricci[-a,-b],tfricci[-a,-b]+ ricciscalar[]*metric[-a,-b]/dimM},MetricOn->All,ContractMetrics->True];
		TFRicciToRicciRules[covd]=MakeRule[{tfricci[-a,-b],ricci[-a,-b]-ricciscalar[]*metric[-a,-b]/dimM},MetricOn->All,ContractMetrics->True];
		TFDistortionToDistortionRules[covd]=ToRule[tfdistortion[a,-b,-c]==(ToTracelessTensor[distortion[a,-b,-c],1,metric])];
		DistortionToTFDistortionRules[covd]=ToRule[distortion[a,-b,-c]==(tfdistortion[a,-b,-c]+ToTraceTensor[distortion[a,-b,-c],1,metric])];
		TFNonMetricityToNonMetricityRules[covd]=ToRule[tfnonmetricity[a,-b,-c]==(ToTracelessTensor[nonmetricity[a,-b,-c],1,metric])];
		NonMetricityToTFNonMetricityRules[covd]=ToRule[nonmetricity[a,-b,-c]==(tfnonmetricity[a,-b,-c]+ToTraceTensor[nonmetricity[a,-b,-c],1,metric])];
		TFTorsionToTorsionRules[covd]=ToRule[tftorsion[a,-b,-c]==(ToTracelessTensor[torsion[a,-b,-c],1,metric])];
		TorsionToTFTorsionRules[covd]=ToRule[torsion[a,-b,-c]==(tftorsion[a,-b,-c]+ToTraceTensor[torsion[a,-b,-c],1,metric])];	
		(***********************************************)	
		(*********** Connection relations **************)
		(***********************************************)
		ConnectionRelations[covd,Distortion]=Join[MakeRule[{distortion[b,-a,a],distortiont1[b]}],MakeRule[{distortion[a,-b,-a],distortiont2[-b]}],MakeRule[{distortion[a,-a,-b],distortiont3[-b]}]];
		ConnectionRelations[covd,NonMetricity]=Join[MakeRule[{nonmetricity[a, -b ,-a ],coweylvec[-b]}],MakeRule[{nonmetricity[b,a,-a],weylvec[b]}]];
		ConnectionRelations[covd,Torsion]=MakeRule[{torsion[a, -b,-a],torsionvec[-b]}];
		If[connectionrels,
		If[info,Print["** DefCovD:  Contractions of Distortion, Torsion, and Nonmetritcity automatically replaced by correcponding vectors."]];
			covd/: ConnectionRelationsQ[covd]:=True;
			AutomaticRules[distortion,ConnectionRelations[covd,Distortion],Verbose->False];
			AutomaticRules[nonmetricity,ConnectionRelations[covd,NonMetricity],Verbose->False];
			AutomaticRules[torsion,ConnectionRelations[covd,Torsion],Verbose->False];
			,covd/:ConnectionRelationsQ[covd]:=False];			
		(** Automatic Conversion of grad metric to nonmetricity **)	
			If[autoNMQ,
			covd/: AutoNonMetricityQ[covd] =True;
			If[!metricQ,SetGradMetricToNonMetricityRule[covd,metric]]];
		(***********************************************)	
		(*********** Curvature relations ***************)
		(***********************************************)
		If[SameQ[metric,$Metrics[[1]]],
			Unprotect[CurvatureRelations];	
			covd/:CurvatureRelations[covd,Riemann]=Join[CurvatureRelations[covd,Riemann],MakeRule[{riemann[-c, -b, -a, a],homothetic[-b, -c]}]];
			covd/:CurvatureRelations[covd,Ricci]=Join[CurvatureRelations[covd,Ricci],MakeRule[{ricci[-a,a],ricciscalar[]}]];
			covd/:CurvatureRelations[covd,Riemann]=DeleteDuplicates@Join[CurvatureRelations[covd,Riemann],MakeRule[{riemann[-c, -b, c, a],coricci[a, -b]}]];
			covd/:CurvatureRelations[covd,CoRicci]=MakeRule[{coricci[d,-d],ricciscalar[]}];
			CurvatureRelations[covd]:=Join[CurvatureRelations[covd,Riemann],CurvatureRelations[covd,Ricci],CurvatureRelations[covd,CoRicci]];
			Protect[CurvatureRelations];
			If[curvrels,CurvatureRelationsQ[covd]:=True;
			AutomaticRules[riemann,CurvatureRelations[covd,Riemann],Verbose->False];
			AutomaticRules[ricci,CurvatureRelations[covd,Ricci],Verbose->False];
			AutomaticRules[coricci,CurvatureRelations[covd,CoRicci],Verbose->False];
			]]		
		];
		
(***************************************************************************************************************)	
(************************* When the connection has nonmetricity but no torsion *********************************)
(***************************************************************************************************************)	
		
		If[!metricQ && !torsionQ,
		NonMetricityQ[covd,metric]=True;
		(***********************************************)	
		(*************** Curvature tensors *************)
		(***********************************************)			
			DefTensor[coricci[-a,-b],M,Antisymmetric[{-a,-b}],PrintAs -> GiveOutputString[CoRicci,covd],
						Master-> covd, DefInfo -> If[info, {"CoRicci tensor",""}, False],TensorID->{CoRicci,covd}];
			DefTensor[homothetic[-a,-b],M,Antisymmetric[{-a,-b}],PrintAs -> GiveOutputString[Homothetic,covd],
						Master-> covd, DefInfo -> If[info, {"Homothetic tensor",""}, False],TensorID->{Homothetic,covd}];						
		(***********************************************)	
		(************** Connection tensors *************)
		(***********************************************)
		DefTensor[disformation[a,-b,-c],M,Symmetric[{2,3}],PrintAs -> GiveOutputString[Disformation,covd],
						Master-> covd, DefInfo -> If[info, {"symmetric disformation tensor",""}, False],TensorID->{Disformation,covd}];
		DefTensor[tfdisformation[a,-b,-c],M,Symmetric[{2,3}],DependenciesOfCovD[covd],TraceFree->{a,-b,-c},
							PrintAs:>GiveOutputString[TFDisformation,covd],Master->covd, DefInfo -> If[info, {"trace free part of the Disformation tensor",""}, False]
							,TensorID->{TFDisformation,covd}];
		DefTensor[disformation1[a],M,PrintAs-> xMAGPrint[DisformationTrace,1]];
		DefTensor[disformation2[-a],M,PrintAs-> xMAGPrint[DisformationTrace,2]];		
			
		DefTensor[nonmetricity[-a,-b,-c],M,Symmetric[{2,3}],PrintAs -> GiveOutputString[NonMetricity,covd],
						Master-> covd, DefInfo -> If[info, {"symmetric nonmetricity tensor",""}, False],TensorID->{NonMetricity,covd}];
		DefTensor[weylvec[-a],M,PrintAs -> GiveOutputString[WeylVector,covd],
						Master-> covd, DefInfo -> If[info, {"Weyl vector",""}, False],TensorID->{WeylVector,covd}];			
		DefTensor[coweylvec[-a],M,PrintAs -> GiveOutputString[WeylCoVector,covd],
						Master-> covd, DefInfo -> If[info, {"Weyl co-vector",""}, False],TensorID->{WeylCoVector,covd}];
						
		(***********************************************)	
		(*********** Connection relations **************)
		(***********************************************)
		ConnectionRelations[covd,Distortion]=Join[MakeRule[{disformation[b,-a,a],disformation1[b]}],MakeRule[{disformation[a,-b,-a],disformation2[-b]}]];
		ConnectionRelations[covd,NonMetricity]=Join[MakeRule[{nonmetricity[a, -b ,-a ],coweylvec[-b]}],MakeRule[{nonmetricity[b,a,-a],weylvec[b]}]];
		If[connectionrels,
		If[info,Print["** DefCovD:  Contractions of Distortion, Torsion, and Nonmetritcity automatically replaced by correcponding vectors."]];
			covd/: ConnectionRelationsQ[covd]:=True;
			AutomaticRules[disformation,ConnectionRelations[covd,Distortion],Verbose->False];
			AutomaticRules[nonmetricity,ConnectionRelations[covd,NonMetricity],Verbose->False]
			,covd/:ConnectionRelationsQ[covd]:=False];
		(************************************************************************************)	
		(****************************** Curvature relations *********************************)
		(************************************************************************************)
		If[SameQ[metric,$Metrics[[1]]],
			Unprotect[CurvatureRelations];	
			covd/:CurvatureRelations[covd,Riemann]=Join[CurvatureRelations[covd,Riemann],MakeRule[{riemann[-c, -b, -a, a],homothetic[-b, -c]}]];
			covd/:CurvatureRelations[covd,Ricci]=Join[CurvatureRelations[covd,Ricci],MakeRule[{ricci[-a,a],ricciscalar[]}]];
			covd/:CurvatureRelations[covd,Riemann]=DeleteDuplicates@Join[CurvatureRelations[covd,Riemann],MakeRule[{riemann[-c, -b, c, a],coricci[a, -b]}]];
			covd/:CurvatureRelations[covd,CoRicci]=MakeRule[{coricci[d,-d],ricciscalar[]}];
			CurvatureRelations[covd]:=Join[CurvatureRelations[covd,Riemann],CurvatureRelations[covd,Ricci],CurvatureRelations[covd,CoRicci]];
			Protect[CurvatureRelations];
			If[curvrels,CurvatureRelationsQ[covd]:=True;
			AutomaticRules[riemann,CurvatureRelations[covd,Riemann],Verbose->False];
			AutomaticRules[ricci,CurvatureRelations[covd,Ricci],Verbose->False];
			AutomaticRules[coricci,CurvatureRelations[covd,CoRicci],Verbose->False];
			]]		
		];
			
(***************************************************************************************************************)	
(*********************** When the connection has torsion but is metric compatible ******************************)
(***************************************************************************************************************)	
					
			If[metricQ && torsionQ,
			NonMetricityQ[covd,metric]=False;
			(* No additionnal curvature tensors when there is only torsion *)	
			
			(***********************************************)	
			(************** Connection tensors *************)
			(***********************************************)
			DefTensor[contorsion[a,-b,-c],M,Antisymmetric[{1,3}],ForceSymmetries->True,PrintAs -> GiveOutputString[Contorsion,covd],
						Master-> covd, DefInfo -> If[info, {"antisymmetric contorsion tensor",""}, False],TensorID->{Contorsion,covd}];	
			DefTensor[torsionvec[-a],M,PrintAs -> GiveOutputString[TorsionVector,covd],
						Master-> covd, DefInfo -> If[info, {"torsion vector",""}, False],TensorID->{TorsionVector,covd}];							
																		
			];
			(**** Weyl To Riemann and Riemann To Weyl rules ***)
			WeylToRiemannRules[covd]=ToRule[weylmag[-a,-b,-c,d]==CollectTensors[ToTracelessTensor[riemann[-a,-b,-c,d],1]]];
			RiemannToWeylRules[covd]=ToRule[riemann[-a,-b,-c,d]==CollectTensors[weylmag[-a,-b,-c,d]+
										ToTracelessTensor[riemann[-a,-b,-c,d],2]+ToTraceTensor[riemann[-a,-b,-c,d],2]]];	
		]
	]
];


(* ::Input::Initialization:: *)
RiemannToWeylRules[PD]={};
WeylToRiemannRules[PD]={};
CoRicciToTFCoRicciRules[PD]={};
TFCoRicciToCoRicciRules[PD]={};
RicciToTFRicciRules[PD]={};
TFRicciToRicciRules[PD]={};
DistortionToTFDistortionRules[PD]={};
TFDistortionToDistortionRules[PD]={};
NonMetricityToTFNonMetricityRules[PD]={};
TFNonMetricityToNonMetricityRules[PD]={};
TorsionToTFTorsionRules[PD]={};
TFTorsionToTorsionRules[PD]={};
CoRicciToTFCoRicciRules[covd_?LeviCivitaQ]={};
TFCoRicciToCoRicciRules[covd_?LeviCivitaQ]={};
DistortionToTFDistortionRules[covd_?LeviCivitaQ]={};
TFDistortionToDistortionRules[covd_?LeviCivitaQ]={};
NonMetricityToTFNonMetricityRules[covd_?LeviCivitaQ]={};
TFNonMetricityToNonMetricityRules[covd_?LeviCivitaQ]={};
TorsionToTFTorsionRules[covd_?LeviCivitaQ]={};
TFTorsionToTorsionRules[covd_?LeviCivitaQ]={};


(* ::Input::Initialization:: *)
deflistableCovDs[function_]:=With[{rules=SymbolJoin[function,"Rules"]},
function[expr_]:=function[expr,$CovDs];
function[expr_,list_List]:=Fold[function,expr,list];
function[expr_,covd_Symbol?CovDQ]:=expr/.rules[covd];
SetNumberOfArguments[function,{1,2}];
Protect[function]
];


(* ::Input::Initialization:: *)
deflistablexTensorxMAGCovDs[function_]:=With[{rules=SymbolJoin[function,"Rules"]},
Unprotect[function];
function[xAct`xTensor`Private`expr$_,xAct`xTensor`Private`covd$_Symbol?CovDQ]=.;
If[function===WeylToRiemann,
function[xAct`xTensor`Private`expr$_,xAct`xTensor`Private`covd$_Symbol?(LeviCivitaQ[#]||(TorsionQ[#]&&!NonMetricityQ[#])&)]:=xAct`xTensor`Private`expr$/. xAct`xTensor`Private`WeylToRiemannRules[xAct`xTensor`Private`covd$],
If[function===RiemannToWeyl,
function[xAct`xTensor`Private`expr$_,xAct`xTensor`Private`covd$_Symbol?(LeviCivitaQ[#]||(TorsionQ[#]&&!NonMetricityQ[#])&)]:=xAct`xTensor`Private`expr$/. xAct`xTensor`Private`RiemannToWeylRules[xAct`xTensor`Private`covd$],
If[function===TFRicciToRicci,
function[xAct`xTensor`Private`expr$_,xAct`xTensor`Private`covd$_Symbol?(LeviCivitaQ[#]||(TorsionQ[#]&&!NonMetricityQ[#])&)]:=xAct`xTensor`Private`expr$/. xAct`xTensor`Private`TFRicciToRicciRules[xAct`xTensor`Private`covd$],
If[function===RicciToTFRicci,
function[xAct`xTensor`Private`expr$_,xAct`xTensor`Private`covd$_Symbol?(LeviCivitaQ[#]||(TorsionQ[#]&&!NonMetricityQ[#])&)]:=xAct`xTensor`Private`expr$/. xAct`xTensor`Private`RicciToTFRicciRules[xAct`xTensor`Private`covd$]
]]]];
function[expr_,PD]:=expr/.rules[PD];
function[expr_,covd_?NonMetricityQ]:=expr/.rules[covd];
SetNumberOfArguments[function,{1,2}];
Protect[function]
];


(* ::Input::Initialization:: *)
deflistableCovDs/@{CoRicciToTFCoRicci,TFCoRicciToCoRicci,DistortionToTFDistortion,TFDistortionToDistortion,NonMetricityToTFNonMetricity,TFNonMetricityToNonMetricity,TorsionToTFTorsion,TFTorsionToTorsion};


(* ::Input::Initialization:: *)
deflistablexTensorxMAGCovDs/@{RicciToTFRicci,TFRicciToRicci,RiemannToWeyl,WeylToRiemann};


(* ::Input::Initialization:: *)
GradMetricToNonMetricityRule[covd_?CovDQ,metric_?MetricQ]:=Module[
{vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]
},
With[{a= indices[[1]],
		b= indices[[2]],
		c= indices[[3]],
	nonmetricty=GiveSymbol[NonMetricity,covd]
},
ToRule[covd[-a][metric[-b,-c]]==nonmetricty[-a,-b,-c],MetricOn->{a}]
]
]


(* ::Input::Initialization:: *)
SetGradMetricToNonMetricityRule[covd_?CovDQ,metric_?MetricQ]:=Module[
{vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]},
With[{a= indices[[1]],
	b= indices[[2]],
		c= indices[[3]],
	nonmetricty=GiveSymbol[NonMetricity,covd]
},
AutomaticRules[metric,GradMetricToNonMetricityRule[covd,metric]]
]
]


(* ::Input::Initialization:: *)
(* This would be the place to check the input, but we have nothing to check *)
DefCovDBeginning[covd_[ind_],vbundles_,options___?OptionQ]:=Null;
(* Here we do the actual work *)
DefCovDEnd[covd_[ind_],vbundles_,options___?OptionQ]:=Module[
{metric=OptionValue[DefCovD,{options},DefMAGTensors]},
If[metric=!=Null,MAGDefTensors[covd[ind],metric,options]];
];


(* ::Input::Initialization:: *)
xTension["xMAG`",DefCovD,"Beginning"]:=DefCovDBeginning;
xTension["xMAG`",DefCovD,"End"]:=DefCovDEnd;


(* ::Input::Initialization:: *)
(*** Private Booleen ***)
MAGChristoffelQ[covd_,metric_]:=False


(* ::Input::Initialization:: *)
MAGChristoffelTensorStart[covd_,metric_]:=With[{vb=First@VBundlesOfCovD[covd],M=BaseOfVBundle@First@VBundlesOfCovD[covd],torsionQ=TorsionQ[covd],
magChrisQ=MAGChristoffelQ[covd,metric],covdmet=CovDOfMetric[metric],indices = GetIndicesOfVBundle[First@VBundlesOfCovD[covd], 3]},
With[{a= indices[[1]],b= indices[[2]],c=indices[[3]],distortion= GiveSymbol[Distortion,covd],disformation= GiveSymbol[Disformation,covd],
	contorsion= GiveSymbol[Contorsion,covd],chriscdmetcovd1=GiveSymbol[Christoffel,covdmet,covd]},
(* General tangent bundle connection *)
If[NonMetricityQ[covd,metric]&&TorsionQ[covd]&&!magChrisQ,
	If[!xTensorQ[chriscdmetcovd1],DefTensor[chriscdmetcovd1[a,-b,-c],M,    PrintAs->GiveOutputString[Christoffel,covd,covdmet]]];
chriscdmetcovd1/:chriscdmetcovd1[inds___]:=-distortion[inds];
Print["** Automatic conversion of ", chriscdmetcovd1, " into ", distortion, " is on."]];

If[NonMetricityQ[covd,metric]&&TorsionQ[covd]&&magChrisQ,
Print["** Automatic conversion of ", chriscdmetcovd1, " into ", distortion, " is already on."]];
(* Case: covd TorsionFree tangent bundle connection *)
If[NonMetricityQ[covd,metric]&&!TorsionQ[covd]&&!magChrisQ,
	If[!xTensorQ[chriscdmetcovd1],DefTensor[chriscdmetcovd1[a,-b,-c],M,Symmetric[{2,3}],PrintAs->GiveOutputString[Christoffel,covd,covdmet]]];
	chriscdmetcovd1/:chriscdmetcovd1[inds___]:=-disformation[inds];
	Print["** Automatic conversion of ", chriscdmetcovd1, " into ", disformation, " is on."]];
If[NonMetricityQ[covd,metric]&&!TorsionQ[covd]&&magChrisQ,Print["** Automatic conversion of ", chriscdmetcovd1, " into ", disformation, " is already on."]];
(* Case: covd is metric with torsion *)
If[!NonMetricityQ[covd,metric]&&TorsionQ[covd]&&!magChrisQ,
	If[!xTensorQ[chriscdmetcovd1],
DefTensor[chriscdmetcovd1[a,-b,-c],M,Symmetric[{1,3}],ForceSymmetries->True,PrintAs->GiveOutputString[Christoffel,covd,covdmet]]];
	chriscdmetcovd1/:chriscdmetcovd1[inds___]:=-contorsion[inds];Print["** Automatic conversion of ", chriscdmetcovd1, " into ", contorsion, " is on."]];

If[NonMetricityQ[covd,metric]&&!TorsionQ[covd]&&magChrisQ,Print["** Automatic conversion of ", chriscdmetcovd1, " into ", contorsion, " is already on."]];

MAGChristoffelQ[covd,metric]:=True
]]


(* ::Input::Initialization:: *)
MAGChristoffelTensorStop[covd_,metric_]:=Module[
{vb=First@VBundlesOfCovD[covd],
covdmet=CovDOfMetric[metric],
indices = GetIndicesOfVBundle[First@VBundlesOfCovD[covd], 3]},
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	distortion= GiveSymbol[Distortion,covd],
		disformation= GiveSymbol[Disformation,covd],
		contorsion= GiveSymbol[Contorsion,covd],
	chriscdmetcovd1=GiveSymbol[Christoffel,covdmet,covd]	
},
If[NonMetricityQ[covd,metric]&&TorsionQ[covd],
	chriscdmetcovd1/:chriscdmetcovd1[inds___]=.;
Print["** Automatic conversion of ", chriscdmetcovd1, " into ", distortion, " is off."]];
If[NonMetricityQ[covd,metric]&&!TorsionQ[covd],
	chriscdmetcovd1/:chriscdmetcovd1[inds___]=.;
Print["** Automatic conversion of ", chriscdmetcovd1, " into ", disformation, " is off."]];
If[!NonMetricityQ[covd,metric]&&TorsionQ[covd],
	chriscdmetcovd1/:chriscdmetcovd1[inds___]=.;
Print["** Automatic conversion of ", chriscdmetcovd1, " into ", contorsion, " is off."]];
MAGChristoffelQ[covd,metric]:=False;
]
]


(* ::Input::Initialization:: *)
TorsionToDistortion::def="`1` has no torsion.";


(* ::Input::Initialization:: *)
NonMetricityToDistortion::def="`1` is compatible with the metric `2`.";


(* ::Input::Initialization:: *)
RicciScalarToRiemann[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,vb=VBundleOfMetric[metric],indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 4],nmQ=NonMetricityQ[covd,metric],
M=BaseOfVBundle@VBundleOfMetric[metric]
},
With[{a= indices[[1]],c= indices[[3]],
	riemannMAG=GiveSymbol[Riemann,covd],
	ricciscalar=GiveSymbol[RicciScalar,covd]
	},
If[SameQ[metric,$Metrics[[1]]],
	If[nmQ,
	rule=MakeRule[{ricciscalar[],riemannMAG[a, -c, -a,c]}];
	Return[exp/.rule],Return[exp]];
]]
];
ruleTraceRicciScalarpower[covd_?CovDQ,metric_?MetricQ]:={(GiveSymbol[RicciScalar,covd][])^n_Integer/;Greater[n,1]:>Product[RicciScalarToRiemann[(GiveSymbol[RicciScalar,covd][]),covd,metric],{i,1,n}],GiveSymbol[RicciScalar,covd][]->RicciScalarToRiemann[(GiveSymbol[RicciScalar,covd][]),covd,metric]}


(* ::Input::Initialization:: *)
TracesToRiemann[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 4],
covdmetric=CovDOfMetric[metric],
nmQ=NonMetricityQ[covd,metric],
torsionQ=TorsionQ[covd],
M=BaseOfVBundle@VBundleOfMetric[metric]
},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	d= indices[[4]],
	riemannMAG=GiveSymbol[Riemann,covd],
	homothetic=GiveSymbol[Homothetic,covd],
	coRicci=GiveSymbol[CoRicci,covd],
	ricci=GiveSymbol[Ricci,covd],
	ricciscalar=GiveSymbol[RicciScalar,covd]
	},
If[SameQ[metric,$Metrics[[1]]],
	If[nmQ,
	If[CurvatureRelationsQ[covd],
	ClearCurvatureRelations[covd]];
	rule=Join[MakeRule[{homothetic[-b, -c],riemannMAG[-c, -b, -a, a]}],MakeRule[{coRicci[a, -b],riemannMAG[d, -b, -d, a]}],MakeRule[{ricci[a, -b],riemannMAG[a, -c, -b,c]}]];
	Return[exp/.ruleTraceRicciScalarpower[covd,metric]/.rule],Return[exp]];
];
]
]


(* ::Input::Initialization:: *)
TracesToRiemann[exp_,covd_?CovDQ]:=TracesToRiemann[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
TracesToRiemann[exp_]:=TracesToRiemann[exp,Part[$CovDs,3]]


(* ::Input::Initialization:: *)
BreakMAGRiemann[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 4],
covdmetric=CovDOfMetric[metric]
},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	d= indices[[4]],
	riemannmetric=GiveSymbol[Riemann,covdmetric],
	riemannMAG=GiveSymbol[Riemann,covd],
	nriemann=GiveSymbol[NRiemann,covd]
	},
If[SameQ[metric,$Metrics[[1]]],
	rule=ToRule[riemannMAG[-a,-b,-c,d]==riemannmetric[-a,-b,-c,d]+nriemann[-a,-b,-c,d]];
	Return[exp/.rule],
	rule=ToRule[riemannMAG[-a,-b,-c,d]==riemannmetric[-a,-b,-c,d]+nriemann[-a,-b,-c,d],MetricOn->None];
	Return[exp/.rule]
	];
]
]


(* ::Input::Initialization:: *)
BreakMAGWeyl[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 4],
covdmetric=CovDOfMetric[metric]
},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	d= indices[[4]],
	riemannmetric=GiveSymbol[Riemann,covdmetric],
	riemannMAG=GiveSymbol[Riemann,covd],
	nriemann=GiveSymbol[NRiemann,covd],
	weylmetric=GiveSymbol[Weyl,covdmetric],
	weylmag=GiveSymbol[Weyl,covd],
	nweylmag=GiveSymbol[NWeyl,covd]
	},
If[SameQ[metric,$Metrics[[1]]],
	rule=ToRule[weylmag[-a,-b,-c,d]==weylmetric[-a,-b,-c,d]+nweylmag[-a,-b,-c,d]];
	Return[exp/.rule],
	rule=ToRule[weylmag[-a,-b,-c,d]==weylmetric[-a,-b,-c,d]+nweylmag[-a,-b,-c,d],MetricOn->None];
	Return[exp/.rule]
	];
]
]


(* ::Input::Initialization:: *)
BreakRiemann[exp_,covd_?CovDQ]:=BreakRiemann[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
BreakRiemann[exp_]:=BreakRiemann[exp,Part[$CovDs,3]]

BreakMAGWeyl[exp_,covd_?CovDQ]:=BreakMAGWeyl[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
BreakMAGWeyl[exp_]:=BreakMAGWeyl[exp,Part[$CovDs,3]]


(* ::Input::Initialization:: *)
BreakDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,vb=VBundleOfMetric[metric],indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]},
With[{i1= indices[[1]],
		i2= indices[[2]],
	i3= indices[[3]],
	distortion=GiveSymbol[Distortion,covd],
	nonmetricity=GiveSymbol[NonMetricity,covd],
		torsion=GiveSymbol[Torsion,covd]
	},
	rule=MakeRule[{distortion[i1,-i2,-i3],(1/2)*nonmetricity[i1, -i2, -i3] - (1/2)*nonmetricity[-i2, i1, -i3] 
	- (1/2)*nonmetricity[-i3, i1, -i2] +  (1/2)*torsion[i1, -i2, -i3] + (1/2)*torsion[-i2, i1, -i3] + (1/2)*torsion[-i3, i1, -i2]}];
	exp/.(Flatten@(InverseMakeRule/@ConnectionRelations[covd]))/.rule
	]
]


(* ::Input::Initialization:: *)
BreakContorsion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	torsion=GiveSymbol[Torsion,covd],
	contorsion= GiveSymbol[Contorsion,covd]
	},
	rule=MakeRule[{contorsion[a,-b,-c],1/2*torsion[a,-b,-c]+1/2torsion[-b,a,-c]+1/2*torsion[-c,a,-b]}];
	exp/.(Flatten@(InverseMakeRule/@ConnectionRelations[covd]))/.rule
	]
]


(* ::Input::Initialization:: *)
BreakDisformation[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	nonmetricity=GiveSymbol[NonMetricity,covd],
	disformation= GiveSymbol[Disformation,covd]
	},
	rule=MakeRule[{disformation[a,-b,-c],1/2*nonmetricity[a,-b,-c]-1/2*nonmetricity[-b,a,-c]-1/2*nonmetricity[-c,a,-b]}];
	exp/.(Flatten@(InverseMakeRule/@ConnectionRelations[covd]))/.rule
	]
]


(* ::Input::Initialization:: *)
DisformationToDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],
nmQ=NonMetricityQ[covd,metric],
torsionQ=TorsionQ[covd],
res},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	distortion=GiveSymbol[Distortion,covd],
	disformation= GiveSymbol[Disformation,covd]
	},
	If[nmQ, 
	rule=ToRule[disformation[a,-b,-c]==(1/2)*distortion[a, -b, -c] + (1/2)*distortion[a, -c, -b] - (1/2)*distortion[-b, a, -c] 
+ (1/2)*distortion[-b, -c, a] - (1/2)*distortion[-c, a, -b] + (1/2)*distortion[-c, -b, a]];
	res=exp/.rule
	];
res
]
]


(* ::Input::Initialization:: *)
ContorsionToDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],
nmQ=NonMetricityQ[covd,metric],
torsionQ=TorsionQ[covd],
res},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	distortion=GiveSymbol[Distortion,covd],
	contorsion= GiveSymbol[Contorsion,covd]
	},
If[torsionQ, rule=ToRule[contorsion[a,-b,-c]==(1/2)*distortion[a, -b, -c] - (1/2)*distortion[a, -c, -b] + (1/2)*distortion[-b, a, -c] - (1/2)*distortion[-b, -c, a] + (1/2)*distortion[-c, a, -b] -  (1/2)*distortion[-c, -b, a]];
res=exp/.rule
];
res
]
]


(* ::Input::Initialization:: *)
NonMetricityToDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{res1,res2,rule,vb=VBundleOfMetric[metric],indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],
nmQ=NonMetricityQ[covd,metric],torsionQ=TorsionQ[covd]},
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	nonmetricity=GiveSymbol[NonMetricity,covd],
	disformation=GiveSymbol[Disformation,covd],
	distortion= GiveSymbol[Distortion,covd]
	},
	If[!nmQ,Message[NonMetricityToDistortion::def,covd,metric]];
	If[nmQ&&torsionQ,
	rule=ToRule[nonmetricity[-a, -b, -c] == -distortion[-b, -a, -c] - distortion[-c, -a, -b]];
	res1=exp/.rule
	];
	If[nmQ&&!torsionQ,
	rule=ToRule[nonmetricity[-a, -b, -c] == -disformation[-b, -a, -c] - disformation[-c, -a, -b]];
	res2=exp/.rule
	];
	Piecewise[{{res1,nmQ&&torsionQ},{res2,nmQ&&!torsionQ},{exp,!nmQ}}]
	]
]


(* ::Input::Initialization:: *)
NonMetricityToDisformation[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	nonmetricity=GiveSymbol[NonMetricity,covd],
	disformation= GiveSymbol[Disformation,covd]
	},
	rule=ToRule[nonmetricity[-a, -b, -c] == -disformation[-b, -a, -c] - disformation[-c, -a, -b]];
	exp/.rule
	]
]


(* ::Input::Initialization:: *)
TorsionToDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
res1,
res2,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],
nmQ=NonMetricityQ[covd,metric],
torsionQ=TorsionQ[covd]
},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	torsion=GiveSymbol[Torsion,covd],
	distortion= GiveSymbol[Distortion,covd],
	contorsion=GiveSymbol[Contorsion,covd]
	},
	If[!torsionQ,
	Message[TorsionToDistortion::def, covd]];
	If[nmQ&&torsionQ,
	rule=ToRule[torsion[a,-b,-c]==2Antisymmetrize[distortion[a,-b,-c],{-b,-c}]];
	res1=exp/.rule
	];
	If[!nmQ&&torsionQ,
	rule=ToRule[torsion[a,-b,-c]==2Antisymmetrize[contorsion[a,-b,-c],{-b,-c}]];
	res2=exp/.rule
	];
	Piecewise[{{res1,nmQ&&torsionQ},{res2,!nmQ&&torsionQ},{exp,!torsionQ}}]
]
]


(* ::Input::Initialization:: *)
TorsionToContorsion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]
},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	torsion=GiveSymbol[Torsion,covd],
	contorsion= GiveSymbol[Contorsion,covd]
	},
		rule=ToRule[torsion[a,-b,-c]==2Antisymmetrize[contorsion[a,-b,-c],{-b,-c}]];
		exp/.rule
	]
]


(* ::Input::Initialization:: *)
BreakDistortion[exp_,covd_?CovDQ]:=BreakDistortion[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
BreakDistortion[exp_]:=BreakDistortion[exp,Part[$CovDs,3]]

BreakDisformation[exp_,covd_?CovDQ]:=BreakDisformation[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
BreakDisformation[exp_]:=BreakDisformation[exp,Part[$CovDs,3]]

BreakContorsion[exp_,covd_?CovDQ]:=BreakContorsion[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
BreakContorsion[exp_]:=BreakContorsion[exp,Part[$CovDs,3]]

DisformationToDistortion[exp_,covd_?CovDQ]:=DisformationToDistortion[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
DisformationToDistortion[exp_]:=DisformationToDistortion[exp,Part[$CovDs,3]]

ContorsionToDistortion[exp_,covd_?CovDQ]:=ContorsionToDistortion[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
ContorsionToDistortion[exp_]:=ContorsionToDistortion[exp,Part[$CovDs,3]]

NonMetricityToDistortion[exp_,covd_?CovDQ]:=NonMetricityToDistortion[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
NonMetricityToDistortion[exp_]:=NonMetricityToDistortion[exp,Part[$CovDs,3]]

NonMetricityToDisformation[exp_,covd_?CovDQ]:=NonMetricityToDisformation[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
NonMetricityToDisformation[exp_]:=NonMetricityToDisformation[exp,Part[$CovDs,3]]

TorsionToDistortion[exp_,covd_?CovDQ]:=TorsionToDistortion[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
TorsionToDistortion[exp_]:=TorsionToDistortion[exp,Part[$CovDs,3]]

TorsionToContorsion[exp_,covd_?CovDQ]:=TorsionToContorsion[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],1]]
TorsionToContorsion[exp_]:=TorsionToContorsion[exp,Part[$CovDs,3]]


(* ::Input::Initialization:: *)
ToDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{indices = GetIndicesOfVBundle[VBundleOfMetric[metric],3],covdmetric=CovDOfMetric[metric],
nmQ=NonMetricityQ[covd,metric],torsionQ=TorsionQ[covd],res1,res2,res3
},
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	torsion=GiveSymbol[Torsion,covd],
	contorsion= GiveSymbol[Contorsion,covd]
	},
If[!MAGChristoffelQ[covd,metric],MAGChristoffelTensorStart[covd,metric]];
If[nmQ&&torsionQ,
If[ConnectionRelationsQ[covd]===True,ClearConnectionRelations[covd]];res1=DisformationToDistortion[ContorsionToDistortion[TorsionToDistortion[NonMetricityToDistortion[ChangeCovD[ChangeCurvature[TracesToRiemann[WeylToRiemann[exp],covd,metric],covd,covdmetric],covd,covdmetric],covd,metric],covd,metric],covd,metric],covd,metric]];
	If[!nmQ&&torsionQ,
	If[ConnectionRelationsQ[covd]===True,ClearConnectionRelations[covd]];
	res2=NoScalar[TorsionToDistortion[ChangeCovD[ChangeCurvature[TracesToRiemann[exp,covd,metric],covd,covdmetric],covd,covdmetric],covd,metric]]];
	If[nmQ&&!torsionQ,
	If[ConnectionRelationsQ[covd]===True,ClearConnectionRelations[covd]];
	res3=NonMetricityToDistortion[ChangeCovD[ChangeCurvature[TracesToRiemann[exp,covd,metric],covd,covdmetric],covd,covdmetric],covd,metric]];
	Piecewise[{{res1,nmQ&&torsionQ},{res2,!nmQ&&torsionQ},{res3,nmQ&&!torsionQ}}]
	]
]


(* ::Input::Initialization:: *)
ToDistortion[exp_,covd_?CovDQ]:=ToDistortion[exp,covd,$Metrics[[1]]]
ToDistortion[exp_]:=ToDistortion[exp,Part[$CovDs,3]]


(* ::Input::Initialization:: *)
TraceFreeQ[tensor_?xTensorQ,inds___List,metric_?MetricQ]:=Module[{mettraces,traces,tfQ},
mettraces=Map[metric@@#&,ChangeIndex/@Subsets[inds,{2}]];
traces=Map[ContractMetric[ToCanonical[tensor@@inds*#],metric]&,mettraces];
If[AllTrue[traces,#===0&],tfQ=True,tfQ=False];
tfQ
];
TraceFreeQ[tensor_,metric_?MetricQ]:=TraceFreeQ[Head@tensor,List@@tensor,metric];
TraceFreeQ[tensor_]:=TraceFreeQ[Head@tensor,List@@tensor,$Metrics[[1]]];


(* ::Input::Initialization:: *)
Options[DefIRD]:={IRDMethod->YoungProject,ManifestSymmetry->Antisymmetric}
DefIRD[tensor_?xTensorQ,inds_List,indsmapping_List,options:OptionsPattern[]]:=Module[{deg=Length[inds],sdttab,ruleindex,indtabs,assotensor,M=Sequence@@DependenciesOfTensor[tensor],method,listtabtensor,manifsym,symtensor=SymmetryGroupOfTensor[tensor],maxsym,tfQ,tftensor,tensorSymbol},
{method}=OptionValue[{DefIRD},{options},{IRDMethod}];
{manifsym}=OptionValue[{DefIRD},{options},{ManifestSymmetry}];
If[manifsym===Antisymmetric,
sdttab=Reverse@StdTableaux[deg],sdttab=StdTableaux[deg]];
ruleindex=MapThread[#1->#2&,{indsmapping,inds}];
indtabs=sdttab/.ruleindex;
tfQ=TraceFreeQ[tensor@@inds];
(***********************************************************************************************************)
(************* If the tensor is already tracefree we decompose it with Young/SNYoung operators *************)
(***********************************************************************************************************)
If[tfQ,
If[TensorID[tensor]=!={},tensorSymbol=TensorID[tensor][[1]],tensorSymbol=tensor];
If[method===YoungProject,
listtabtensor=Map[#->ToCanonical[YoungProject2[tensor@@inds,#,ManifestSymmetry->manifsym]]&,indtabs];
];
If[method===SNYoungProject,
listtabtensor=Map[#->ToCanonical[SNYoungProject[tensor@@inds,#]]&,indtabs];
];
listtabtensor=DeleteCases[listtabtensor,a_List->0];
indtabs=Map[#[[1]]&,listtabtensor];
tensorSymbol[TensorID[tensor][[2]],"IRD",n_Integer]:=GiveSymbol[tensorSymbol,TensorID[tensor][[2]],"IRD",n];
assotensor=Map[#[[1]]->tensorSymbol[TensorID[tensor][[2]],"IRD",Sequence@@#[[2]]]&,Normal@PositionIndex@indtabs];
If[MasterOf[tensor]=!={},
Map[DefTensor[#[[2]]@@inds,M,PrintAs->xMAGIRDPrint[tensorSymbol,TensorID[tensor][[2]],ToExpression@StringTake[ToString[#[[2]]],-1]]]&,assotensor],
Map[DefTensor[#[[2]]@@inds,M,PrintAs->xMAGPrint[tensor,ToExpression@StringTake[ToString[#[[2]]],-1]]]&,assotensor]];
IRDMapping[tensor]:=Map[#[[1]]->HoldFirst[#[[2]]@@inds]&,assotensor];
IRDRules[tensor]:=Flatten@Map[ToRule[#[[1]]@@inds==#[[2]]]&,MapThread[{#1,#2}&,{Map[#[[2]]&,assotensor],Map[#[[2]]&,listtabtensor]}]]];
(*****************************************************************************************************************************)
(**** If the tensor is not tracefree we project the tensor onto it tracefree part  and then apply Young/SNYoung operators ****)
(*****************************************************************************************************************************)
If[!tfQ,
		If[TensorID[tensor]==={},tftensor=ToExpression[StringJoin["TF",ToString[tensor]]]];
		If[TensorID[tensor][[1]]===Riemann,
		tftensor=ToExpression[StringJoin[ToString[Weyl],ToString[TensorID[tensor][[2]]]]],
		tftensor=ToExpression[StringJoin["TF",ToString[tensor]]]]];
If[xTensorQ[tftensor],
If[TensorID[tftensor]=!={},tensorSymbol=TensorID[tftensor][[1]],tensorSymbol=tftensor];
	If[method===YoungProject,
	listtabtensor=Map[#->ToCanonical[YoungProject2[tftensor@@inds,#,ManifestSymmetry->manifsym]]&,indtabs]];
	If[method===SNYoungProject,
	listtabtensor=Map[#->ToCanonical[SNYoungProject[tftensor@@inds,#]]&,indtabs]];
listtabtensor=DeleteCases[listtabtensor,a_List->0];
indtabs=Map[#[[1]]&,listtabtensor];
tensorSymbol[TensorID[tftensor][[2]],"IRD",n_Integer]:=GiveSymbol[tensorSymbol,TensorID[tftensor][[2]],"IRD",n];
assotensor=Map[#[[1]]->tensorSymbol[TensorID[tensor][[2]],"IRD",Sequence@@#[[2]]]&,Normal@PositionIndex@indtabs];
If[MasterOf[tensor]=!={},
Map[DefTensor[#[[2]]@@inds,M,PrintAs->xMAGIRDPrint[TensorID[tftensor][[1]],TensorID[tftensor][[2]],ToExpression@StringTake[ToString[#[[2]]],-1]]]&,assotensor],
Map[DefTensor[#[[2]]@@inds,M,PrintAs->xMAGPrint[tensor,ToExpression@StringTake[ToString[#[[2]]],-1]]]&,assotensor]];
IRDMapping[tensor]:=Map[#[[1]]->HoldFirst[#[[2]]@@inds]&,assotensor];
IRDRules[tensor]:=Flatten@Map[ToRule[#[[1]]@@inds==#[[2]]]&,MapThread[{#1,#2}&,{Map[#[[2]]&,assotensor],Map[#[[2]]&,listtabtensor]}]]]
]


(* ::Input::Initialization:: *)
UndefIRD[tensor_?xTensorQ,options:OptionsPattern[]]:=Module[{},Map[UndefTensor[Head[#[[2,1]]]]&,IRDMapping[tensor]];IRDMapping[tensor]=.;
IRDRules[tensor]=.;];


(* ::Input::Initialization:: *)
DefIRD[tensor_?xTensorQ,inds_List,options:OptionsPattern[]]:=DefIRD[tensor,inds,Range[Length[inds]],options];
DefIRD[tensorfunc_,indsmapping_List,options:OptionsPattern[]]:=DefIRD[Head@tensorfunc,List@@tensorfunc,indsmapping,options];
DefIRD[tensorfunc_,options:OptionsPattern[]]:=DefIRD[Head@tensorfunc,List@@tensorfunc,options];


(* ::Input::Initialization:: *)
PrintAsCharacter[LinearVector]="\[Xi]";


(* ::Input::Initialization:: *)
LinearVector[int_Integer]:=ToExpression[StringJoin[ToString[LinearVector],ToString[int]]];


(* ::Input::Initialization:: *)
StartLinearTransformations[covd_]:=Module[{M=$Manifolds[[1]],TM=TangentBundleOfManifold[$Manifolds[[1]]],
a},
a=IndicesOfVBundle[TM][[1,1]];
With[{vect1=GiveSymbol[LinearVector,1],vect2=GiveSymbol[LinearVector,2],vect3=GiveSymbol[LinearVector,3]},
If[!xTensorQ[vect1],
DefTensor[vect1[a],M,PrintAs-> xMAGIRDPrint[LinearVector,covd,1]];
DefTensor[vect2[a],M,PrintAs-> xMAGIRDPrint[LinearVector,covd,2]];
DefTensor[vect3[a],M,PrintAs-> xMAGIRDPrint[LinearVector,covd,3]]
];
]
];


(* ::Input::Initialization:: *)
LinearTransformations[covd_?CovDQ,metric_?MetricQ]:=Module[
{vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric],3],
M=BaseOfVBundle@First@VBundlesOfCovD[covd],nmQ=NonMetricityQ[covd,metric],torsionQ=TorsionQ[covd],
vector1=GiveSymbol[LinearVector,1],vector2=GiveSymbol[LinearVector,2],vector3=GiveSymbol[LinearVector,3]
},
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	distortion=GiveSymbol[Distortion,covd]},
If[!xTensorQ[vector1],StartLinearTransformations[covd]];
{MakeRule[{distortion[a,b,c],distortion[a,b,c]+metric[a,b]vector1[c]},MetricOn->All],MakeRule[{distortion[a,b,c],distortion[a,b,c]+metric[a,c]vector2[b]},MetricOn->All],MakeRule[{distortion[a,b,c],distortion[a,b,c]+metric[b,c]vector3[a]},MetricOn->All],MakeRule[{distortion[a,b,c],distortion[a,b,c]+metric[a,b]vector1[c]+metric[a,c]vector2[b]+metric[b,c]vector3[a]},MetricOn->All]}
]
];
LinearTransformations[covd_?CovDQ]:=LinearTransformations[covd,$Metrics[[1]]];
LinearTransformations[]:=LinearTransformations[$CovDs[[3]]];


(* ::Input::Initialization:: *)
LinearTransform[kind___Integer,exp_,covd_?CovDQ,metric_?MetricQ]:=Module[{
vector1=GiveSymbol[LinearVector,1],vector2=GiveSymbol[LinearVector,2],vector3=GiveSymbol[LinearVector,3],distortion=GiveSymbol[Distortion,covd]},
Collect[(ToDistortion[exp,covd,metric])/.LinearTransformations[covd,metric][[kind]],{_metric,_delta,_vector1,_vector2,_vector3,_distortion},Factor]
];
LinearTransform[exp_,covd_?CovDQ,metric_?MetricQ]:=LinearTransform[4,exp,covd,metric];
LinearTransform[kind___Integer,exp_,covd_?CovDQ]:=LinearTransform[kind,exp,covd,$Metrics[[1]]];
LinearTransform[kind___Integer,exp_]:=LinearTransform[kind,exp,$CovDs[[3]]];


(* ::Input::Initialization:: *)
Options[ProjectiveTransformation]:={Symmetric->False}
ProjectiveTransformation[covd_?CovDQ,metric_?MetricQ,options:OptionsPattern[]]:=Module[{vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric],3],M=BaseOfVBundle@First@VBundlesOfCovD[covd],nmQ=NonMetricityQ[covd,metric],torsionQ=TorsionQ[covd],
vector1=GiveSymbol[LinearVector,1],vector2=GiveSymbol[LinearVector,2],vector3=GiveSymbol[LinearVector,3],sym},
{sym}=OptionValue[{ProjectiveTransformation},{options},{Symmetric}];
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	distortion=GiveSymbol[Distortion,covd]},
If[sym,Return[MakeRule[{distortion[a,b,c],distortion[a,b,c]+metric[a,b]vector2[c]+metric[a,c]vector2[b]},MetricOn->All],Module]];
LinearTransformations[covd,metric][[2]]]
];
ProjectiveTransformation[covd_?CovDQ,options:OptionsPattern[]]:=ProjectiveTransformation[covd,$Metrics[[1]],options];
ProjectiveTransformation[options:OptionsPattern[]]:=ProjectiveTransformation[$CovDs[[3]],options];

Options[ProjectiveTransform]:={Symmetric->False}
ProjectiveTransform[exp_,covd_?CovDQ,metric_?MetricQ,options:OptionsPattern[]]:=Module[{vector1=GiveSymbol[LinearVector,1],vector2=GiveSymbol[LinearVector,2],vector3=GiveSymbol[LinearVector,3],distortion=GiveSymbol[Distortion,covd],sym},
{sym}=OptionValue[{ProjectiveTransform},{options},{Symmetric}];
If[sym,Return[Collect[(ToDistortion[exp,covd,metric])/.ProjectiveTransformation[covd,metric,Symmetric->sym],{_metric,_delta,_vector2,_distortion},Factor],Module]
];
LinearTransform[2,exp,covd,metric]
];

ProjectiveTransform[exp_,covd_?CovDQ,options:OptionsPattern[]]:=ProjectiveTransform[exp,covd,$Metrics[[1]],options];
ProjectiveTransform[exp_,options:OptionsPattern[]]:=ProjectiveTransform[exp,$CovDs[[3]],options];


(* ::Input::Initialization:: *)
DefDistortionADMComp[covd_,indmetric_]:=Module[
{metric=Part[InducedFrom[indmetric],1],
nv=Part[InducedFrom[indmetric],2],
vb=VBundleOfMetric[indmetric],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],6],
M=ManifoldOfCovD[covd],
Chhh=GiveSymbol[Distortion,covd,indmetric,indmetric,indmetric]
},
With[
{torsionQ=TorsionQ[covd],
nonmetricityQ=NonMetricityQ[covd,metric],
a= indices[[1]],
b= indices[[2]],
c= indices[[3]],
d= indices[[4]],
i= indices[[5]],
j= indices[[6]],
tm=TangentBundleOfManifold[M],
Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
Chnh=GiveSymbol[Distortion,covd,indmetric,nv,indmetric],
Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric],
Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
Cnhn=GiveSymbol[Distortion,covd,nv,indmetric,nv],
Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv],
ChhhQ=xTensorQ@Chhh,
distortion=GiveSymbol[Distortion,covd]
},
If[InducedFrom[indmetric]===Null,Throw@Print[indmetric," is not an induced metric"]];
If[!ChhhQ,
If[torsionQ&&nonmetricityQ,
DefTensor[Chhh[a,-b,-c],M,OrthogonalTo->{nv[-a],nv[b],nv[c]},ProjectedWith->{indmetric[-a,d],indmetric[b,-i],indmetric[c,-j]},PrintAs->xMAGPrint[Distortion,Null,indmetric]];
DefTensor[Chhn[a,-b],M,OrthogonalTo->{nv[-a],nv[b]},ProjectedWith->{indmetric[-a,d],indmetric[b,-i]},PrintAs->xMAGPrint[Distortion,3,nv]];
DefTensor[Chnh[a,-b],M,OrthogonalTo->{nv[-a],nv[b]},ProjectedWith->{indmetric[-a,d],indmetric[b,-i]},PrintAs->xMAGPrint[Distortion,2,nv]];
DefTensor[Cnhh[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Distortion,1,nv]];
DefTensor[Cnnh[-a],M,OrthogonalTo->{nv[a]},ProjectedWith->{indmetric[a,-d]},PrintAs->xMAGPrint[Distortion,3,indmetric]];
DefTensor[Cnhn[-a],M,OrthogonalTo->{nv[a]},ProjectedWith->{indmetric[a,-d]},PrintAs->xMAGPrint[Distortion,2,indmetric]];
DefTensor[Chnn[a],M,OrthogonalTo->{nv[-a]},ProjectedWith->{indmetric[-a,d]},PrintAs->xMAGPrint[Distortion,1,indmetric]];
DefTensor[Cnnn[],M,PrintAs->xMAGPrint[Distortion,Null,nv]];
];
,Throw@Print["** The ADM components of ",distortion, " are already defined"]];
]
]


(* ::Input::Initialization:: *)
UndefDistortionADMComp[covd_,indmetric_]:=Module[
{torsionQ=TorsionQ[covd],
nonmetricityQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
nv=Part[InducedFrom[indmetric],2]
},
With[{
Chhh=GiveSymbol[Distortion,covd,indmetric,indmetric,indmetric],
Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
Chnh=GiveSymbol[Distortion,covd,indmetric,nv,indmetric],
Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric],
Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
Cnhn=GiveSymbol[Distortion,covd,nv,indmetric,nv],
Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv]
},
If[torsionQ&&nonmetricityQ,
UndefTensor[Chhh];
UndefTensor[Chhn];
UndefTensor[Chnh];
UndefTensor[Cnhh];
UndefTensor[Cnnh];
UndefTensor[Cnhn];
UndefTensor[Chnn];
UndefTensor[Cnnn];
];
]
]


(* ::Input::Initialization:: *)
DefDistortionADMComp[covd_]:=DefDistortionADMComp[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
DefDistortionADMComp[]:=DefDistortionADMComp[Part[$CovDs,3]]
UndefDistortionADMComp[covd_]:=UndefDistortionADMComp[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
UndefDistortionADMComp[]:=UndefDistortionADMComp[Part[$CovDs,3]]


(* ::Input::Initialization:: *)
DistortionToADM[expr_,covd_,indmetric_]:=Module[
{
nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],3]
},
With[
{
nv=Part[InducedFrom[indmetric],2],
a= indices[[1]],
b= indices[[2]],
c= indices[[3]],
distortion=GiveSymbol[Distortion,covd]
},
With[{Chhh=GiveSymbol[Distortion,covd,indmetric,indmetric,indmetric],
	Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
	Chnh=GiveSymbol[Distortion,covd,indmetric,nv,indmetric],
	Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric],
	Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
	Cnhn=GiveSymbol[Distortion,covd,nv,indmetric,nv],
	Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
	Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv]
	},
	If[nonmetQ&&torsionQ,
	RuleDistortionToADM=
	MakeRule[{distortion[a,-b,-c],Chhh[a, -b, -c] -Cnhh[-b, -c]*nv[a] - Chnh[a, -c]*nv[-b] - Chhn[a, -b]*nv[-c]  + Cnnh[-c]*nv[a]*nv[-b]+ Cnhn[-b]*nv[a]*nv[-c] + Chnn[a]*nv[-b]*nv[-c] - Cnnn[]*nv[a]*nv[-b]*nv[-c]}];
	];
	Return[expr/.RuleDistortionToADM]
]
]
]


(* ::Input::Initialization:: *)
DistortionToADM[expr_,covd_]:=DistortionToADM[expr,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
DistortionToADM[expr_]:=DistortionToADM[expr,Part[$CovDs,3]]


(* ::Input::Initialization:: *)
AutomaticDistortionToADMQ[covd_,indmetric_]:=False


(* ::Input::Initialization:: *)
Options[DistortionToADMStart]:={Verbose->True}
DistortionToADMStart[covd_,indmetric_,options:OptionsPattern[]]:=Module[
	{metric=Part[InducedFrom[indmetric],1],
	vb=VBundleOfMetric[indmetric],
	indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],7],
	M=ManifoldOfCovD[covd],
	autoruleQ=AutomaticDistortionToADMQ[covd,indmetric],
	verbose,
	rule
	},
								(* Options*)
	{verbose}=OptionValue[{DistortionToADMStart},{options},{Verbose}];
With[{
	nv=Part[InducedFrom[indmetric],2],
	torsionQ=TorsionQ[covd],
	nonmetricityQ=NonMetricityQ[covd,metric],
	a= indices[[1]],
	b= indices[[2]],
	c= indices[[3]],
	d= indices[[4]],
	i= indices[[5]],
	j= indices[[6]],
	k= indices[[7]],
	distortion=GiveSymbol[Distortion,covd]
	},
	With[{
		Chhh=GiveSymbol[Distortion,covd,indmetric,indmetric,indmetric],
		Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
		Chnh=GiveSymbol[Distortion,covd,indmetric,nv,indmetric],
		Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric],
		Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
		Cnhn=GiveSymbol[Distortion,covd,nv,indmetric,nv],
		Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
		Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv]
	},
													(* General case *)
	If[autoruleQ&&verbose,Throw@Print["** Automatic conversion of the contractions of the distortion tensor with ",PrintAs@indmetric," and ", PrintAs@ nv, " to "  ,"its ADM components is already on"]];

	If[!autoruleQ&&verbose,Print["** Automatic conversion of the contractions of the distortion tensor with ",PrintAs@indmetric," and ", PrintAs@ nv, " to "  ,"its ADM components is on"]];

	If[torsionQ&&nonmetricityQ&&!autoruleQ,

	rule=Join[
		MakeRule[{indmetric[-a,i]*indmetric[-b,j]*indmetric[-c,k]*distortion[a, b, c],Chhh[i,j,k]}],MakeRule[{distortion[j, -i, -c]*indmetric[a, -j]*indmetric[b, i]*nv[c] ,Chhn[a, b]}],MakeRule[{ distortion[i, -b, j]*indmetric[a, -i]*indmetric[c, -j]*nv[b] , Chnh[a, c]}],
MakeRule[{distortion[a, -i, j]*indmetric[b, i]*indmetric[c, -j]*nv[-a]  ,  Cnhh[b, c]}],
MakeRule[{distortion[a, -b, -i]*indmetric[-a, d]*nv[i]*nv[b]  ,  Chnn[d]}],
MakeRule[{distortion[a, -b, i]*indmetric[c, -i]*nv[-a]*nv[b]  ,  Cnnh[c]}],
MakeRule[{ distortion[a, i, -c]*indmetric[b, -i]*nv[-a]*nv[c] ,  Cnhn[b]}],
MakeRule[{distortion[a, -b, -c]*nv[-a]*nv[b]*nv[c],  Cnnn[]}]];

	AutomaticRules[distortion,rule,Verbose->False];

	RuleADistortionToADM[covd,indmetric]:=rule;
	];
	AutomaticDistortionToADMQ[covd,indmetric]:=True;
]
]
]


(* ::Input::Initialization:: *)
Options[DistortionToADMStop]:={Verbose->True}
DistortionToADMStop[covd_,indmetric_,options:OptionsPattern[]]:=Module[
{torsionQ=TorsionQ[covd],
nonmetricityQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
M=ManifoldOfCovD[covd],
verbose,
autoruleQ=AutomaticDistortionToADMQ[covd,indmetric]
},
With[{nv=Part[InducedFrom[indmetric],2],
	distortion=GiveSymbol[Distortion,covd]
	},
								(* Options*)
	{verbose}=OptionValue[{DistortionToADMStop},{options},{Verbose}];
								(* Messages *)
If[!autoruleQ&&verbose,Throw@Print["** Automatic conversion of the contractions of the distortion tensor with ",PrintAs@indmetric," and ", PrintAs@ nv, " to "  ,"its ADM components is already off"]];

If[autoruleQ&&verbose,Print["** Automatic conversion of the contractions of the distortion tensor with ",PrintAs@indmetric," and ", PrintAs@ nv, " to "  ,"its ADM components is off"]];
(* General case *)
If[autoruleQ&&torsionQ&&nonmetricityQ,
		ClearAutomaticRules[distortion,RuleADistortionToADM[covd,indmetric],Verbose->False];
];
AutomaticDistortionToADMQ[covd,indmetric]:=False;
]
]


(* ::Input::Initialization:: *)
DistortionToADMStart[covd_,options:OptionsPattern[]]:=DistortionToADMStart[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2],options]
DistortionToADMStart[options:OptionsPattern[]]:=DistortionToADMStart[Part[$CovDs,3],options]
DistortionToADMStop[covd_,options:OptionsPattern[]]:=DistortionToADMStop[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2],options]
DistortionToADMStop[options:OptionsPattern[]]:=DistortionToADMStop[Part[$CovDs,3],options]


(* ::Input::Initialization:: *)
PrintAsCharacter[Extrinsic]="K";


(* ::Input::Initialization:: *)
DefMAGExtrinsicTensors[covd_,indmetric_]:=Module[
{metric=Part[InducedFrom[indmetric],1],
vb=VBundleOfMetric[indmetric],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],4],
M=ManifoldOfCovD[covd]
},
With[{torsionQ=TorsionQ[covd],
	nonmetricityQ=NonMetricityQ[covd,metric],
	a= indices[[1]],
	b= indices[[2]],
	d= indices[[3]],
	i= indices[[4]],
	nv=Part[InducedFrom[indmetric],2],
	extrinsic1=GiveSymbol[Extrinsic,1,covd],
	extrinsic3=GiveSymbol[Extrinsic,3,covd]
	},
	If[nonmetricityQ&&torsionQ,
	DefTensor[extrinsic1[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Extrinsic,1]];
	DefTensor[extrinsic3[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Extrinsic,3]]
	];
]
]


(* ::Input::Initialization:: *)
UndefMAGExtrinsicTensors[covd_,indmetric_]:=Module[
{torsionQ=TorsionQ[covd],
nonmetricityQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]]
},
With[{
	extrinsic1=GiveSymbol[Extrinsic,1,covd],
	extrinsic3=GiveSymbol[Extrinsic,3,covd]
	},
If[torsionQ&&nonmetricityQ,
UndefTensor[extrinsic1];
UndefTensor[extrinsic3];
];
]
]


(* ::Input::Initialization:: *)
DefMAGExtrinsicTensors[covd_]:=DefMAGExtrinsicTensors[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
DefMAGExtrinsicTensors[]:=DefMAGExtrinsicTensors[Part[$CovDs,3]]
UndefMAGExtrinsicTensors[covd_]:=UndefMAGExtrinsicTensors[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
UndefMAGExtrinsicTensors[]:=UndefMAGExtrinsicTensors[Part[$CovDs,3]]


(* ::Input::Initialization:: *)
Options[ExtrinsicToDistortionADM]:={Verbose->True}
ExtrinsicToDistortionADM[exp_,covd_,indmetric_,options:OptionsPattern[]]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],2],
autoruleQ=AutomaticDistortionADMToExtrinsicQ[covd,indmetric],
verbose
},
{verbose}=OptionValue[{ExtrinsicToDistortionADM},{options},{Verbose}];
With[{nv=Part[InducedFrom[indmetric],2],
	a= indices[[1]],
	b= indices[[2]],
	extrinsic1=GiveSymbol[Extrinsic,1,covd],
	extrinsic3=GiveSymbol[Extrinsic,3,covd],
	extrinsich=GiveSymbol[ExtrinsicK,indmetric]
	},
With[{Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
	Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric]},
	If[autoruleQ,DistortionADMToExtrinsicStop[covd,indmetric,Verbose->verbose]];
	If[nonmetQ&&torsionQ,
	RuleExtrinsicToChhn=MakeRule[{extrinsic3[-a, b],-Chhn[b, -a] + extrinsich[-a, b]}];
	RuleExtrinsicToCnhh=MakeRule[{extrinsic1[-a, -b],Cnhh[-a, -b]+extrinsich[-a, -b]}];
	];
	Return[exp/.RuleExtrinsicToChhn/.RuleExtrinsicToCnhh]
]
]
]


(* ::Input::Initialization:: *)
ExtrinsicToDistortionADM[exp_,covd_]:=ExtrinsicToDistortionADM[exp,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
ExtrinsicToDistortionADM[exp_]:=ExtrinsicToDistortionADM[exp,Part[$CovDs,3]]


(* ::Input::Initialization:: *)
AutomaticDistortionADMToExtrinsicQ[covd_,indmetric_]:=False
Options[DistortionADMToExtrinsicStart]:={Verbose->True}
DistortionADMToExtrinsicStart[covd_,indmetric_,options:OptionsPattern[]]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
verbose,
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],2],
autoruleQ=AutomaticDistortionADMToExtrinsicQ[covd,indmetric]
},
{verbose}=OptionValue[{DistortionADMToExtrinsicStart},{options},{Verbose}];
With[
{nv=Part[InducedFrom[indmetric],2],
a= indices[[1]],
b= indices[[2]],
distortion=GiveSymbol[Distortion,covd],
extrinsic1=GiveSymbol[Extrinsic,1,covd],
extrinsic3=GiveSymbol[Extrinsic,3,covd],
extrinsich=GiveSymbol[ExtrinsicK,indmetric]
},
With[{Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
	Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric]},
								(* Messages *)
	If[verbose&&!autoruleQ&&torsionQ&&nonmetQ,Print["** Automatic conversion of ADM components",PrintAs@Cnhh," and ",  PrintAs@Chhn, " to "  ,PrintAs@extrinsic1, " and ", PrintAs@extrinsic3, " is on"]];

	If[verbose&&autoruleQ&&torsionQ&&nonmetQ,Throw@Print["** Automatic conversion of ADM components",PrintAs@Cnhh," and ",
 PrintAs@ Chhn, " to "  ,PrintAs@extrinsic1, " and ", PrintAs@extrinsic3, " is already on"]];
							(* The function *)
	If[!autoruleQ&&nonmetQ&&torsionQ,
	RuleChhnToExtrinsic=MakeRule[{Chhn[b, -a],-extrinsic3[-a, b] + extrinsich[-a, b]}];
	AutomaticRules[Chhn,RuleChhnToExtrinsic,Verbose->False];
	RuleCnhhToExtrinsic=MakeRule[{Cnhh[-a, -b],extrinsic1[-a, -b]-extrinsich[-a, -b]}];
	AutomaticRules[Cnhh,RuleCnhhToExtrinsic,Verbose->False];
	];
AutomaticDistortionADMToExtrinsicQ[covd,indmetric]:=True;
]
]
]


(* ::Input::Initialization:: *)
Options[DistortionADMToExtrinsicStop]:={Verbose->True}
DistortionADMToExtrinsicStop[covd_,indmetric_,options:OptionsPattern[]]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
verbose,
autoruleQ=AutomaticDistortionADMToExtrinsicQ[covd,indmetric]
},
{verbose}=OptionValue[{DistortionADMToExtrinsicStop},{options},{Verbose}];
With[{
nv=Part[InducedFrom[indmetric],2],
extrinsic1=GiveSymbol[Extrinsic,1,covd],
extrinsic3=GiveSymbol[Extrinsic,3,covd]
},
With[{Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
	Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric]},

							(* Messages *)
	If[verbose&&autoruleQ&&torsionQ&&nonmetQ,Print["** Automatic conversion of ADM components ",PrintAs@Cnhh," and ", PrintAs@ Chhn, " to "  ,PrintAs@extrinsic1, " and ", PrintAs@extrinsic3, " is off"]];
	If[verbose&&!autoruleQ&&torsionQ&&nonmetQ,
		Throw@Print["** Automatic conversion of ADM components",PrintAs@Cnhh," and ",  PrintAs@Chhn, " to "  ,PrintAs@extrinsic1, " and ", PrintAs@extrinsic3, " is already off"]];
	If[autoruleQ&&nonmetQ&&torsionQ,
	ClearAutomaticRules[Chhn,RuleChhnToExtrinsic,Verbose->False];
	ClearAutomaticRules[Cnhh,RuleCnhhToExtrinsic,Verbose->False];
	];
AutomaticDistortionADMToExtrinsicQ[covd,indmetric]:=False;
]
]
]


(* ::Input::Initialization:: *)
DistortionADMToExtrinsicStart[covd_,options:OptionsPattern[]]:=DistortionADMToExtrinsicStart[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2],options];
DistortionADMToExtrinsicStart[options:OptionsPattern[]]:=DistortionADMToExtrinsicStart[Part[$CovDs,3],options];
DistortionADMToExtrinsicStop[covd_,options:OptionsPattern[]]:=DistortionADMToExtrinsicStop[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2],options]
DistortionADMToExtrinsicStop[options:OptionsPattern[]]:=DistortionADMToExtrinsicStop[Part[$CovDs,3],options]


(* ::Input::Initialization:: *)
PrintAsCharacter[Acceleration]="a";


(* ::Input::Initialization:: *)
DefMAGAccelerationTensors[covd_,indmetric_]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
M=ManifoldOfCovD[covd],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],2]
},
With[{
	nv=Part[InducedFrom[indmetric],2],
	a= indices[[1]],
	b= indices[[2]],
	acceleration1=GiveSymbol[Acceleration,"1",covd],
	acceleration3=GiveSymbol[Acceleration,"3",covd],
	acceleration1h=GiveSymbol[Acceleration,"1",covd,indmetric],
	acceleration3h=GiveSymbol[Acceleration,"3",covd,indmetric]
	},
With[{accelerationcovdn=GiveSymbol[Acceleration,covd,nv]},
	If[nonmetQ&&torsionQ,
	DefTensor[acceleration1[a],M,PrintAs->xMAGPrint[Acceleration,1]];
	DefTensor[acceleration3[a],M,PrintAs->xMAGPrint[Acceleration,3]];
	DefTensor[acceleration1h[a],M,OrthogonalTo->{nv[-a]},ProjectedWith->{indmetric[-a,b]},PrintAs->xMAGPrint[Acceleration,1,indmetric]];
	DefTensor[acceleration3h[a],M,OrthogonalTo->{nv[-a]},ProjectedWith->{indmetric[-a,b]},PrintAs->xMAGPrint[Acceleration,3,indmetric]];
	DefTensor[accelerationcovdn[],M,PrintAs->xMAGPrint[Acceleration,Null,nv]]
	];
]
]
]


(* ::Input::Initialization:: *)
UndefMAGAccelerationTensors[covd_,indmetric_]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
M=ManifoldOfCovD[covd]
},
With[
{
nv=Part[InducedFrom[indmetric],2]
},
	With[
	{acceleration1=GiveSymbol[Acceleration,"1",covd],
	acceleration3=GiveSymbol[Acceleration,"3",covd],
	acceleration1h=GiveSymbol[Acceleration,"1",covd,indmetric],
	acceleration3h=GiveSymbol[Acceleration,"3",covd,indmetric],
	accelerationcovdn=GiveSymbol[Acceleration,covd,nv]
	},
	If[nonmetQ&&torsionQ,
	UndefTensor[acceleration1];
	UndefTensor[acceleration3];
	UndefTensor[acceleration1h];
	UndefTensor[acceleration3h];
	UndefTensor[accelerationcovdn]
	];
]
]
]


(* ::Input::Initialization:: *)
DefMAGAccelerationTensors[covd_]:=DefMAGAccelerationTensors[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
DefMAGAccelerationTensors[]:=DefMAGAccelerationTensors[Part[$CovDs,3]]
UndefMAGAccelerationTensors[covd_]:=UndefMAGAccelerationTensors[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
UndefMAGAccelerationTensors[]:=UndefMAGAccelerationTensors[Part[$CovDs,3]]


(* ::Input::Initialization:: *)
Options[AccelerationToDistortionADM]:={Verbose->True}
AccelerationToDistortionADM[exp_,covd_,indmetric_,options:OptionsPattern[]]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],1],
autoruleQ=AutomaticDistortionADMToAccelerationQ[covd,indmetric],
verbose
},
{verbose}=OptionValue[{AccelerationToDistortionADM},{options},{Verbose}];
With[{nv=Part[InducedFrom[indmetric],2],
	a= indices[[1]]
	},
	With[{Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
		Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
		Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv],
		acceleration1=GiveSymbol[Acceleration,"1",covd],
		acceleration3=GiveSymbol[Acceleration,"3",covd],
		acceleration1h=GiveSymbol[Acceleration,"1",covd,indmetric],
		acceleration3h=GiveSymbol[Acceleration,"3",covd,indmetric],
		accelerationcovdn=GiveSymbol[Acceleration,covd,nv],
		accelerationn=GiveSymbol[Acceleration,nv]
		},
	If[autoruleQ,DistortionADMToAccelerationStop[covd,indmetric,Verbose->verbose]];
	If[nonmetQ&&torsionQ,
	RuleAccToCnnh=MakeRule[{acceleration3h[-a],-Cnnh[-a]+accelerationn[-a]}];
	RuleAccToChnn=MakeRule[{acceleration1h[-a],Chnn[-a]+accelerationn[-a]}];
	RuleanToCnnn=MakeRule[{accelerationcovdn[],Cnnn[]}];
	];
	Return[exp/.RuleAccToCnnh/.RuleAccToChnn/.RuleanToCnnn]
]
]
]


(* ::Input::Initialization:: *)
AccelerationToDistortionADM[e_,covd_]:=AccelerationToDistortionADM[e,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
AccelerationToDistortionADM[e_]:=AccelerationToDistortionADM[e,Part[$CovDs,3]]


(* ::Input::Initialization:: *)
AutomaticDistortionADMToAccelerationQ[covd_,indmetric_]:=False
Options[DistortionADMToAccelerationStart]:={Verbose->True}
DistortionADMToAccelerationStart[covd_,indmetric_,options:OptionsPattern[]]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],1],
verbose,
autoruleQ=AutomaticDistortionADMToAccelerationQ[covd,indmetric]
},
{verbose}=OptionValue[{DistortionADMToAccelerationStart},{options},{Verbose}];
With[{nv=Part[InducedFrom[indmetric],2],
	a= indices[[1]]
	},
	With[{Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
		Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
		Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv],
		acceleration1=GiveSymbol[Acceleration,"1",covd],
		acceleration3=GiveSymbol[Acceleration,"3",covd],
		acceleration1h=GiveSymbol[Acceleration,"1",covd,indmetric],
		acceleration3h=GiveSymbol[Acceleration,"3",covd,indmetric],
		accelerationcovdn=GiveSymbol[Acceleration,covd,nv],
		accelerationn=GiveSymbol[Acceleration,nv]
		},
								(* Messages *)
		If[verbose&&!autoruleQ&&torsionQ&&nonmetQ,
		Print["** Automatic conversion of ADM components ",PrintAs@Chnn,", ",PrintAs@Cnnh," and ",  
		PrintAs@Cnnn, " to "  ,PrintAs@acceleration1,", ",PrintAs@acceleration3, " and ",PrintAs@accelerationcovdn, " is on"]];

		If[verbose&&autoruleQ&&torsionQ&&nonmetQ,
		Throw@Print["** Automatic conversion of ADM components ",PrintAs@Chnn,", ",PrintAs@Cnnh," and ", 
		PrintAs@Cnnn, " to "  ,PrintAs@acceleration1,", ",PrintAs@acceleration3, " and ",PrintAs@accelerationcovdn, " is already on"]];

		If[!autoruleQ&&nonmetQ&&torsionQ,
		RuleCnnhToAcc=MakeRule[{Cnnh[-a],-acceleration3h[-a]+accelerationn[-a]}];
		AutomaticRules[Cnnh,RuleCnnhToAcc,Verbose->False];
		RuleChnnToAcc=MakeRule[{Chnn[-a],acceleration1h[-a]-accelerationn[-a]}];
		AutomaticRules[Chnn,RuleChnnToAcc,Verbose->False];
		RuleCnnnToan=MakeRule[{Cnnn[],accelerationcovdn[]}];
		AutomaticRules[Cnnn,RuleCnnnToan,Verbose->False];
		];
AutomaticDistortionADMToAccelerationQ[covd,indmetric]:=True;
	]
]
]


(* ::Input::Initialization:: *)
Options[DistortionADMToAccelerationStop]:={Verbose->True}
DistortionADMToAccelerationStop[covd_,indmetric_,options:OptionsPattern[]]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
verbose,
autoruleQ=AutomaticDistortionADMToAccelerationQ[covd,indmetric]
},
{verbose}=OptionValue[{DistortionADMToAccelerationStop},{options},{Verbose}];
With[{nv=Part[InducedFrom[indmetric],2]
	},
	With[{Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
		Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
		Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv],
		acceleration1=GiveSymbol[Acceleration,"1",covd],
		acceleration3=GiveSymbol[Acceleration,"3",covd],
		acceleration1h=GiveSymbol[Acceleration,"1",covd,indmetric],
		acceleration3h=GiveSymbol[Acceleration,"3",covd,indmetric],
		accelerationcovdn=GiveSymbol[Acceleration,covd,nv]
		},
									(* Messages *)
	If[verbose&&autoruleQ&&torsionQ&&nonmetQ,
	Print["** Automatic conversion of ADM components ",PrintAs@Chnn,", ",
	PrintAs@Cnnh," and ", PrintAs@ Cnnn, " to "  ,PrintAs@acceleration1,", ",PrintAs@acceleration3, " and ",PrintAs@accelerationcovdn, " is off"]];

	If[verbose&&!autoruleQ&&torsionQ&&nonmetQ,
	Throw@Print["** Automatic conversion of ADM components ",PrintAs@Chnn,", ",
	PrintAs@Cnnh," and ",  PrintAs@Cnnn, " to "  ,PrintAs@acceleration1,", ",PrintAs@acceleration3, " and ",PrintAs@accelerationcovdn, " is already off"]];

	If[nonmetQ&&torsionQ,
	ClearAutomaticRules[Cnnh,RuleCnnhToAcc,Verbose->False];
	ClearAutomaticRules[Chnn,RuleChnnToAcc,Verbose->False];
	ClearAutomaticRules[Cnnn,RuleCnnnToan,Verbose->False];
	];
	AutomaticDistortionADMToAccelerationQ[covd,indmetric]:=False;
	]
]
]


(* ::Input::Initialization:: *)
DistortionADMToAccelerationStart[covd_,options:OptionsPattern[]]:=DistortionADMToAccelerationStart[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2],options]
DistortionADMToAccelerationStart[options:OptionsPattern[]]:=DistortionADMToAccelerationStart[Part[$CovDs,3],options]
DistortionADMToAccelerationStop[covd_,options:OptionsPattern[]]:=DistortionADMToAccelerationStop[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2],options]
DistortionADMToAccelerationStop[options:OptionsPattern[]]:=DistortionADMToAccelerationStop[Part[$CovDs,3],options]


(* ::Input::Initialization:: *)
FromADMToDistortion[expr_,covd_,indmetric_]:=Module[
{
nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],7],
autoruleCQ=AutomaticDistortionToADMQ[covd,indmetric],
autoruleKQ=AutomaticDistortionADMToExtrinsicQ[covd,indmetric],
autoruleAQ=AutomaticDistortionADMToAccelerationQ[covd,indmetric],
rule,
expint,
res
},
With[{nv=Part[InducedFrom[indmetric],2]
},
With[
{
a= indices[[1]],
b= indices[[2]],
c= indices[[3]],
d= indices[[4]],
i= indices[[5]],
j= indices[[6]],
k= indices[[7]],
Chhh=GiveSymbol[Distortion,covd,indmetric,indmetric,indmetric],
Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
Chnh=GiveSymbol[Distortion,covd,indmetric,nv,indmetric],
Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric],
Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
Cnhn=GiveSymbol[Distortion,covd,nv,indmetric,nv],
Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv],
distortion=GiveSymbol[Distortion,covd]
},
	If[nonmetQ&&torsionQ,
		If[autoruleCQ,DistortionToADMStop[covd,indmetric,Verbose->True]];
		expint=AccelerationToDistortionADM[ExtrinsicToDistortionADM[expr,covd,indmetric,Verbose->False],covd,indmetric,Verbose->False];
		rule=Join[
		MakeRule[{Chhh[i,j,k],indmetric[-a,i]*indmetric[-b,j]*indmetric[-c,k]*distortion[a, b, c]}],
		MakeRule[{ Chhn[a, b],distortion[j, -i, -c]*indmetric[a, -j]*indmetric[b, i]*nv[c]}],
		MakeRule[{Chnh[a, c],distortion[i, -b, j]*indmetric[a, -i]*indmetric[c, -j]*nv[b] }],
		MakeRule[{Cnhh[b, c],distortion[a, -i, j]*indmetric[b, i]*indmetric[c, -j]*nv[-a]}],
		MakeRule[{Chnn[d],distortion[a, -b, -i]*indmetric[-a, d]*nv[i]*nv[b]}],
		MakeRule[{Cnnh[c],distortion[a, -b, i]*indmetric[c, -i]*nv[-a]*nv[b]}],
		MakeRule[{Cnhn[b],distortion[a, i, -c]*indmetric[b, -i]*nv[-a]*nv[c]}],
		MakeRule[{Cnnn[],distortion[a, -b, -c]*nv[-a]*nv[b]*nv[c]}]];
			];
	res=expint/.rule;
	DistortionADMToExtrinsicStart[covd,indmetric,Verbose->False];
	DistortionADMToAccelerationStart[covd,indmetric,Verbose->False];
	AutomaticDistortionToADMQ[covd,indmetric]:=False;
	Return[res]
]
]
]


(* ::Input::Initialization:: *)
FromADMToDistortion[expr_,covd_]:=FromADMToDistortion[expr,covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
FromADMToDistortion[expr_]:=FromADMToDistortion[expr,Part[$CovDs,3]]


(* ::Input::Initialization:: *)
(*Protect[DefIRDTensors]*)
End[];
EndPackage[];



