(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
xAct`xMAG`$Version={"0.1.0",{2023,05,18}}


(* ::Input::Initialization:: *)
xAct`xMAG`$xTensorVersionExpected={"1.2.0",{2021,10,17}};
xAct`xMAG`$xTrasVersionExpected={"1.0.6",{2014,10,30}};


(* ::Input::Initialization:: *)
(* xMAG: Metric-Affine Gravity framework *)

(* Copyright (C) 2020 T. Helpin *)

(* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License,or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

*)


(* ::Input::Initialization:: *)
(* :Title: xMAG *)

(* :Author: Thomas Helpin *)

(* :Summary: Metric-Affine Gravity framework. *)

(* :Brief Discussion: xMAG is a package to study metric affine gravity using using xTensor. *)
  
(* :Context: xAct`xMAG` *)

(* :Package Version: 0.1.0 *)

(* :Copyright: T.Helpin (2020) *)

(* :History: TODO *)

(* :Keywords: TODO *)

(* :Source: xMAG.nb *)

(* :Warning: TODO *)

(* :Mathematica Version: 8.0 and later *)

(* :Limitations: *)
	
(* :Acknowledgements: *)


(* ::Input::Initialization:: *)
If[Unevaluated[xAct`xCore`Private`$LastPackage]===xAct`xCore`Private`$LastPackage,xAct`xCore`Private`$LastPackage="xAct`xMAG`"];


(* ::Input::Initialization:: *)
Off[General::nostdvar]
Off[General::nostdopt]
BeginPackage["xAct`xMAG`",{"xAct`xTensor`","xAct`xPert`","xAct`xPerm`","xAct`xCore`","xAct`ExpressionManipulation`","xAct`TraceFree`","xAct`xTras`","xAct`xBrauer`"}]


(* ::Input::Initialization:: *)
If[Not@OrderedQ@Map[Last,{$xTensorVersionExpected,xAct`xTensor`$Version}],Throw@Message[General::versions,"xTensor",xAct`xTensor`$Version,$xTensorVersionExpected]]

If[Not@OrderedQ@Map[Last,{$xTrasVersionExpected,xAct`xTras`$Version}],Throw@Message[General::versions,"xTras",xAct`xTras`$Version,$xTrasVersionExpected]]


(* ::Input::Initialization:: *)
Print[xAct`xCore`Private`bars]
Print["Package xAct`xMAG`  version ",$Version[[1]],", ",$Version[[2]]];
Print["Copyright (C) 2020, Thomas Helpin, under the General Public License."];


(* ::Input::Initialization:: *)
Off[General::shdw]
xAct`xForm`Disclaimer[]:=Print["These are points 11 and 12 of the General Public License:\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM `AS IS\.b4 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."]
On[General::shdw]


(* ::Input::Initialization:: *)
If[xAct`xCore`Private`$LastPackage==="xAct`xMAG`",
Unset[xAct`xCore`Private`$LastPackage];
Print[xAct`xCore`Private`bars];
Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];
Print[xAct`xCore`Private`bars]]


(* ::Input::Initialization:: *)
$RiemannSign=-1;
$RicciSign=1;


(* ::Input::Initialization:: *)
GiveOutputString[Acceleration,vector_]:=GiveOutputString[Acceleration]


(* ::Input::Initialization:: *)
(*** VERSIONS ***)
$Version::usage="$Version is a global variable giving the version of the package xMAG in use.";
$xTensorVersionExpected::usage="$xTensorVersionExpected is a global variable giving the oldest possible version of the package xTensor which is required by the version of the package xMAG in use.";


(* ::Input::Initialization:: *)
(**************************************************************************************************************)
(**************************************** Convenient functions ***********************************************)
(**************************************************************************************************************)
ToFunction::usage="ToFunction[exp1==exp2,functionname] automatically transforms an equality between two tensorial expressions into a function with name 
functionname.";
InverseMakeRule::usage="InverseMakeRule[rule] inverse the rule when it is possible.";
(* LeviCivitaQ::usage="LeviCivitaQ[covd,g] returns True if covd is the Levi-Civita connection associated with g. LeviCivitaQ[covd] returns True if covd is 
the Levi-Civita connection associated with the metric MasterOf[covd] if any."; *)
NonMetricityQ::usage="NonMetricityQ[cd,g] gives True if cd is not metric compatible with respect to g and False otherwise.";


(**************************************************************************************************************)
(********** The principal option for the extension of the xTensor of DefCovD ********************)
(**************************************************************************************************************)
Master::usage="Master is an option for DefType commands specifying the master symbol of the defined symbol. By default, no master is associated.
In xBrauer Master is an important option for DefTensor. Use Master -> met, or Master -> Null. Its default value is Null.
DefTensor[tens[inds],...,Master->met] defines a tensor tens with indices inds which can be raised, lowered or contracted with metric met only. 
DefTensor[tens[inds],M,...,Master->Null] defines a tensor tens with indices inds which can be raised, lowered or contracted with the first of metric of M.
In xMAG Master is an important option for DefCovD. Use Master -> met, or Master -> Null. Its default value is Null.\ 
When Torsion is True and FromMetric is set to Null, Master -> met triggers the definitions and relations appropriate \ 
	for a metric-affine Riemaniann geometry with an independent connection with torsion and nonmetricity and metric met.
When Torsion is True and FromMetric is set to met, Master -> met triggers the definitions and relations appropriate \ 
	for a metric-affine Riemannian geometry with a metric compatible connection with torsion and metric met.
When Torsion is False and FromMetric is set to Null, Master -> met triggers the definitions and relations appropriate \ 
	for a metric-affine Riemannian geometry with an independent symmetric connection and metric met.";

(**************************************************************************************************************)
(************ Extended "Non-Riemannian" connection tensors define in the extension of DefCovD *****************)
(**************************************************************************************************************)
Distortion::usage =
	"Distortion is a reserved word in xMAG. It is used to generated the name of the Distortion tensor.";
DistortionTrace::usage =
	"DistortionTrace[n][covd] returns the n trace vector of the distortion tensor associated to the covariant \
derivative covd.";
TFDistortion::usage =
	"TFDistortion[covd] returns the traceless distortion tensor associated to a connection covd acting on a tangent bundle.";
TFDistortionToDistortion::usage="TFDistortionToDistortion[expr, covd] expands expr expressing all TFDistortion tensors of covd in terms\
 of the Distortion of covd.";
DistortionToTFDistortion::usage="DistortionToTFDistortion[expr, covd] expands expr expressing all Distortion tensors of covd in terms\
 of the TFDistortion of covd.";
Disformation::usage =
	"Disformation is a reserved word in xMAG. It is used to generated the name \
of the Disformation tensor.";
TFDisformation::usage ="TFDisformation[covd] returns the traceless Disformation tensor associated to a connection covd acting on a tangent bundle.";
TFDisformationToDisformation::usage="TFDisformationToDisformation[expr,covd] expands expr expressing all TFDisformation tensors of covd in terms\
 of the Disformation of covd.";
DisformationToTFDisformation::usage="DisformationToTFDisformation[expr, covd] expands expr expressing all Disformation tensors of covd in terms\
 of the TFDisformation and other tensors of covd.";
DisformationTrace::usage =
	"DisformationTrace[covd][n] returns the n trace vector of the disformation tensor associated to the covariant \
derivative covd.";
Contorsion::usage =
	"Contorsion is a reserved word in xMAG. It is used to generated the name \
of the Contorsion tensor.";
TFContorsion::usage ="TFContorsion[covd] returns the traceless Contorsion tensor associated to a connection covd acting on a tangent bundle.";
TFContorsionToContorsion::usage="TFContorsionToContorsion[expr, covd] expands expr expressing all TFContorsion tensors of covd in terms\
 of the Contorsion and other tensors of covd.";
ContorsionToTFContorsion::usage="ContorsionToTFContorsion[expr, covd] expands expr expressing all Contorsion tensors of covd in terms\
 of the TFContorsion and other tensors of covd.";
NonMetricity::usage =
	"NonMetricity is a reserved word in xMAG. It is used to generated the name \
of the nonmetricity tensor.";
NonMetricityTrace::usage =
	"NonMetricityTrace[n][covd] returns the nth trace vector of the NonMetricity tensor associated to the covariant \
derivative covd.";
TFNonMetricity::usage ="TFNonMetricity[covd] returns the Traceless NonMetricity tensor associated to a connection covd acting on a tangent bundle.";
TFNonMetricityToNonMetricity::usage="TFNonMetricityToNonMetricity[expr, covd] expands expr expressing all TFNonMetricity tensors of covd in terms of the NonMetricity\
 and other tensors of covd.";
NonMetricityToTFNonMetricity::usage="NonMetricityToTFNonMetricity[expr, covd] expands expr expressing all NonMetricity tensors of covd in terms of the TFNonMetricity\
 and other tensors of covd.";
(*WeylVector::usage ="WeylVector is a reserved word in xMAG. It is used to generated the name \
of the WeylVector vector.";*)
TFTorsion::usage ="TFTorsion[covd] returns the Traceless Torsion tensor associated to a connection covd acting on a tangent bundle.";
TFTorsionToTorsion::usage="TFTorsionToTorsion[expr, covd] expands expr expressing all TFTorsion tensors of covd in terms of the Torsion and other tensors of covd.";
TorsionToTFTorsion::usage="TorsionToTFTorsion[expr, covd] expands expr expressing all Torsion tensors of covd in terms of the TFTorsion and other tensors of covd.";
TorsionVector::usage ="TorsionVector is a reserved word in xMAG. It is used to generated the name \
of the TorsionVector vector.";
(**************************************************************************************************************)
(*********** Extended Non-Riemannian curvature tensors define through the extension of DefCovD ****************)
(**************************************************************************************************************)
Homothetic::usage="Homothetic is a reserved word in xMAG. It is used to generated the name \
of one of the traces of the Riemann tensor known as the Homothetic tensor. This tensor is defines with DefCovD";
CoRicci::usage="CoRicci is a reserved word in xMAG. It is used to generated the name \
of one of the traces of the Riemann tensor known as the CoRicci tensor. This tensor is defines with DefCovD";
TFRicci::usage="TFRicci[covd] returns the Traceless Ricci curvature tensor associated to a connection covd acting on a tangent bundle.";
TFCoRicci::usage="TFCoRicci[covd] returns the Traceless CoRicci curvature tensor associated to a connection covd acting on a tangent bundle.";
CoRicciToTFCoRicci::usage="CoRicciToTFCoRicci[expr, covd] expands expr expressing all CoRicci tensors of covd in terms of the TFCoRicci and other tensors of covd.
 If the second argument is a list of covariant derivatives the command is applied sequentially on expr. RicciToTFRicci[expr] expands all Ricci tensors.";
TFCoRicciToCoRicci::usage="TFCoRicciToCoRicci[expr, covd] expands expr expressing all TFCoRicci tensors of covd in terms of the CoRicci and other tensors of covd. 
If the second argument is a list of covariant derivatives the command is applied sequentially on expr TFCoRicciToRicci[expr] expands all TFCoRicci tensors.";
(**************************************************************************************************************)
(**************** ConnectionRelations which is similar to CurvatureRelations in xTensor ***********************)
(**************************************************************************************************************)
ConnectionRelations::usage="ConnectionRelations is a Boolean option for DefCovD giving whether automatic rules relating \
the connection tensors (Distortion/Torsion/NonMetricity) of a newly define covariant derivative should be set or not. Its default value is True.
ConnectionRelations[covd, Distortion] gives a list of the relations between the contracted Distortion of covd and the associated Trace vectors. \ 
ConnectionRelations[covd,Torsion] yield the corresponding rule for the torsion and ConnectionRelations[covd,NonMetricity] for NonMetricity.";
ConnectionRelationsQ::usage="ConnectionRelationsQ[CD] returns True if all of the connections \
relations for the covariant derivative CD have been set as automatic rules, and False otherwise.";
ClearConnectionRelations::usage="ClearConnectionRelations[CD] removes the automatic connection \
relations for the covariant derivative CD.";
SetConnectionRelations::usage="SetConnectionRelations[CD] sets the automatic connection \
relations for the covariant derivative CD.";
ClearCurvatureRelations::usage="todo";
SetCurvatureRelations::usage="todo";
GradMetricToNonMetricity::usage="GradMetricToNonMetricity is a Boolean option for DefCovD giving whether automatic rules transforming covd[-a]metric[-b,-c] to NonMetricity[-a,-b,-c]\
 should be set or not. Its default value is True. GradMetricToNonMetricity[covd] gives the rule which transforms covd[-a]metric[-b,-c] to NonMetricitycovd[-a,-b,-c].";
GradMetricToNonMetricityQ::usage="GradMetricToNonMetricityQ[CD] returns True if the rule from CD[-a]metric[-b,-c] to NonMetricityCD[-a,-b,-c]\
 for the covariant derivative CD have been set as automatic rules, and False otherwise.";
ClearGradMetricToNonMetricity::usage ="ClearGradMetricToNonMetricity[CD] removes GradMetricToNonMetricity[CD] as an automatic rule.";
SetGradMetricToNonMetricity::usage ="SetGradMetricToNonMetricity[CD] sets GradMetricToNonMetricity[CD] as an automatic rule.";

(**************************************************************************************************************)
(***************************** Function related to the general connection *************************************)
(**************************************************************************************************************)
MAGChristoffelTensorStart::usage="ChristoffelToDistortionStart[CD,g] start the automatic transformation of ChristoffelcdCD to the distortionCD tensor 
where cd is the metric compatible connection associated to the metric g.";
MAGChristoffelTensorStop::usage="ChristoffelToDistortionStop[CD,g] stop the automatic transformation of ChristoffelcdCD to the distortionCD tensor 
where cd is the metric compatible connection associated to the metric g.";
BreakDistortion::usage="BreakDistortion[exp,cd,metric] transforms all occurences of Distortioncd in exp into NonMetricitycd and Torsioncd terms.
The inputs cd and metric are optional.";
BreakDisformation::usage="BreakDisformation[exp,cd,metric] transforms all occurences of Disformation in exp into the sum of nonmetricity tensors.
The inputs cd and metric are optional.";
BreakContorsion::usage="BreakContorsion[exp,cd,metric] transforms all occurences of Disformation in exp into the sum of torsion tensors. 
The inputs cd and metric are optional.";
ToDistortion::usage="ToDistortion[exp,CD,g] decomposes the curvature tensors and covariant derivative CD in exp into curvature tensors and
covariant derivative associated to the Levi-Civita connection of the metric g plus terms proportional to the distortion tensors. 
It's also transforms non-metricity, torsion, disformation and contorsion tensors into the distortion tensor.";
ToDisformation::usage="When the connection has non metricity but zero Torsion ToDisformation[exp,CD,g] decomposes the curvature tensors and covariant derivative CD 
in exp into curvature tensors and covariant derivative associated to the Levi-Civita connection of the metric g plus terms proportional to the disformation tensors. 
When the connection as non metricity and Torsion ToDisformation[exp,CD,g] decomposes the distortion tensor as a sum of disformation and contorsion.";
ToContorsion::usage="When the connection has Torsion  but zero non-metricity ToContorsion[exp,CD,g] decomposes the curvature tensors and covariant derivative CD 
in exp into curvature tensors and covariant derivative associated to the Levi-Civita connection of the metric g plus terms proportional to the contorsion tensors. 
When the connection as non metricity and Torsion ToContorsion[exp,CD,g] decomposes the distortion tensor as a sum of disformation and contorsion.";
ToDistortion::usage="ToDistortion[exp,CD,g] decomposes the curvature tensors and covariant derivative CD in exp into curvature tensors and
covariant derivative associated to the Levi-Civita connection of the metric g plus terms proportional to the distortion tensors. 
It's also transforms non-metricity, torsion, disformation and contorsion tensors into the distortion tensor.";
(*********************************************************************************************************************)
(******************** Perturbation pour la connection affine independante de la m\[EAcute]trique******************************)
(*********************************************************************************************************************)
DefConnectionPerturbation::usage="DefConnectionPerturbation[christoffel,pert,param] constructs a number of definitions for the perturbation of the given christoffel symbol, which must exist already.
A tensor pert[LI[order],a,-b,-c] is defined on the vbundle of christoffel and the parameter param will be defined and used to expand the perturbed expressions.
DefConnectionPerturbation is also a Boolean option for DefCovD.";
(*DefConnectionVariation::usage="DefConnectionVariation";*)

(*********************************************************************************************************************)
(******************** Function related to the trace decomposition of a curvature tensor ******************************)
(*********************************************************************************************************************)
RiemannToWeyl::usage="RiemannToWeyl[expr, covd] expands expr expressing all Riemann tensors of covd in terms of the Weyl and other tensors of covd.\
 If the second argument is a list of covariant derivatives the command is applied sequentially on expr. RiemannToWeyl[expr] expands all Riemann tensors.";
WeylToRiemann::usage="WeylToRiemann[expr, covd] expands expr expressing all Weyl tensors of covd in terms of the Riemann and other tensors of covd.\
 If the second argument is a list of covariant derivatives the command is applied sequentially on expr. WeylToRiemann[expr] expands all Weyl tensors.";
(************************************************************************************************************************************)
(****************************** Linear/Projective Transformations - Weyl Transformation *********************************************)
(************************************************************************************************************************************) 
LinearVector::usage="Head for vectors involved in linear transformations of the distortion tensor.";
LinearTransformations::usage="LinearTransformations[covd] returns the set of rules corresponding to a linear transformations of the distortion tensor\
 associated to covd.";
LinearTransform::usage="LinearTransform[n,exp] applies the linear transformation of type n to exp.";
ProjectiveTransformation::usage="ProjectiveTransformation[CD] returns the rule corresponding to the projective transformation of the distortion tensor associated\
 to the covariant derivative CD.";
ProjectiveTransform::usage="ProjectiveTransform[exp,CD] applies the projective transformation to all 
occurences of the distortion tensor appearing in the ToDistortion[expr,CD].";
ProjectiveQ::usage="ProjectiveQ[exp,CD,g] return true if exp is projective invariant, false otherwise.";
WeylTransformation::usage="WeylTransformation[cd1,cd2] list the Weyl transformation rules from metric g1 covariant derivative cd1 to the metric g2 covariant derivative cd2.";
WeylTransform::usage="WeylTransform[exp,cd1,cd2] apply the Weyl transformation rules from metric g1 covariant derivative cd1 to the metric g2 covariant derivative cd2.";
(*******************************************************************************************************************************************)
(****************************** Induced Decomposition in Metric theories and Metric Affine Gravity *********************************************)
(*******************************************************************************************************************************************)
StartInducedDecomposition::usage="StartInducedDecomposition[met,CD,{{indcdgpost,indcdgpre},{indCDpost,indCDpre}},{normalvector,indmetric}] defines a number of tensors and rules
to ease the induced decomposition in metric-affine gravity. For now this function works only for a non-Riemannian geometry with independent metric met and GL(dim) independent connection.";
SpaceLikeQ::usage="SpaceLikeQ is a Boolean option for StartInducedDecomposition. It specify wether or not the hypersurface is spacelike. The default value is True.";
Normalization::usage="Normalization is an option for StartInducedDecomposition. It specify the normalization coefficient for the normal vector. The default value is -1.";
StopInducedDecomposition::usafe="StopInducedDecomposition[CD,indmetric] undefines tensors associated with the induced decomposition with induced metric h and independent covariant/ 
derivative CD.";
AccelerationToGradNormal::usage="AccelerationToGradNormal[exp] replaces all occurences of Acceleration vector to the covariant derivative of the normal vector.";
Extrinsic::usage="Extrinsic is a reserved word in xMAG. It is used to generated the name of the MAG extrinsic tensors.";
Gauss::usage="Gauss is a reserved word in xMAG.";
Codazzi::usage="Codazzi is a reserved word in xMAG.";
Mainardi::usage="Mainardi is a reserved word in xMAG.";
Affine::usage="Affine is a reserved word in xMAG.";
InducedCurvatureRelations::usage="InducedCurvatureRelations is a Boolean options for StartInducedDecomposition giving wether automatic rules relating Projector Inert Head 
of the Riemann curvature tensor to projected tensors should be defined or not.\
 These rules for covariant derivative cd and induced metric h are stored in InducedCurvatureRelations[cd,h,Projector].

InducedCurvatureRelations[cd,h,Gauss] gives the Gauss relation, InducedCurvatureRelations[cd,h,Codazzi] gives the Codazzi relations, 
InducedCurvatureRelations[cd,h,Mainardi] gives the Mainardi relations, InducedCurvatureRelations[cd,h,Affine] gives the induced relations which are specific to a metric-affine geometry.   
 ";
InducedCurvatureRelationsQ::usage="InducedCurvatureRelationsQ[cd,h] returns True if the rules relating Projector Inert Head 
of the Riemann tensor to projected tensors have been set as automatic rules, False otherwise.";
SetInducedCurvatureRelations::usage="SetInducedCurvatureRelations[cd,h] sets the automatic rules relating Projector Inert Head 
of the Riemann tensor to projected tensors.";
ClearInducedCurvatureRelations::usage="ClearInducedCurvatureRelations[cd,h] removes the automatic rules relating Projector Inert Head 
of curvature tensor to projected tensors.";
InducedConnectionRelations::usage="InducedConnectionRelations is a Boolean option for StartInducedDecomposition giving wether automatic rules relating Projector Inert Head 
of distortion tensor to projected tensors should be defined or not.\ 
These rules for covariant derivative cd and induced metric h are stored in InducedConnectionRelations[cd,h,Projector].

InducedConnectionRelations[cd,h,Extrinsic] gives the relations between the induced components of the distortion tensor and the generalized extrinsic curvature tensors.
InducedConnectionRelations[cd,h,Acceleration] gives the relations between the induced components of the distortion tensor and the generalized acceleration tensors.";
InducedConnectionRelationsQ::usage="InducedConnectionRelationsQ[CD] returns True if the rules relating Projector Inert Head 
of the distortion tensor to projected tensors have been set as automatic rules, False otherwise.";
SetInducedConnectionRelations::usage="SetInducedConnectionRelations[CD,h] sets the automatic rules relating Projector Inert Head 
of the distortion tensor to projected tensors.";
ClearInducedConnectionRelations::usage="ClearInducedConnectionRelations[CD,h] removes the automatic rules relating Projector Inert Head 
of distortion tensor to projected tensors.";
DistortionDecomposition::usage="DistortionDecomposition[expr,CD] decomposes all occurences of the distortion tensor appearing in exp.";
RiemannDecomposition::usage="RiemannDecomposition[expr,CD] decomposes all occurences of the Riemann Curvature tensor appearing in exp.";
InducedProjectiveRelations::usage="InducedProjectiveRelations is a boolean options for StartInducedDecomposition giving wether automatic rules relating non projective invariant components
of the distortion tensor to projective invariant tensors should be defined or not.\ 
InducedProjectiveRelations[CD,h] gives the transformation rules from non projective invariant component of the distortion tensor to a projective 
invariant tensor + rest.";
SetInducedProjectiveRelations::usage="SetInducedCurvatureRelations[cd,h] sets the automatic rules relating Projector Inert Head 
of the Riemann tensor to projected tensors.";
ClearInducedProjectiveRelations::usage="ClearInducedCurvatureRelations[cd,h] removes the automatic rules relating Projector Inert Head 
of curvature tensor to projected tensors.";
ToInducedCurvature::usage="";


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Input::Initialization:: *)
(*SafeCanonical[e_]:=ToCanonical[e, UseMetricOnVBundle -> None]*)
SafeToRule[exp_]:=ToRule[exp,MetricOn->None,ContractMetrics->False];
SafeMakeRule[e_List]:=MakeRule[e,MetricOn->None,ContractMetrics->False]


(* ::Input::Initialization:: *)
Options[ToFunction]={PatternIndices->All,TestIndices->True,MetricOn->None,UseSymmetries->True,Verbose->False,ContractMetrics->False,Evaluate->False}
ToFunction[expr:(_Equal|_Rule|_RuleDelayed),Function_,options:OptionsPattern[]]:=Module[{rule,pi,ti,mo,us,vb,cm,ev},
{pi,ti,mo,us,vb,cm,ev}=OptionValue[{PatternIndices,TestIndices,MetricOn,UseSymmetries,Verbose,ContractMetrics,Evaluate}];
rule=ToRule[expr,PatternIndices->pi,TestIndices->ti,MetricOn->mo,UseSymmetries->us,Verbose->vb,ContractMetrics->cm,Evaluate->ev];
Function[e_]:=e/.rule;
Print["** Defining function  "<>ToString[Function]]
]


(* ::Input::Initialization:: *)
NonMetricityQ[covd_?CovDQ,metric_?MetricQ]:=If[MetricOfCovD[covd]===metric,False,True]
NonMetricityQ[covd_?CovDQ]:=If[MasterOf[covd]=!={}&&MetricQ[MasterOf[covd]],NonMetricityQ[covd,MasterOf[covd]],NonMetricityQ[covd,$Metrics[[1]]]];


(* ::Input::Initialization:: *)
Options[InverseMakeRule]={PatternIndices->All,TestIndices->True,MetricOn->All,UseSymmetries->True,Verbose->False,ContractMetrics->True,Evaluate->False};
InverseMakeRule[rule_,options:OptionsPattern[]]:=Module[{part1pattern=rule[[1,1]],part1,part2=rule[[2,2]],partternind1,ind2,tens1,tens2},
If[Head[part2]===Plus,Throw["non invertible rule"]];
If[!InertHeadQ[Head@part1pattern]&&!InertHeadQ[Head@part2],
If[Head[part1pattern]===Times,
part1=Map[Map[If[Head[#]===PatternTest,First[First[#]],-First[First[#[[2]]]]]&,#]&,part1pattern],
part1=Map[If[Head[#]===PatternTest,First[First[#]],-First[First[#[[2]]]]]&,part1pattern]
]];
If[InertHeadQ[Head@part1pattern]&&!InertHeadQ[Head@part2],
With[{part1pat=Sequence@@part1pattern,inerthead1=Head[part1pattern]},
If[Head[part1pat]===Times,
part1=inerthead1[Map[Map[If[Head[#]===PatternTest,First[First[#]],-First[First[#[[2]]]]]&,#]&,part1pat]],
part1=inerthead1[Map[If[Head[#]===PatternTest,First[First[#]],-First[First[#[[2]]]]]&,part1pat]];
Print[part1]
]]];
If[!InertHeadQ[Head@part1pattern]&&InertHeadQ[Head@part2],
With[{inerthead2=Head[part2]},
If[Head[part1pattern]===Times,
part1=Map[Map[If[Head[#]===PatternTest,First[First[#]],-First[First[#[[2]]]]]&,#]&,part1pattern],
part1=Map[If[Head[#]===PatternTest,First[First[#]],-First[First[#[[2]]]]]&,part1pattern]
];
part2=inerthead2[part2]
]
];
If[InertHeadQ[part1pattern]&&InertHeadQ[part2],
With[{part1pat=Sequence@@part1pattern,inerthead1=Head[part1pattern],inerthead2=Head[part2]},
If[Head[part1pat]===Times,
part1=inerthead1[Map[Map[If[Head[#]===PatternTest,First[First[#]],-First[First[#[[2]]]]]&,#]&,part1pat]],
part1=inerthead1[Map[If[Head[#]===PatternTest,First[First[#]],-First[First[#[[2]]]]]&,part1pat]]
];
part2=inerthead2[part2][part2]
]
];
ToRule[part2==part1,options]
]


Unprotect[xAct`xTensor`DefCovD];

If[FreeQ[Options[xAct`xTensor`DefCovD],ConnectionRelations], 
	Options[xAct`xTensor`DefCovD] ^= Append[Options[xAct`xTensor`DefCovD], ConnectionRelations -> False];
, 
	Null;
];
Protect[xAct`xTensor`DefCovD];

Unprotect[xAct`xTensor`DefCovD];
If[FreeQ[Options[xAct`xTensor`DefCovD], GradMetricToNonMetricity], 
	Options[xAct`xTensor`DefCovD] ^= Append[Options[xAct`xTensor`DefCovD], GradMetricToNonMetricity-> True];
, 
	Null;
];
Protect[xAct`xTensor`DefCovD];

Unprotect[xAct`xTensor`DefCovD];
If[FreeQ[Options[xAct`xTensor`DefCovD],DefConnectionPerturbation], 
	Options[xAct`xTensor`DefCovD] ^= Append[Options[xAct`xTensor`DefCovD], DefConnectionPerturbation-> True];
, 
	Null;
];
Protect[xAct`xTensor`DefCovD];


(* ::Input::Initialization:: *)
Set[CovDTensorQ[#],True]&/@{Distortion,DistortionTrace,TFDistortion,Disformation,DisformationTrace,TFDisformation,Contorsion,TFContorsion,NonMetricity,TFNonMetricity,NonMetricityTrace,TFTorsion,TorsionVector,CoRicci,TFCoRicci,Homothetic,Weyl,NRiemann,NWeyl,LinearVector};
CovDTensorQ[_]=False;


(* ::Input::Initialization:: *)
Distortion[covd_]:=ToExpression[StringJoin[ToString[Distortion],ToString[covd]]];
Disformation[covd_]:=ToExpression[StringJoin[ToString[Disformation],ToString[covd]]];
Contorsion[covd_]:=ToExpression[StringJoin[ToString[Contorsion],ToString[covd]]];
NonMetricity[covd_]:=ToExpression[StringJoin[ToString[NonMetricity],ToString[covd]]];
(*WeylVector[covd_]:=ToExpression[StringJoin[ToString[WeylVector],ToString[covd]]];*)
(*WeylCoVector[covd_]:=ToExpression[StringJoin[ToString[WeylCoVector],ToString[covd]]];*)
TorsionVector[covd_]:=ToExpression[StringJoin[ToString[TorsionVector],ToString[covd]]];
CoRicci[covd_]:=ToExpression[StringJoin[ToString[CoRicci],ToString[covd]]];
Homothetic[covd_]:=ToExpression[StringJoin[ToString[Homothetic],ToString[covd]]];
TFCoRicci[covd_]:=ToExpression[StringJoin[ToString[TFCoRicci],ToString[covd]]];


(* ::Input::Initialization:: *)
(****** We overwrite RicciScalar error message of xTensor ********)
RicciScalar[covd_Symbol?CovDQ]:=GiveSymbol[RicciScalar,covd];


(* ::Input::Initialization:: *)
(** Extended parts curvature tensors **)
PrintAsCharacter[Ricci]="\!\(\*OverscriptBox[\(R\), \((1)\)]\)";
PrintAsCharacter[CoRicci]="\!\(\*OverscriptBox[\(R\), \((2)\)]\)";
PrintAsCharacter[Homothetic]="\!\(\*OverscriptBox[\(R\), \((3)\)]\)";
PrintAsCharacter[TFRicci]="\!\(\*OverscriptBox[\(S\), \((1)\)]\)";
PrintAsCharacter[TFCoRicci]="\!\(\*OverscriptBox[\(S\), \((2)\)]\)";
(** Tensors related to the general connection **)
PrintAsCharacter[Distortion]="C";
PrintAsCharacter[DistortionTrace]="C";
PrintAsCharacter[TFDistortion]="\!\(\*OverscriptBox[\(C\), \((tf)\)]\)";
PrintAsCharacter[Disformation]="D";
PrintAsCharacter[DisformationTrace]="D";
PrintAsCharacter[TFDisformation]="\!\(\*OverscriptBox[\(D\), \((tf)\)]\)";
PrintAsCharacter[Contorsion]="K";
PrintAsCharacter[TFContorsion]="\!\(\*OverscriptBox[\(K\), \((tf)\)]\)";
PrintAsCharacter[NonMetricity]="Q";
PrintAsCharacter[TFNonMetricity]="\!\(\*OverscriptBox[\(Q\), \((tf)\)]\)";
PrintAsCharacter[NonMetricityTrace]="Q";
PrintAsCharacter[TFTorsion]="\!\(\*OverscriptBox[\(T\), \((tf)\)]\)";
PrintAsCharacter[TorsionVector]="T";


(* ::Input::Initialization:: *)
GiveOutputString[tensor_Symbol?CovDTensorQ,covd_]:=StringJoin[PrintAsCharacter[tensor],"[",SymbolOfCovD[covd][[2]],"]"];


(* ::Input::Initialization:: *)
xTension["xMAG`",TFRicci,"End"]:=xMAGxTensorTFRicci;
xMAGxTensorTFRicci[covd_Symbol?CovDQ]:=GiveSymbol[TFRicci,covd];


(* ::Input::Initialization:: *)
DistortionTrace[comp_][covd_]:=ToExpression[StringJoin[ToString[DistortionTrace],ToString[comp],ToString[covd]]];
DisformationTrace[comp_][covd_]:=ToExpression[StringJoin[ToString[DisformationTrace],ToString[comp],ToString[covd]]];
NonMetricityTrace[comp_][covd_]:=ToExpression[StringJoin[ToString[NonMetricityTrace],ToString[comp],ToString[covd]]];


(* ::Input::Initialization:: *)
(** Some Output format **)
Format[Parenthesis[e_]]:=DisplayForm@RowBox[{"(",MakeBoxes@e,")"}];
xMAGPrint[xMAGsymbol_,character_,xTensorSymbol_]:=Module[{},
If[character===Null,Return[ToString[Overscript[ToExpression[PrintAsCharacter[xMAGsymbol]],Parenthesis[DisplayForm[ToExpression[PrintAsCharacter[xTensorSymbol]]]]],StandardForm]],
Return[ToString[Overscript[ToExpression[PrintAsCharacter[xMAGsymbol]],Parenthesis[DisplayForm[character]DisplayForm[ToExpression[PrintAsCharacter[xTensorSymbol]]]]],StandardForm]]
];
];
xMAGPrint[xMAGsymbol_,character_]:=ToString[Overscript[ToExpression[PrintAsCharacter[xMAGsymbol]],Parenthesis[DisplayForm[character]]],StandardForm];
xMAGIRDPrint[xMAGsymbol_,covd_,character_]:=StringJoin[ToString[Overscript[ToExpression[PrintAsCharacter[xMAGsymbol]],Parenthesis[DisplayForm[character]]],StandardForm],"[",SymbolOfCovD[covd][[2]],"]"];


(* ::Input::Initialization:: *)
GradMetricToNonMetricity[]:=Apply[Join,Map[GradMetricToNonMetricityRule,$CovDs]];
GradMetricToNonMetricity[___]:={};


(* ::Input::Initialization:: *)
ClearGradMetricToNonMetricity[cd_?(NonMetricityQ[#]&),options___?OptionQ]:=(ClearAutomaticRules[Evaluate[MasterOf[cd]],GradMetricToNonMetricity[cd],options];
cd/: GradMetricToNonMetricityQ[cd]:=False;
);
SetGradMetricToNonMetricity[cd_?(NonMetricityQ[#]&),options___?OptionQ]:=(AutomaticRules[Evaluate[MasterOf[cd]],GradMetricToNonMetricity[cd],options];
cd/: GradMetricToNonMetricityQ[cd]:=True;
);


(* ::Input::Initialization:: *)
ConnectionRelations[]:=Apply[Join,Map[ConnectionRelations,$CovDs]];
ConnectionRelations[covd_Symbol?CovDQ]:=Join[ConnectionRelations[covd,Distortion],ConnectionRelations[covd,NonMetricity],ConnectionRelations[covd,Torsion]];
ConnectionRelations[___]:={};


(* ::Input::Initialization:: *)
ClearConnectionRelations[cd_?(TorsionQ[#]&&NonMetricityQ[#]&),options___?OptionQ]:=(ClearAutomaticRules[Evaluate[GiveSymbol[Distortion,cd]],ConnectionRelations[cd,Distortion],options];
ClearAutomaticRules[Evaluate[GiveSymbol[Torsion,cd]],ConnectionRelations[cd,Torsion],options];
ClearAutomaticRules[Evaluate[GiveSymbol[NonMetricity,cd]],ConnectionRelations[cd,NonMetricity],options];
cd/: ConnectionRelationsQ[cd]:=False;
);

ClearConnectionRelations[cd_?(!TorsionQ[#]&&NonMetricityQ[#]&),options___?OptionQ]:=(ClearAutomaticRules[Evaluate[GiveSymbol[Disformation,cd]],ConnectionRelations[cd,Distortion],options];
ClearAutomaticRules[Evaluate[GiveSymbol[NonMetricity,cd]],ConnectionRelations[cd,NonMetricity],options];
cd/: ConnectionRelationsQ[cd]:=False;
);

ClearConnectionRelations[cd_?(TorsionQ[#]&&!NonMetricityQ[#]&),options___?OptionQ]:=(ClearAutomaticRules[Evaluate[GiveSymbol[Contorsion,cd]],ConnectionRelations[cd,Distortion],options];
ClearAutomaticRules[Evaluate[GiveSymbol[Torsion,cd]],ConnectionRelations[cd,Torsion],options];
cd/: ConnectionRelationsQ[cd]:=False;
);


(* ::Input::Initialization:: *)
SetConnectionRelations[cd_?(TorsionQ[#]&&NonMetricityQ[#]&),options___?OptionQ]:=(AutomaticRules[Evaluate[GiveSymbol[Distortion,cd]],ConnectionRelations[cd,Distortion],options];
AutomaticRules[Evaluate[GiveSymbol[Torsion,cd]],ConnectionRelations[cd,Torsion],options];
AutomaticRules[Evaluate[GiveSymbol[NonMetricity,cd]],ConnectionRelations[cd,NonMetricity],options];
cd/: ConnectionRelationsQ[cd]:=True;
);

SetConnectionRelations[cd_?(!TorsionQ[#]&&NonMetricityQ[#]&),options___?OptionQ]:=(AutomaticRules[Evaluate[GiveSymbol[Disformation,cd]],ConnectionRelations[cd,Distortion],options];
AutomaticRules[Evaluate[GiveSymbol[NonMetricity,cd]],ConnectionRelations[cd,NonMetricity],options];
cd/: ConnectionRelationsQ[cd]:=True;
);

SetConnectionRelations[cd_?(TorsionQ[#]&&!NonMetricityQ[#]&),options___?OptionQ]:=(AutomaticRules[Evaluate[GiveSymbol[Contorsion,cd]],ConnectionRelations[cd,Distortion],options];
AutomaticRules[Evaluate[GiveSymbol[Torsion,cd]],ConnectionRelations[cd,Torsion],options];
cd/: ConnectionRelationsQ[cd]:=True;
);


(* ::Input::Initialization:: *)
ClearCurvatureRelations[cd_?CovDQ/;!NonMetricityQ[cd],options___?OptionQ]:=(ClearAutomaticRules[Evaluate[GiveSymbol[Ricci,cd]],CurvatureRelations[cd,Ricci],options];ClearAutomaticRules[Evaluate[GiveSymbol[Riemann,cd]],CurvatureRelations[cd,Riemann],options];ClearAutomaticRules[Evaluate[GiveSymbol[SymRiemann,cd]],CurvatureRelations[cd,SymRiemann],options];
CurvatureRelationsQ[cd]=False;);
ClearCurvatureRelations[cd_?CovDQ/;NonMetricityQ[cd],options___?OptionQ]:=(ClearAutomaticRules[Evaluate[GiveSymbol[Ricci,cd]],CurvatureRelations[cd,Ricci],options];
ClearAutomaticRules[Evaluate[GiveSymbol[CoRicci,cd]],CurvatureRelations[cd,CoRicci],options];
ClearAutomaticRules[Evaluate[GiveSymbol[Riemann,cd]],CurvatureRelations[cd,Riemann],options];
CurvatureRelationsQ[cd]=False;);

SetCurvatureRelations[cd_?CovDQ/;!NonMetricityQ[cd],options___?OptionQ]:=(AutomaticRules[Evaluate[GiveSymbol[Ricci,cd]],CurvatureRelations[cd,Ricci],options];AutomaticRules[Evaluate[GiveSymbol[Riemann,cd]],CurvatureRelations[cd,Riemann],options];AutomaticRules[Evaluate[GiveSymbol[SymRiemann,cd]],CurvatureRelations[cd,SymRiemann],options];
CurvatureRelationsQ[cd]=True;);
SetCurvatureRelations[cd_?CovDQ/;NonMetricityQ[cd],options___?OptionQ]:=(AutomaticRules[Evaluate[GiveSymbol[Ricci,cd]],CurvatureRelations[cd,Ricci],options];
AutomaticRules[Evaluate[GiveSymbol[CoRicci,cd]],CurvatureRelations[cd,CoRicci],options];AutomaticRules[Evaluate[GiveSymbol[Riemann,cd]],CurvatureRelations[cd,Riemann],options];
CurvatureRelationsQ[cd]=True;);


(* ::Input::Initialization:: *)
GradMetricToNonMetricityRule[covd_?CovDQ,metric_?MetricQ]:=Module[
{vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]
},
With[{a= indices[[1]],
		b= indices[[2]],
		c= indices[[3]],
	nonmetricty=GiveSymbol[NonMetricity,covd]
},
ToRule[covd[-a][metric[-b,-c]]==nonmetricty[-a,-b,-c],MetricOn->{a}]
]
]


(* ::Input::Initialization:: *)
SetGradMetricToNonMetricityRule[covd_?CovDQ,metric_?MetricQ]:=Module[
{vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]},
With[{a= indices[[1]],
	b= indices[[2]],
		c= indices[[3]],
	nonmetricty=GiveSymbol[NonMetricity,covd]
},
AutomaticRules[metric,GradMetricToNonMetricityRule[covd,metric]]
]
]


(* ::Input::Initialization:: *)
xTension["xMAG`xTras`",DefCovD,"End"]:=xMAGDefCovD;


xMAGDefCovD[covd_[ind_],vbundles_,options___?OptionQ]:=With[
	{vb=VBundleOfIndex[ind],M=BaseOfVBundle@VBundleOfIndex[ind],indices = GetIndicesOfVBundle[VBundleOfIndex[ind], 8],
	metricQ= (FromMetric/. CheckOptions[options] /. Options[DefCovD]) =!= Null,mocQ= (Master/. CheckOptions[options] /. Options[DefCovD]) =!= Null,
	torsionQ= Torsion/. CheckOptions[options] /. Options[DefCovD],definfo= DefInfo /. CheckOptions[options] /. Options[DefCovD],
	curvrels= CurvatureRelations/. CheckOptions[options] /. Options[DefCovD],
	connectionrels= ConnectionRelations /. CheckOptions[options] /. Options[DefCovD],autoNMQ=OptionValue[DefCovD,{options},GradMetricToNonMetricity],
	pw=ProjectedWith/. CheckOptions[options] /. Options[DefCovD],
	ov=OrthogonalTo/. CheckOptions[options] /. Options[DefCovD],
	dcpQ=DefConnectionPerturbation/. CheckOptions[options] /. Options[DefCovD]
	},
	With[{dimM=DimOfManifold[M],info= If[definfo =!= False, $DefInfoQ, False],
			projectedQ=(pw=!={}),orthogonalQ=(ov=!={}),riemann=GiveSymbol[Riemann,covd],
			weylmag=GiveSymbol[Weyl,covd],Nriemann=GiveSymbol[NRiemann,covd],
			Nweylmag=GiveSymbol[NWeyl,covd],homothetic=GiveSymbol[Homothetic,covd],coricci=GiveSymbol[CoRicci,covd],tfcoricci=GiveSymbol[TFCoRicci,covd],
			tfricci=GiveSymbol[TFRicci,covd],ricci=GiveSymbol[Ricci,covd],einstein=GiveSymbol[Einstein,covd],ricciscalar=GiveSymbol[RicciScalar,covd],distortion= GiveSymbol[Distortion,covd],
			tfdistortion=GiveSymbol[TFDistortion,covd],distortiont1=GiveSymbol[DistortionTrace,1,covd],distortiont2=GiveSymbol[DistortionTrace,2,covd],
			distortiont3=GiveSymbol[DistortionTrace,3,covd],tfnonmetricity=GiveSymbol[TFNonMetricity,covd],tftorsion=GiveSymbol[TFTorsion,covd],
			disformation= GiveSymbol[Disformation,covd],tfdisformation= GiveSymbol[TFDisformation,covd],
			disformation1=GiveSymbol[DisformationTrace,1,covd],disformation2=GiveSymbol[DisformationTrace,2,covd],contorsion=GiveSymbol[Contorsion,covd],
			tfcontorsion= GiveSymbol[TFContorsion,covd],nonmetricity=GiveSymbol[NonMetricity,covd],
			torsion=GiveSymbol[Torsion,covd],torsionvec=GiveSymbol[TorsionVector,covd],weylvec=GiveSymbol[NonMetricityTrace,1,covd],tracenonmetricity2= GiveSymbol[NonMetricityTrace,2,covd],
			christoffel=GiveSymbol[Christoffel,covd],pertchristoffel=GiveSymbol[Perturbation,Christoffel,covd],
			a= indices[[1]],
			b= indices[[2]],
			c= indices[[3]],
			d= indices[[4]],
			a1= indices[[5]],
			b1= indices[[6]],
			c1= indices[[7]],
			d1= indices[[8]]
			},
		Module[{nv,projector,cd,imetric,integerdimQ},With[{metric=Master/. CheckOptions[options] /. Options[DefCovD]},
	If[mocQ&&(!metricQ||torsionQ),
		imetric=Inv[metric];
		cd=CovDOfMetric[metric];
		integerdimQ=IntegerQ[dimM];
		(* orthogonality and projections *)
		If[orthogonalQ,nv=ov[[1,0]]];
		If[projectedQ,projector=pw[[1,0]]];
		If[!metricQ,
		(*** MAG Weyl tensor ***)
		DefTensor[weylmag[-a,-b,-c,d],M,Antisymmetric[{-a,-b}],TraceFree->{-a,-b,-c,d},PrintAs -> GiveOutputString[Weyl,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a],nv[b],nv[c],nv[-d]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1],projector[b,-b1],projector[c,-c1],projector[-d,d1]},{}],
						 DefInfo -> If[info, {"Totally traceless generalized Weyl tensor",""}, False],TensorID->{Weyl,covd}];
		(**** Trace free part of the Ricci tensor ****)
		DefTensor[tfricci[-a,-b],DependenciesOfCovD[covd],TraceFree->{-a,-b},
							PrintAs:>GiveOutputString[TFRicci,covd],Master->covd, 
							OrthogonalTo:>If[orthogonalQ,{nv[a],nv[b]},{}],
							ProjectedWith:>If[projectedQ,{projector[a,-a1],projector[b,-b1]},{}],
							DefInfo -> If[info, {"trace free part of the Ricci tensor",""}, False],TensorID->{TFRicci,covd}];
		(**** RicciScalar *****)
		DefTensor[ricciscalar[],M, PrintAs -> GiveOutputString[RicciScalar,covd],
						Master-> covd, DefInfo -> If[info, {"Ricci scalar",""}, False],TensorID->{RicciScalar,covd}];
		(*** Einstein tensor ****)
		DefTensor[einstein[-a,-b],M,PrintAs -> GiveOutputString[Einstein,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a],nv[b]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1],projector[b,-b1]},{}],
						DefInfo -> If[info, {"Einstein tensor",""}, False],TensorID->{Einstein,covd}]					
		];
					
(***************************************************************************************************************)	
(************************* When the connection has torsion and nonmetricity ************************************)
(***************************************************************************************************************)	
		If[!metricQ && torsionQ,
		NonMetricityQ[covd,metric]=True;
		(***********************************************)	
		(*************** Curvature tensors *************)
		(***********************************************)		
		DefTensor[coricci[a,-b],M,PrintAs -> GiveOutputString[CoRicci,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b]},{}],
						ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1]},{}],
						DefInfo -> If[info, {"CoRicci tensor",""}, False],TensorID->{CoRicci,covd}];
		DefTensor[tfcoricci[a,-b],DependenciesOfCovD[covd],TraceFree->{a,-b},
							PrintAs:>GiveOutputString[TFCoRicci,covd],Master->covd, 
							OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b]},{}],
							ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1]},{}],
							DefInfo -> If[info, {"trace free part of the Co-Ricci tensor",""}, False],
							TensorID->{TFCoRicci,covd}];
		DefTensor[homothetic[-a,-b],M,Antisymmetric[{-a,-b}],PrintAs -> GiveOutputString[Homothetic,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a],nv[b]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1],projector[b,-b1]},{}],
						 DefInfo -> If[info, {"Homothetic tensor",""}, False],TensorID->{Homothetic,covd}];
		homothetic/:homothetic[a_Symbol,-a_Symbol]:=0;
		homothetic/:homothetic[-a_Symbol,a_Symbol]:=0;
		(***********************************************)	
		(************** Connection tensors *************)
		(***********************************************)	
		DefTensor[distortion[a,-b,-c],M,PrintAs -> GiveOutputString[Distortion,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"distortion tensor",""}, False],TensorID->{Distortion,covd}];
		DefTensor[tfdistortion[a,-b,-c],DependenciesOfCovD[covd],TraceFree->{a,-b,-c},
							PrintAs:>GiveOutputString[TFDistortion,covd],Master->covd,
							OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b],nv[c]},{}],
							ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1],projector[c,-c1]},{}],
							DefInfo -> If[info, {"trace free part of the Distortion tensor",""}, False],TensorID->{TFDistortion,covd}];
		DefTensor[distortiont1[a],M,PrintAs-> xMAGPrint[DistortionTrace,1],
							OrthogonalTo:>If[orthogonalQ,{nv[-a]},{}],
							ProjectedWith:>If[projectedQ,{projector[-a,a1]},{}]];
		DefTensor[distortiont2[-a],M,PrintAs-> xMAGPrint[DistortionTrace,2],
							OrthogonalTo:>If[orthogonalQ,{nv[a]},{}],
							ProjectedWith:>If[projectedQ,{projector[a,-a1]},{}]];	
		DefTensor[distortiont3[-a],M,PrintAs-> xMAGPrint[DistortionTrace,3],OrthogonalTo:>If[orthogonalQ,{nv[a]},{}],
							ProjectedWith:>If[projectedQ,{projector[a,-a1]},{}]];						
		DefTensor[contorsion[a,-b,-c],M,Antisymmetric[{1,3}],ForceSymmetries->True,PrintAs -> GiveOutputString[Contorsion,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"antisymmetric contorsion tensor",""}, False],TensorID->{Contorsion,covd}];	
		DefTensor[torsionvec[-a],M,PrintAs -> GiveOutputString[TorsionVector,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1]},{}],
						DefInfo -> If[info, {"torsion vector",""}, False],TensorID->{TorsionVector,covd}];
		DefTensor[tftorsion[a,-b,-c],M,Antisymmetric[{2,3}],TraceFree->{a,-b,-c},PrintAs -> GiveOutputString[TFTorsion,covd],
						Master-> covd, 
						OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"trace free part of the Torsion tensor",""}, False],TensorID->{TFTorsion,covd}];
		DefTensor[disformation[a,-b,-c],M,Symmetric[{2,3}],PrintAs -> GiveOutputString[Disformation,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"symmetric disformation tensor",""}, False],TensorID->{Disformation,covd}];
		DefTensor[nonmetricity[-a,-b,-c],M,Symmetric[{2,3}],PrintAs -> GiveOutputString[NonMetricity,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"symmetric NonMetricity tensor",""}, False],TensorID->{NonMetricity,covd}];
		DefTensor[tfnonmetricity[-a,-b,-c],M,Symmetric[{2,3}],TraceFree->{-a,-b,-c},PrintAs -> GiveOutputString[TFNonMetricity,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"trace free part of the NonMetricity tensor",""}, False],TensorID->{TFNonMetricity,covd}];
		DefTensor[weylvec[a],M,PrintAs -> "Q",
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[-a]},{}],
							ProjectedWith:>If[projectedQ,{projector[-a,a1]},{}],
						DefInfo -> If[info, {"Weyl vector",""}, False],TensorID->{NonMetricityTrace,covd}];	
		DefTensor[tracenonmetricity2[-a],M,PrintAs -> "\!\(\*OverscriptBox[\(Q\), \(~\)]\)",
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1]},{}],
						DefInfo -> If[info, {"Second trace of non-metricity",""}, False],TensorID->{NonMetricityTrace,covd}];									
		(**********************************************)	
		(************** TraceFree rules ***************)
		(**********************************************)
		If[!FrozenMetricQ[metric],
		CoRicciToTFCoRicciRules[covd]=ToRule[coricci[a,-b]==tfcoricci[a,-b]+TraceProject[coricci[a,-b],metric]];
		TFCoRicciToCoRicciRules[covd]=ToRule[tfcoricci[a,-b]==TracelessProject[coricci[a,-b],1,metric]];
		RicciToTFRicciRules[covd]=ToRule[ricci[-a,-b]==tfricci[-a,-b]+TraceProject[ricci[-a,-b],metric]];
		TFRicciToRicciRules[covd]=ToRule[tfricci[-a,-b]==TracelessProject[ricci[-a,-b],1,metric]];
		TFDistortionToDistortionRules[covd]=ToRule[tfdistortion[a,-b,-c]==(TracelessProject[distortion[a,-b,-c],1,metric])];
		DistortionToTFDistortionRules[covd]=ToRule[distortion[a,-b,-c]==(tfdistortion[a,-b,-c]+TraceProject[distortion[a,-b,-c],metric])];
		TFNonMetricityToNonMetricityRules[covd]=ToRule[tfnonmetricity[a,-b,-c]==(TracelessProject[nonmetricity[a,-b,-c],1,metric])];
		NonMetricityToTFNonMetricityRules[covd]=ToRule[nonmetricity[a,-b,-c]==(tfnonmetricity[a,-b,-c]+TraceProject[nonmetricity[a,-b,-c],metric])];
		TFTorsionToTorsionRules[covd]=ToRule[tftorsion[a,-b,-c]==(TracelessProject[torsion[a,-b,-c],1,metric])];
		TorsionToTFTorsionRules[covd]=ToRule[torsion[a,-b,-c]==(tftorsion[a,-b,-c]+TraceProject[torsion[a,-b,-c],metric])],
		(**Frozen metric**)
		CoRicciToTFCoRicciRules[covd]=SafeToRule[coricci[a,-b]==tfcoricci[a,-b]+TraceProject[coricci[a,-b],metric]];
		TFCoRicciToCoRicciRules[covd]=SafeToRule[tfcoricci[a,-b]==TracelessProject[coricci[a,-b],1,metric]];
		RicciToTFRicciRules[covd]=SafeToRule[ricci[-a,-b]==tfricci[-a,-b]+TraceProject[ricci[-a,-b],metric]];
		TFRicciToRicciRules[covd]=SafeToRule[tfricci[-a,-b]==TracelessProject[ricci[-a,-b],1,metric]];
		TFDistortionToDistortionRules[covd]=SafeToRule[tfdistortion[a,-b,-c]==(TracelessProject[distortion[a,-b,-c],1,metric])];
		DistortionToTFDistortionRules[covd]=SafeToRule[distortion[a,-b,-c]==(tfdistortion[a,-b,-c]+TraceProject[distortion[a,-b,-c],metric])];
		TFNonMetricityToNonMetricityRules[covd]=SafeToRule[tfnonmetricity[a,-b,-c]==(TracelessProject[nonmetricity[a,-b,-c],1,metric])];
		NonMetricityToTFNonMetricityRules[covd]=SafeToRule[nonmetricity[a,-b,-c]==(tfnonmetricity[a,-b,-c]+TraceProject[nonmetricity[a,-b,-c],metric])];
		TFTorsionToTorsionRules[covd]=SafeToRule[tftorsion[a,-b,-c]==(TracelessProject[torsion[a,-b,-c],1,metric])];
		TorsionToTFTorsionRules[covd]=SafeToRule[torsion[a,-b,-c]==(tftorsion[a,-b,-c]+TraceProject[torsion[a,-b,-c],metric])]];
		(*************************************************************************************************************)	
		(*********** Ricci versus Einstein : we take the convention of Aoki/Shimada : arXiv: 1904.10175v1 ************)
		(*************************************************************************************************************)
		(**** For dim=2, it is not clear for me what to do ***)
		RicciToEinsteinRules[covd]=
		If[If[integerdimQ,dimM>1,True],
		If[info,Print["** DefCovD:  Computing RicciToEinsteinRules for dim ",dimM]];
		MakeRule[{ricci[-a,-b],2*einstein[-a,-b]-coricci[-a,-b]+metric[-a,-b]ricciscalar[]},MetricOn->All,TestIndices->False,ContractMetrics->True],{}];
		EinsteinToRicciRules[covd]=If[If[integerdimQ,dimM>=3,True],MakeRule[{einstein[-a,-b],(ricci[-a,-b]+coricci[-a,-b]-metric[-a,-b]*ricciscalar[])/2}],{}];
		(***********************************************)	
		(*********** Connection relations **************)
		(***********************************************)
		If[!FrozenMetricQ[metric],
		ConnectionRelations[covd,Distortion]=Join[MakeRule[{distortion[b,-a,a],distortiont1[b]}],MakeRule[{distortion[a,-b,-a],distortiont2[-b]}],MakeRule[{distortion[a,-a,-b],distortiont3[-b]}]];
		ConnectionRelations[covd,NonMetricity]=Join[MakeRule[{nonmetricity[a,-b,-a],tracenonmetricity2[-b]}],MakeRule[{nonmetricity[b,a,-a],weylvec[b]}]];
		ConnectionRelations[covd,Torsion]=MakeRule[{torsion[a, -b,-a],torsionvec[-b]}],
		ConnectionRelations[covd,Distortion]=Join[MakeRule[{distortion[b,-a,a],distortiont1[b]}],MakeRule[{distortion[a,-b,-a],distortiont2[-b]}],MakeRule[{distortion[a,-a,-b],distortiont3[-b]}]];
		ConnectionRelations[covd,NonMetricity]=Join[MakeRule[{nonmetricity[a, -b ,-a ],tracenonmetricity2[-b]}],MakeRule[{nonmetricity[b,a,-a],weylvec[b]}]];
		ConnectionRelations[covd,Torsion]=MakeRule[{torsion[a, -b,-a],torsionvec[-b]}]];
		If[connectionrels,
		If[info,Print["** DefCovD:  Contractions of Distortion, Torsion, and Nonmetritcity automatically replaced by correcponding vectors."]];
			covd/: ConnectionRelationsQ[covd]:=True;
			AutomaticRules[distortion,ConnectionRelations[covd,Distortion],Verbose->False];
			AutomaticRules[nonmetricity,ConnectionRelations[covd,NonMetricity],Verbose->False];
			AutomaticRules[torsion,ConnectionRelations[covd,Torsion],Verbose->False];
			,covd/:ConnectionRelationsQ[covd]:=False];			
		(** Automatic Conversion of grad metric to nonmetricity **)
		GradMetricToNonMetricity[covd]=MakeRule[{covd[-a][metric[-b,-c]],nonmetricity[-a,-b,-c]},MetricOn->{a}];
		If[autoNMQ,
			SetGradMetricToNonMetricity[covd],
			covd/:GradMetricToNonMetricityQ[covd]:=False;
		];
		(***********************************************)	
		(*********** Curvature relations ***************)
		(***********************************************)
		If[!FrozenMetricQ[metric],
			Unprotect[CurvatureRelations];
			ClearAutomaticRules[riemann,CurvatureRelations[covd,Riemann],Verbose->False];
			covd/:CurvatureRelations[covd,Riemann]=.;
			covd/:CurvatureRelations[covd,Riemann]=Join[MakeRule[{riemann[-a,-b,-c,b],$RicciSign ricci[-a,-c]}],MakeRule[{riemann[-a,-c, c, b],-$RicciSign*coricci[-a, b]}],
			MakeRule[{riemann[-b, -c, -a, a],$RiemannSign*homothetic[-c, -b]}]];
			covd/:CurvatureRelations[covd,Ricci]=Join[CurvatureRelations[covd,Ricci],MakeRule[{ricci[-a,a],ricciscalar[]}]];
			covd/:CurvatureRelations[covd,CoRicci]=MakeRule[{coricci[d,-d],ricciscalar[]}];
			CurvatureRelations[covd]:=Join[CurvatureRelations[covd,Riemann],CurvatureRelations[covd,Ricci],CurvatureRelations[covd,CoRicci]];
			Protect[CurvatureRelations],
			Unprotect[CurvatureRelations];
			If[curvrels,
			ClearAutomaticRules[riemann,CurvatureRelations[covd,Riemann]]];
			covd/:CurvatureRelations[covd,Riemann]=.;(***** Nothing change if frozen because MakeRule handle everything*****)
			covd/:CurvatureRelations[covd,Riemann]=Join[MakeRule[{riemann[-a,-b,-c,b],$RicciSign ricci[-a,-c]}],MakeRule[{riemann[-a,-c, c, b],-$RicciSign*coricci[-a, b]}],
			MakeRule[{riemann[-b, -c, -a, a],$RiemannSign*homothetic[-c, -b]}]];
			covd/:CurvatureRelations[covd,Ricci]=Join[CurvatureRelations[covd,Ricci],MakeRule[{ricci[-a,a],ricciscalar[]}]];
			covd/:CurvatureRelations[covd,CoRicci]=MakeRule[{coricci[d,-d],ricciscalar[]}];
			CurvatureRelations[covd]:=Join[CurvatureRelations[covd,Riemann],CurvatureRelations[covd,Ricci],CurvatureRelations[covd,CoRicci]];
			Protect[CurvatureRelations]
			];
			If[curvrels,CurvatureRelationsQ[covd]:=True;
			AutomaticRules[riemann,CurvatureRelations[covd,Riemann],Verbose->False];
			AutomaticRules[ricci,CurvatureRelations[covd,Ricci],Verbose->False];
			AutomaticRules[coricci,CurvatureRelations[covd,CoRicci],Verbose->False];
			]		
		];
		
(***************************************************************************************************************)	
(************************* When the connection has nonmetricity but no torsion *********************************)
(***************************************************************************************************************)	
		
		If[!metricQ && !torsionQ,
		NonMetricityQ[covd,metric]=True;
		(***********************************************)	
		(*************** Curvature tensors *************)
		(***********************************************)			
		DefTensor[coricci[a,-b],M,PrintAs -> GiveOutputString[CoRicci,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b]},{}],
						ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1]},{}],
						DefInfo -> If[info, {"CoRicci tensor",""}, False],TensorID->{CoRicci,covd}];
		DefTensor[tfcoricci[a,-b],DependenciesOfCovD[covd],TraceFree->{a,-b},
							PrintAs:>GiveOutputString[TFCoRicci,covd],Master->covd, 
							OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b]},{}],
							ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1]},{}],
							DefInfo -> If[info, {"trace free part of the Co-Ricci tensor",""}, False],
							TensorID->{TFCoRicci,covd}];
		DefTensor[homothetic[-a,-b],M,Antisymmetric[{-a,-b}],PrintAs -> GiveOutputString[Homothetic,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a],nv[b]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1],projector[b,-b1]},{}],
						 DefInfo -> If[info, {"Homothetic tensor",""}, False],TensorID->{Homothetic,covd}];
		homothetic/:homothetic[a_Symbol,-a_Symbol]:=0;
		homothetic/:homothetic[-a_Symbol,a_Symbol]:=0;
		
		(***********************************************)	
		(************** Connection tensors *************)
		(***********************************************)
		DefTensor[disformation[a,-b,-c],M,Symmetric[{2,3}],PrintAs -> GiveOutputString[Disformation,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"symmetric disformation tensor",""}, False],TensorID->{Disformation,covd}];
		DefTensor[tfdisformation[a,-b,-c],M,Symmetric[{2,3}],TraceFree->{a,-b,-c},
							PrintAs:>GiveOutputString[TFDisformation,covd],Master->covd,
							OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b],nv[c]},{}],
							ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1],projector[c,-c1]},{}],
							DefInfo -> If[info, {"trace free part of the Disformation tensor",""}, False]
							,TensorID->{TFDisformation,covd}];
		DefTensor[disformation1[a],M,PrintAs-> xMAGPrint[DisformationTrace,1],
							OrthogonalTo:>If[orthogonalQ,{nv[-a]},{}],
							ProjectedWith:>If[projectedQ,{projector[-a,a1]},{}]];	
		DefTensor[disformation2[-a],M,PrintAs-> xMAGPrint[DisformationTrace,2],
							OrthogonalTo:>If[orthogonalQ,{nv[a]},{}],
							ProjectedWith:>If[projectedQ,{projector[a,-a1]},{}]];			
			
		DefTensor[nonmetricity[-a,-b,-c],M,Symmetric[{2,3}],PrintAs -> GiveOutputString[NonMetricity,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"symmetric NonMetricity tensor",""}, False],TensorID->{NonMetricity,covd}];
		DefTensor[tfnonmetricity[-a,-b,-c],M,Symmetric[{2,3}],TraceFree->{-a,-b,-c},PrintAs -> GiveOutputString[TFNonMetricity,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"trace free part of the NonMetricity tensor",""}, False],TensorID->{TFNonMetricity,covd}];
		DefTensor[weylvec[a],M,PrintAs -> GiveOutputString[NonMetricityTrace1,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[-a]},{}],
							ProjectedWith:>If[projectedQ,{projector[-a,a1]},{}],
						DefInfo -> If[info, {"Weyl vector",""}, False],TensorID->{NonMetricityTrace,covd}];	
		DefTensor[tracenonmetricity2[-a],M,PrintAs -> GiveOutputString[NonMetricityTrace2,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1]},{}],
						DefInfo -> If[info, {"Second trace of non-metricity",""}, False],TensorID->{NonMetricityTrace,covd}];		
		(**********************************************)	
		(************** TraceFree rules ***************)
		(**********************************************)
		CoRicciToTFCoRicciRules[covd]=ToRule[coricci[a,-b]==tfcoricci[a,-b]+TraceProject[coricci[a,-b],metric]];
		TFCoRicciToCoRicciRules[covd]=ToRule[tfcoricci[a,-b]==TracelessProject[coricci[a,-b],1,metric]];
		RicciToTFRicciRules[covd]=ToRule[ricci[-a,-b]==tfricci[-a,-b]+TraceProject[ricci[-a,-b],metric]];
		TFRicciToRicciRules[covd]=ToRule[tfricci[-a,-b]==TracelessProject[ricci[-a,-b],1,metric]];
		TFDisformationToDisformationRules[covd]=ToRule[tfdisformation[a,-b,-c]==(TracelessProject[disformation[a,-b,-c],1,metric])];
		DisformationToTFDisformationRules[covd]=ToRule[disformation[a,-b,-c]==(tfdisformation[a,-b,-c]+TraceProject[disformation[a,-b,-c],metric])];
		TFNonMetricityToNonMetricityRules[covd]=ToRule[tfnonmetricity[a,-b,-c]==(TracelessProject[nonmetricity[a,-b,-c],1,metric])];
		NonMetricityToTFNonMetricityRules[covd]=ToRule[nonmetricity[a,-b,-c]==(tfnonmetricity[a,-b,-c]+TraceProject[nonmetricity[a,-b,-c],metric])];
		(*************************************************************************************************************)	
		(*********** Ricci versus Einstein : we take the convention of Aoki/Shimada : arXiv: 1904.10175v1 ************)
		(*************************************************************************************************************)
		RicciToEinsteinRules[covd]=
		If[If[integerdimQ,dimM>1,True],
		If[info,Print["** DefCovD:  Computing RicciToEinsteinRules for dim ",dimM]];
		MakeRule[{ricci[-a,-b],2*einstein[-a,-b]-coricci[-a,-b]+metric[-a,-b]ricciscalar[]},MetricOn->All,TestIndices->False,ContractMetrics->True],{}];
		EinsteinToRicciRules[covd]=If[If[integerdimQ,dimM>=3,True],MakeRule[{einstein[-a,-b],(ricci[-a,-b]+coricci[-a,-b]-metric[-a,-b]*ricciscalar[])/2}],{}];	
		(***********************************************)	
		(*********** Connection relations **************)
		(***********************************************)
		ConnectionRelations[covd,Distortion]=Join[MakeRule[{disformation[b,-a,a],disformation1[b]}],MakeRule[{disformation[a,-b,-a],disformation2[-b]}]];
		ConnectionRelations[covd,NonMetricity]=Join[MakeRule[{nonmetricity[a, -b ,-a],tracenonmetricity2[-b]}],MakeRule[{nonmetricity[b,a,-a],weylvec[b]}]];
		If[connectionrels,
		If[info,Print["** DefCovD:  Contractions of Distortion, Torsion, and Nonmetritcity automatically replaced by corresponding vectors."]];
			covd/: ConnectionRelationsQ[covd]:=True;
			AutomaticRules[disformation,ConnectionRelations[covd,Distortion],Verbose->False];
			AutomaticRules[nonmetricity,ConnectionRelations[covd,NonMetricity],Verbose->False]
			,covd/:ConnectionRelationsQ[covd]:=False];
			
		(** Automatic Conversion of grad metric to nonmetricity **)
		GradMetricToNonMetricity[covd]=MakeRule[{covd[-a][metric[-b,-c]],nonmetricity[-a,-b,-c]},MetricOn->{a}];
		If[autoNMQ,
			SetGradMetricToNonMetricity[covd],
			covd/:GradMetricToNonMetricityQ[covd]:=False;
		];
		(************************************************************************************)	
		(****************************** Curvature relations *********************************)
		(************************************************************************************)
		covd/:CurvatureRelations[covd,Riemann]=Join[MakeRule[{riemann[-a,-b,-c,b],$RicciSign ricci[-a,-c]}],MakeRule[{riemann[-a,-c, c, b],-$RicciSign*coricci[-a, b]}],
			MakeRule[{riemann[-c, -b, -a, a],$RiemannSign*homothetic[-b, -c]}]];
		If[!FrozenMetricQ[metric],
			Unprotect[CurvatureRelations];	
			covd/:CurvatureRelations[covd,Riemann]=Join[CurvatureRelations[covd,Riemann],MakeRule[{riemann[-c, -b, -a, a],$RiemannSign*homothetic[-b, -c]}]];
			covd/:CurvatureRelations[covd,Ricci]=Join[CurvatureRelations[covd,Ricci],MakeRule[{ricci[-a,a],ricciscalar[]}]];
			covd/:CurvatureRelations[covd,Riemann]=DeleteDuplicates@Join[CurvatureRelations[covd,Riemann],MakeRule[{riemann[-a, -c, c, b],-$RicciSign*coricci[-a, b]}]];
			covd/:CurvatureRelations[covd,CoRicci]=MakeRule[{coricci[d,-d],ricciscalar[]}];
			(************ From trace of Bianchi identity ****)
			covd/:CurvatureRelations[covd,Homothetic]=MakeRule[{homothetic[-a,-b],Evaluate[$RiemannSign*-2*Antisymmetrize[ricci[-a,-b],{-a,-b}]]}];
			(*covd/:CurvatureRelations[covd,Homothetic]={};*)
			CurvatureRelations[covd]:=Join[CurvatureRelations[covd,Riemann],CurvatureRelations[covd,Ricci],CurvatureRelations[covd,Homothetic],CurvatureRelations[covd,CoRicci]];
			Protect[CurvatureRelations],
			Unprotect[CurvatureRelations];
			If[curvrels,ClearAutomaticRules[riemann,CurvatureRelations[covd,Riemann]]];	
			covd/:CurvatureRelations[covd,Riemann]=.;
			covd/:CurvatureRelations[covd,Riemann]=Join[MakeRule[{riemann[-a,-b,-c,b],$RicciSign ricci[-a,-c]}],
			MakeRule[{imetric[d,c]riemann[-b,-c, -d, a],-$RicciSign*coricci[-b,a]},MakeRule[{riemann[-c, -b, -a, a],$RiemannSign*homothetic[-b, -c]}]]];
			covd/:CurvatureRelations[covd,Ricci]=.;
			covd/:CurvatureRelations[covd,Ricci]=MakeRule[{imetric[a,b]*ricci[-a,-b],ricciscalar[]}];
			covd/:CurvatureRelations[covd,CoRicci]=MakeRule[{coricci[d,-d],ricciscalar[]}];
			covd/:CurvatureRelations[covd,Homothetic]=MakeRule[{homothetic[-a,-b],Evaluate[-2*Antisymmetrize[ricci[-a,-b],{-a,-b}]]}];
			CurvatureRelations[covd]:=Join[CurvatureRelations[covd,Riemann],CurvatureRelations[covd,Ricci],CurvatureRelations[covd,Homothetic],CurvatureRelations[covd,CoRicci]];
			Protect[CurvatureRelations]
			];
			If[curvrels,CurvatureRelationsQ[covd]=True;
			AutomaticRules[riemann,CurvatureRelations[covd,Riemann],Verbose->False];
			AutomaticRules[ricci,CurvatureRelations[covd,Ricci],Verbose->False];
			AutomaticRules[homothetic,CurvatureRelations[covd,Homothetic],Verbose->False];
			AutomaticRules[coricci,CurvatureRelations[covd,CoRicci],Verbose->False];
			]		
		];
			
(***************************************************************************************************************)	
(*********************** When the connection has torsion but is metric compatible ******************************)
(***************************************************************************************************************)	
					
			If[metricQ && torsionQ,
			NonMetricityQ[covd,metric]=False;
			(* No additionnal curvature tensors when there is only torsion *)	
			(* We change the convention for the slots of Riemann : depends only on the connection by definition *)
			SlotsOfTensor[riemann]^:={-vb,-vb,-vb,vb};
			(***********************************************)	
			(************** Connection tensors *************)
			(***********************************************)
			DefTensor[contorsion[a,-b,-c],M,Antisymmetric[{1,3}],ForceSymmetries->True,PrintAs->GiveOutputString[Contorsion,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"antisymmetric Contorsion tensor",""}, False],TensorID->{Contorsion,covd}];	
			DefTensor[torsionvec[-a],M,PrintAs -> GiveOutputString[TorsionVector,covd],
						Master-> covd,
						OrthogonalTo:>If[orthogonalQ,{nv[a]},{}],
						ProjectedWith:>If[projectedQ,{projector[a,-a1]},{}],
						DefInfo -> If[info, {"torsion vector",""}, False],TensorID->{TorsionVector,covd}];
			DefTensor[tfcontorsion[a,-b,-c],M,Antisymmetric[{1,3}],ForceSymmetries->True,TraceFree->{a,-b,-c},
							PrintAs:>GiveOutputString[TFContorsion,covd],Master->covd,
							OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b],nv[c]},{}],
							ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1],projector[c,-c1]},{}],
							DefInfo -> If[info, {"trace free part of the Contorsion tensor",""}, False],TensorID->{TFContorsion,covd}];
			DefTensor[tftorsion[a,-b,-c],M,Antisymmetric[{2,3}],TraceFree->{a,-b,-c},PrintAs->GiveOutputString[TFTorsion,covd],
						Master-> covd, 
						OrthogonalTo:>If[orthogonalQ,{nv[-a],nv[b],nv[c]},{}],
						ProjectedWith:>If[projectedQ,{projector[-a,a1],projector[b,-b1],projector[c,-c1]},{}],
						DefInfo -> If[info, {"trace free part of the Torsion tensor",""}, False],TensorID->{TFTorsion,covd}];
						
			(**********************************************)	
			(************** TraceFree rules ***************)
			(**********************************************)
			RicciToTFRicciRules[covd]=ToRule[ricci[-a,-b]==tfricci[-a,-b]+TraceProject[ricci[-a,-b],metric]];
			TFRicciToRicciRules[covd]=ToRule[tfricci[-a,-b]==TracelessProject[ricci[-a,-b],1,metric]];
			TFContorsionToContorsionRules[covd]=ToRule[tfcontorsion[a,-b,-c]==(TracelessProject[contorsion[a,-b,-c],1,metric])];
			ContorsionToTFContorsionRules[covd]=ToRule[contorsion[a,-b,-c]==(tfcontorsion[a,-b,-c]+TraceProject[contorsion[a,-b,-c],metric])];
			TFTorsionToTorsionRules[covd]=ToRule[tftorsion[a,-b,-c]==(TracelessProject[torsion[a,-b,-c],1,metric])];
			TorsionToTFTorsionRules[covd]=ToRule[torsion[a,-b,-c]==(tftorsion[a,-b,-c]+TraceProject[torsion[a,-b,-c],metric])];
			
			(***********************************************)	
			(*********** Connection relations **************)
			(***********************************************)
			
			ConnectionRelations[covd,Torsion]=MakeRule[{torsion[a,-b,-a],torsionvec[-b]}];	
			ConnectionRelations[covd,Contorsion]=MakeRule[{contorsion[a,-a,-b],-torsionvec[-b]}];	
			(*ConnectionRelations[covd,Contorsion]=Join[MakeRule[{disformation[b,-a,a],disformation1[b]}],MakeRule[{disformation[a,-b,-a],disformation2[-b]}]];*)
			If[connectionrels,
			If[info,Print["** DefCovD:  Contractions of Distortion, Torsion, and Nonmetritcity automatically replaced by corresponding vectors."]];
				covd/: ConnectionRelationsQ[covd]:=True;
				AutomaticRules[torsion,ConnectionRelations[covd,Torsion],Verbose->False];
				AutomaticRules[contorsion,ConnectionRelations[covd,Distorsi],Verbose->False];
				,covd/:ConnectionRelationsQ[covd]:=False];
						
			(************************************************************************************)	
			(****************************** Curvature relations *********************************)
			(************************************************************************************)
			If[FrozenMetricQ[metric], (******** No change actually *******)
			Unprotect[CurvatureRelations];
			If[curvrels,
			ClearAutomaticRules[riemann,CurvatureRelations[covd,Riemann]]];
			covd/:CurvatureRelations[covd,Riemann]=.;
			covd/:CurvatureRelations[covd,Riemann]=MakeRule[{riemann[-a,-b,-c,b],$RicciSign*ricci[-a,-c]}];
			covd/:CurvatureRelations[covd,Ricci]=.;
			covd/:CurvatureRelations[covd,Ricci]=MakeRule[{imetric[a,b]*ricci[-a,-b],ricciscalar[]}];
			CurvatureRelations[covd]:=Join[CurvatureRelations[covd,Riemann],CurvatureRelations[covd,Ricci]];
			Protect[CurvatureRelations]
			];
			If[curvrels,CurvatureRelationsQ[covd]=True;
			AutomaticRules[riemann,CurvatureRelations[covd,Riemann],Verbose->False];
			AutomaticRules[ricci,CurvatureRelations[covd,Ricci],Verbose->False];
			]	
			];
			
(***************************************************************************************************************)	
(************************** Weyl To Riemann and Riemann To Weyl rules ******************************************)
(***************************************************************************************************************)	
			If[!FrozenMetricQ[metric],
			WeylToRiemannRules[covd]=ToRule[weylmag[-a,-b,-c,d]==CollectTensors[TracelessProject[riemann[-a,-b,-c,d],1,metric]]];
			RiemannToWeylRules[covd]=ToRule[riemann[-a,-b,-c,d]==CollectTensors[weylmag[-a,-b,-c,d]+
										TracelessProject[riemann[-a,-b,-c,d],2,metric]+TraceProject[riemann[-a,-b,-c,d],metric]]],
			WeylToRiemannRules[covd]=SafeToRule[weylmag[-a,-b,-c,d]==Collect[TracelessProject[riemann[-a,-b,-c,d],1,metric],{_metric,_imetric,_delta,_riemann,_ricci,_ricciscalar},Factor]];
			RiemannToWeylRules[covd]=SafeToRule[riemann[-a,-b,-c,d]==Collect[weylmag[-a,-b,-c,d]+
										TracelessProject[riemann[-a,-b,-c,d],2,metric]+TraceProject[riemann[-a,-b,-c,d],metric],{_metric,_imetric,
										_delta,_weylmag,_ricci,_ricciscalar},Factor]]];
			If[dcpQ,
				DefConnectionPerturbation[christoffel[a,-b,-c],pertchristoffel];
			];	
		]
		]
		]
		]
];


(* ::Input::Initialization:: *)
RiemannToWeylRules[PD]={};
WeylToRiemannRules[PD]={};
CoRicciToTFCoRicciRules[PD]={};
TFCoRicciToCoRicciRules[PD]={};
RicciToTFRicciRules[PD]={};
TFRicciToRicciRules[PD]={};
DistortionToTFDistortionRules[PD]={};
TFDistortionToDistortionRules[PD]={};
NonMetricityToTFNonMetricityRules[PD]={};
TFNonMetricityToNonMetricityRules[PD]={};
TorsionToTFTorsionRules[PD]={};
TFTorsionToTorsionRules[PD]={};
CoRicciToTFCoRicciRules[covd_?LeviCivitaQ]={};
TFCoRicciToCoRicciRules[covd_?LeviCivitaQ]={};
DistortionToTFDistortionRules[covd_?LeviCivitaQ]={};
TFDistortionToDistortionRules[covd_?LeviCivitaQ]={};
NonMetricityToTFNonMetricityRules[covd_?LeviCivitaQ]={};
TFNonMetricityToNonMetricityRules[covd_?LeviCivitaQ]={};
TorsionToTFTorsionRules[covd_?LeviCivitaQ]={};
TFTorsionToTorsionRules[covd_?LeviCivitaQ]={};
RicciToEinsteinRules[PD]={};
RicciToEinsteinRules[covd_?LeviCivitaQ]={};
EinsteinToRicciRules[PD]={};
EinsteinToRicciRules[covd_?LeviCivitaQ]={};


(* ::Input::Initialization:: *)
FirstMetricOfVBundle[vbundle_,mess_:True]:=firstmetricofvbundle[vbundle,MetricsOfVBundle[vbundle],mess];
firstmetricofvbundle[vbundle_,{},True]:=Throw@Message[MetricsOfVBundle::missing,"metric",vbundle];
firstmetricofvbundle[vbundle_,{},False]:=Null;
firstmetricofvbundle[vbundle_,list_List,_]:=First[list];
firstmetricofvbundle[vbundle_,list_,_]:=Throw@Message[MetricsOfVBundle::invalid,list,"list of metrics"];


(* ::Input::Initialization:: *)
FirstMetricQ[Null,___]:=False;
FirstMetricQ[metric_]:=FirstMetricQ[metric,VBundleOfMetric[metric]];
FirstMetricQ[metric_,vbundle_]:=metric===FirstMetricOfVBundle[vbundle,True];


(* ::Input::Initialization:: *)
FrozenMetricQ[metric_]:=And[Not@FirstMetricQ[metric],InducedFrom[metric]===Null];


(* ::Input::Initialization:: *)
deflistablexTensorxMAGCovDs[function_]:=With[{rules=SymbolJoin[function,"Rules"]},
Unprotect[function];
function[expr_,covd_Symbol?CovDQ]=.;
If[function===WeylToRiemann,
function[expr_,covd_Symbol?(!SameQ[#,PD]&&(LeviCivitaQ[#,MasterOf[#]]||(TorsionQ[#]&&!NonMetricityQ[#]))&)]:=expr/. xAct`xTensor`Private`WeylToRiemannRules[covd];
function[expr_,covd_Symbol]:=expr/.WeylToRiemannRules[covd]
];
If[function===RiemannToWeyl,
function[expr_,covd_Symbol?(!SameQ[#,PD]&&(LeviCivitaQ[#,MasterOf[#]]||(TorsionQ[#]&&!NonMetricityQ[#]))&)]:=expr/. xAct`xTensor`Private`RiemannToWeylRules[covd];
function[expr_,covd_Symbol]:=expr/.RiemannToWeylRules[covd]
];
If[function===TFRicciToRicci,
function[expr_,covd_Symbol?(!SameQ[#,PD]&&(LeviCivitaQ[#,MasterOf[#]]||(TorsionQ[#]&&!NonMetricityQ[#]))&)]:=expr/. xAct`xTensor`Private`TFRicciToRicciRules[covd];
function[expr_,covd_Symbol]:=expr/.TFRicciToRicciRules[covd]
];
If[function===RicciToTFRicci,
function[expr_,covd_Symbol?(!SameQ[#,PD]&&(LeviCivitaQ[#,MasterOf[#]]||(TorsionQ[#]&&!NonMetricityQ[#]))&)]:=expr/. xAct`xTensor`Private`RicciToTFRicciRules[covd];
function[expr_,covd_Symbol]:=expr/.RicciToTFRicciRules[covd]
];
If[function===EinsteinToRicci,
function[expr_,covd_Symbol?(!SameQ[#,PD]&&((LeviCivitaQ[#,MasterOf[#]]||(TorsionQ[#]&&!NonMetricityQ[#]))&&!FrozenMetricQ[MasterOf[#]])&)]:=expr/. xAct`xTensor`Private`EinsteinToRicciRules[covd];
function[expr_,covd_Symbol]:=expr/.EinsteinToRicciRules[covd]
];
If[function===RicciToEinstein,
function[expr_,covd_Symbol?(!SameQ[#,PD]&&(LeviCivitaQ[#,MasterOf[#]]||(TorsionQ[#]&&!NonMetricityQ[#]))&)]:=expr/. xAct`xTensor`Private`RicciToEinsteinRules[covd];
function[expr_,covd_Symbol]:=expr/.RicciToEinsteinRules[covd]
];
If[function===ProjectDerivative,
function[expr_,covd_Symbol?(!SameQ[#,PD]&&(LeviCivitaQ[#,MasterOf[#]]||(TorsionQ[#]&&!NonMetricityQ[#]))&)]:=expr/. xAct`xTensor`Private`ProjectDerivativeRules[covd];
function[expr_,covd_Symbol]:=expr/.ProjectDerivativeRules[covd]
];
function[expr_,PD]:=expr/.rules[PD];
(*function[expr_,covd_?NonMetricityQ]:=expr/.rules[covd];*)
SetNumberOfArguments[function,{1,2}];
Protect[function]
];


(* ::Input::Initialization:: *)
xAct`xTensor`Private`deflistableCovDs/@{CoRicciToTFCoRicci,TFCoRicciToCoRicci,DistortionToTFDistortion,TFDistortionToDistortion,NonMetricityToTFNonMetricity,TFNonMetricityToNonMetricity,TorsionToTFTorsion,TFTorsionToTorsion};


(* ::Input::Initialization:: *)
deflistablexTensorxMAGCovDs/@{RicciToTFRicci,TFRicciToRicci,RiemannToWeyl,WeylToRiemann,RicciToEinstein,EinsteinToRicci};


(* ::Input::Initialization:: *)
xTension["xMAG`",DefCovD,"Beginning"]:=DefCovDBeginning;
xTension["xMAG`",DefCovD,"End"]:=DefCovDEnd;


(* ::Input::Initialization:: *)
Unprotect[UndefCovD];
UndefCovD[covd_]:=Catch@With[{manifold=ManifoldOfCovD[covd],ef=ExtendedFrom[covd],master=MasterOf[covd]},Module[{servants=ServantsOf[covd],christoffels,christoffel=GiveSymbol[Christoffel,covd]},
If[!CovDQ[covd],Throw[Message[UndefCovD::unknown,"covariant derivative",covd]]];
If[master=!=Null,
ServantsOf[master]^=DeleteCases[ServantsOf[master],covd];
MasterOf[covd]^={}];
VisitorsOf[christoffel]^={};
xAct`xTensor`Private`CheckRemoveSymbol[covd];
MakexTensions[UndefCovD,"Beginning",covd];
xUpSet[ServantsOf[covd],{}];
christoffels=Cases[xAct`xTensor`Private`$Christoffels,{_,{___,covd,___},_}];
xAct`xTensor`Private`$Christoffels=Complement[xAct`xTensor`Private`$Christoffels,christoffels];
DropFromHosts[covd];
Undef/@Union[First/@christoffels,servants];
If[ef=!=Null,
xUpDeleteCasesTo[VisitorsOf[ef],covd];xAct`xTensor`Private`RemoveSymbol/@(StringJoin[#,ToString[covd]]&/@Join[{"Christoffel","Riemann","Ricci","Torsion"},If[MetricOfCovD[ef]=!=Null,{"RicciScalar","Weyl","TFRicci","Einstein","Kretschmann"},{}]])];
$CovDs=DeleteCases[$CovDs,covd];
If[MetricOfCovD[covd]=!=Null&&!FrozenQ[MetricOfCovD[covd]]||(!xTensorQ[GiveSymbol[Contorsion,covd]]||!xTensorQ[GiveSymbol[Disformation,covd]])&&MetricOfCovD[covd]===Null,
Unset[xAct`xTensor`Private`RiemannToWeylRules[covd]];
Unset[xAct`xTensor`Private`WeylToRiemannRules[covd]];
Unset[xAct`xTensor`Private`RicciToTFRicciRules[covd]];
Unset[xAct`xTensor`Private`TFRicciToRicciRules[covd]];
Unset[xAct`xTensor`Private`RicciToEinsteinRules[covd]];
Unset[xAct`xTensor`Private`EinsteinToRicciRules[covd]],
With[{nmq=NonMetricityQ[covd],torsionQ=TorsionQ[covd]},
If[nmq&&torsionQ,
Unset[RiemannToWeylRules[covd]];
Unset[WeylToRiemannRules[covd]];
Unset[RicciToTFRicciRules[covd]];
Unset[TFRicciToRicciRules[covd]];
Unset[CoRicciToTFCoRicciRules[covd]];
Unset[TFCoRicciToCoRicciRules[covd]];
Unset[DistortionToTFDistortionRules[covd]];
Unset[TFDistortionToDistortionRules[covd]];
Unset[NonMetricityToTFNonMetricityRules[covd]];
Unset[TFNonMetricityToNonMetricityRules[covd]];
Unset[TorsionToTFTorsionRules[covd]];
Unset[TFTorsionToTorsionRules[covd]],
If[nmq&&!torsionQ,
Unset[RiemannToWeylRules[covd]];
Unset[WeylToRiemannRules[covd]];
Unset[RicciToTFRicciRules[covd]];
Unset[TFRicciToRicciRules[covd]];
Unset[CoRicciToTFCoRicciRules[covd]];
Unset[TFCoRicciToCoRicciRules[covd]];
Unset[DisformationToTFDisformationRules[covd]];
Unset[TFDisformationToDisformationRules[covd]];
Unset[NonMetricityToTFNonMetricityRules[covd]];
Unset[TFNonMetricityToNonMetricityRules[covd]],
If[!nmq&&torsionQ,
Unset[RiemannToWeylRules[covd]];
Unset[WeylToRiemannRules[covd]];
Unset[RicciToTFRicciRules[covd]];
Unset[TFRicciToRicciRules[covd]];
Unset[ContorsionToTFContorsionRules[covd]];
Unset[TFContorsionToContorsionRules[covd]];
Unset[TorsionToTFTorsionRules[covd]];
Unset[TFTorsionToTorsionRules[covd]]]]]]
];
If[MetricOfCovD[covd]=!=Null&&!TorsionQ[covd],
Unset[SortCovDs[expr_,covd]]];
MakexTensions[UndefCovD,"End",covd];
xAct`xTensor`Private`$ChristoffelsMakeUndefInfo[UndefCovD,covd];
xAct`xTensor`Private`RemoveSymbol[covd];
]
];
Protect[UndefCovD];


(* ::Input::Initialization:: *)
(******* Need to be carefull with $TorsionSign ****) 

xAct`xTensor`Private`changeRiemann[covd1_,covd2_,{_,_,_},riemann_][-c_Symbol,-d_Symbol,-b_Symbol,a_Symbol]:=With[{chr=HeadOfTensor[Christoffel[covd1,covd2][a,-c,-b],{a,-c,-b}]},Module[{e=DummyAs[a]},
riemann[covd2][-c,-d,-b,a]+SafeCanonical[$RiemannSign(-covd2[-c][chr[a,-d,-b]]+covd2[-d][chr[a,-c,-b]]-chr[a,-c,-e]chr[e,-d,-b]+chr[a,-d,-e]chr[e,-c,-b]+If[riemann===Riemann,-$TorsionSign TorsionToDistortion[Torsion[covd2][e,-c,-d]]chr[a,-e,-b],0])]]];


(* ::Input::Initialization:: *)
(*** Private Booleen ***)
MAGChristoffelQ[covd_,metric_,options:OptionsPattern[]]:=False


(* ::Input::Initialization:: *)
Options[MAGChristoffelTensorStart]:={Verbose->True}
MAGChristoffelTensorStart[covd_,metric_,options:OptionsPattern[]]:=Module[{verbose},
With[{vb=First@VBundlesOfCovD[covd],M=BaseOfVBundle@First@VBundlesOfCovD[covd],torsionQ=TorsionQ[covd],
magChrisQ=MAGChristoffelQ[covd,metric],covdmet=CovDOfMetric[metric],indices = GetIndicesOfVBundle[First@VBundlesOfCovD[covd], 3]},
With[{a= indices[[1]],
	b= indices[[2]],
	c=indices[[3]],
	distortion= GiveSymbol[Distortion,covd],
	disformation= GiveSymbol[Disformation,covd],
	contorsion= GiveSymbol[Contorsion,covd],
	chriscovdmetcovd=GiveSymbol[Christoffel,covdmet,covd],
	chriscovdcovdmet=GiveSymbol[Christoffel,covd,covdmet]},
{verbose}=OptionValue[{MAGChristoffelTensorStart},{options},{Verbose}];
(* General connection *)
If[NonMetricityQ[covd,metric]&&TorsionQ[covd]&&!magChrisQ,
If[StringLength[ToString[covd]]>=StringLength[ToString[covdmet]],
	If[!xTensorQ[chriscovdmetcovd],DefTensor[chriscovdmetcovd[a,-b,-c],M,    PrintAs->GiveOutputString[Christoffel,covdmet,covd]]];
chriscovdmetcovd/:chriscovdmetcovd[inds___]:=-distortion[inds];
If[verbose,Print["** Automatic conversion of ", chriscovdmetcovd, " into ", distortion, " is on."]],
If[!xTensorQ[chriscovdcovdmet],DefTensor[chriscovdcovdmet[a,-b,-c],M,    PrintAs->GiveOutputString[Christoffel,covd,covdmet]]];
chriscovdcovdmet/:chriscovdcovdmet[inds___]:=distortion[inds];
If[verbose,Print["** Automatic conversion of ", chriscovdcovdmet, " into ", distortion, " is on."]]
]];

If[NonMetricityQ[covd,metric]&&TorsionQ[covd]&&magChrisQ,
If[verbose,Print["** Automatic conversion of ", chriscovdmetcovd, " into ", distortion, " is already on."]]];

(* Case: covd TorsionFree tangent bundle connection *)
If[NonMetricityQ[covd,metric]&&!TorsionQ[covd]&&!magChrisQ,
If[StringLength[ToString[covd]]>=StringLength[ToString[covdmet]],
	If[!xTensorQ[chriscovdmetcovd],DefTensor[chriscovdmetcovd[a,-b,-c],M,Symmetric[{2,3}],PrintAs->GiveOutputString[Christoffel,covdmet,covd]]];
	chriscovdmetcovd/:chriscovdmetcovd[inds___]:=-disformation[inds];
If[verbose,Print["** Automatic conversion of ", chriscovdmetcovd, " into ", disformation, " is on."]],
If[!xTensorQ[chriscovdcovdmet],DefTensor[chriscovdcovdmet[a,-b,-c],M,    PrintAs->GiveOutputString[Christoffel,covd,covdmet]]];
chriscovdcovdmet/:chriscovdcovdmet[inds___]:=disformation[inds];
If[verbose,Print["** Automatic conversion of ", chriscovdcovdmet, " into ", disformation, " is on."]]
]];

If[NonMetricityQ[covd,metric]&&!TorsionQ[covd]&&magChrisQ,If[verbose,Print["** Automatic conversion of ", chriscovdmetcovd, " into ", disformation, " is already on."]]];

(* Case: covd is metric with torsion *)
If[!NonMetricityQ[covd,metric]&&TorsionQ[covd]&&!magChrisQ,
If[StringLength[ToString[covd]]>=StringLength[ToString[covdmet]],
	If[!xTensorQ[chriscovdmetcovd],
DefTensor[chriscovdmetcovd[a,-b,-c],M,Symmetric[{1,3}],ForceSymmetries->True,PrintAs->GiveOutputString[Christoffel,covdmet,covd]]];
	chriscovdmetcovd/:chriscovdmetcovd[inds___]:=-contorsion[inds];
If[verbose,Print["** Automatic conversion of ", chriscovdmetcovd, " into ", contorsion, " is on."]],
If[!xTensorQ[chriscovdcovdmet],DefTensor[chriscovdcovdmet[a,-b,-c],M,    PrintAs->GiveOutputString[Christoffel,covd,covdmet]]];
chriscovdcovdmet/:chriscovdcovdmet[inds___]:=contorsion[inds];
If[verbose,Print["** Automatic conversion of ", chriscovdcovdmet, " into ", contorsion, " is on."]]
]];

If[NonMetricityQ[covd,metric]&&!TorsionQ[covd]&&magChrisQ,If[verbose,Print["** Automatic conversion of ", chriscovdmetcovd, " into ", contorsion, " is already on."]]];

MAGChristoffelQ[covd,metric]:=True
]]];


(* ::Input::Initialization:: *)
Options[MAGChristoffelTensorStop]:={Verbose->True}
MAGChristoffelTensorStop[covd_,metric_,options:OptionsPattern[]]:=Module[
{vb=First@VBundlesOfCovD[covd],
covdmet=CovDOfMetric[metric],
indices = GetIndicesOfVBundle[First@VBundlesOfCovD[covd], 3],verbose},
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	distortion= GiveSymbol[Distortion,covd],
		disformation= GiveSymbol[Disformation,covd],
		contorsion= GiveSymbol[Contorsion,covd],
	chriscovdmetcovd=GiveSymbol[Christoffel,covdmet,covd],
	chriscovdcovdmet=GiveSymbol[Christoffel,covd,covdmet]		
},
{verbose}=OptionValue[{MAGChristoffelTensorStop},{options},{Verbose}];
If[NonMetricityQ[covd,metric]&&TorsionQ[covd],
If[StringLength[ToString[covd]]>=StringLength[ToString[covdmet]],
	chriscovdmetcovd/:chriscovdmetcovd[inds___]=.;
If[verbose,Print["** Automatic conversion of ", chriscovdmetcovd, " into ", distortion, " is off."]],
chriscovdcovdmet/:chriscovdcovdmet[inds___]=.;
If[verbose,Print["** Automatic conversion of ", chriscovdcovdmet, " into ", distortion, " is off."]]
]];
If[NonMetricityQ[covd,metric]&&!TorsionQ[covd],
If[StringLength[ToString[covd]]>=StringLength[ToString[covdmet]],
	chriscovdmetcovd/:chriscdmetcovd[inds___]=.;
If[verbose,Print["** Automatic conversion of ", chriscovdmetcovd, " into ", disformation, " is off."]],
chriscovdcovdmet/:chriscovdcovdmet[inds___]=.;
If[verbose,Print["** Automatic conversion of ", chriscovdcovdmet, " into ", disformation, " is off."]]
]];
If[!NonMetricityQ[covd,metric]&&TorsionQ[covd],
If[StringLength[ToString[covd]]>=StringLength[ToString[covdmet]],
	chriscovdmetcovd/:chriscdmetcovd[inds___]=.;
If[verbose,Print["** Automatic conversion of ", chriscovdmetcovd, " into ", contorsion, " is off."]],
chriscovdcovdmet/:chriscovdcovdmet[inds___]=.;
If[verbose,Print["** Automatic conversion of ", chriscovdcovdmet, " into ",contorsion, " is off."]]
]];
MAGChristoffelQ[covd,metric]:=False;
]
]


(* ::Input::Initialization:: *)
Options[DefConnectionPerturbation]={PrintAs->"\[Delta]\[CapitalGamma]"};
DefConnectionPerturbation[christoffel_?xTensorQ[i1_,-i2_,-i3_],pert_Symbol,param_Symbol:Automatic,options___?OptionQ] :=Module[{covd=MasterOf[christoffel],vbundle=SlotsOfTensor[christoffel][[1]],manifold=Sequence@@DependenciesOfTensor[christoffel],indices,pa,torsionQ,nonmetricityQ,metric},
{pa}={PrintAs}/.CheckOptions[options]/.Options[DefConnectionPerturbation];
(* Define parameter if it does not exist yet *)
If[!ParameterQ[param],
If[param===Automatic,
DefParameter[GiveSymbol[PerturbationParameter,christoffel],PrintAs:>GiveOutputString[PerturbationParameter,christoffel]],
DefParameter[param]
]];
(*indices=GetIndicesOfVBundle[vbundle,4];*)
metric=MasterOf[covd];
torsionQ=TorsionQ[covd];
nonmetricityQ=NonMetricityQ[covd,metric];
If[torsionQ&&nonmetricityQ,
DefTensorPerturbation[pert[LI["order"],i1,-i2,-i3],christoffel[i1,-i2,-i3],manifold,PrintAs->pa]];
If[torsionQ&&!nonmetricityQ,
DefTensorPerturbation[pert[LI["order"],i1,-i2,-i3],christoffel[i1,-i2,-i3],manifold,Antisymmetric[{2,4}],ForceSymmetries->True,Master->metric,PrintAs->pa]];
If[!torsionQ&&nonmetricityQ,
DefTensorPerturbation[pert[LI["order"],i1,-i2,-i3],christoffel[i1,-i2,-i3],manifold,Symmetric[{3,4}],ForceSymmetries->True,Master->metric,PrintAs->pa]];
DefConnectionVariation[christoffel,pert,param]
(* Store perturbation structure in global variables *)
]


(* ::Input::Initialization:: *)
DefConnectionVariation[christoffel_?xTensorQ,pert_,Automatic]:=DefConnectionVariation[christoffel,pert,PerturbationParameter[christoffel]];


(* ::Input::Initialization:: *)
DefConnectionVariation[christoffel_?xTensorQ,per_,param_]:=Module[{covd=MasterOf[christoffel],var,M,vb,i1,i2,i3,i4,j1,a1,a2,a3,a4,torsionQ,nonmetricityQ,metric,cd,PertRiemannCD\[CapitalGamma],PertRicciCD\[CapitalGamma],PertCoRicciCD\[CapitalGamma],PertHomotheticCD\[CapitalGamma],PertRicciScalar\[CapitalGamma],PertWeyl\[CapitalGamma],pertmet,weyl},vb=SlotsOfTensor[christoffel][[1]];
M=BaseOfVBundle@vb;
{i1,i2,i3,i4,j1,a1,a2,a3,a4}=GetIndicesOfVBundle[vb,9];
metric=MasterOf[covd];
torsionQ=TorsionQ[covd];
nonmetricityQ=NonMetricityQ[covd,metric];
cd=CovDOfMetric[metric];
weyl=GiveSymbol[Weyl,covd];
MAGChristoffelTensorStart[covd,metric,Verbose->False];
If[Perturbation[christoffel[i1,-i2,-i3]]=!=per[LI[1],i1,-i2,-i3],Throw@Message[DefConnectionVariation::error,"connection perturbation does not match or is not defined."]];
Block[{$DefInfoQ=False},
If[torsionQ&&nonmetricityQ,
DefTensor[var[i1,-i2,-i3],M,Master->metric]];
If[torsionQ&&!nonmetricityQ,
DefTensor[var[i1,-i2,-i3],M,Antisymmetric[{1,3}],ForceSymmetries->True,Master->metric]];
If[!torsionQ&&nonmetricityQ,
DefTensor[var[i1,-i2,-i3],M,Symmetric[{2,3}],ForceSymmetries->True,Master->metric]]
];
(*********** To Do : DefMetric perturbation if not defined ??? *****)
With[{sqrt=Sqrt[SignDetOfMetric[metric] Determinant[metric][]]},
PertRiemannCD\[CapitalGamma]=Perturbation[Riemann[covd][-i1_Symbol,-i2_Symbol,-i3_Symbol,i4_Symbol]]:>christoffel[i4, -i2, -j1]*per[LI[1], j1, -i1, -i3] -christoffel[i4, -i1, -j1]*per[LI[1], j1, -i2, -i3] - christoffel[j1, -i2, -i3]*per[LI[1], i4, -i1, -j1] + christoffel[j1, -i1, -i3]*per[LI[1], i4, -i2, -j1] - PD[-i1][per[LI[1], i4, -i2, -i3]] + PD[-i2][per[LI[1], i4, -i1, -i3]];
PertRicciCD\[CapitalGamma]=Perturbation[Ricci[covd][-i1_Symbol,-i2_Symbol]]:>christoffel[i4, -i4, -i3]*per[LI[1],i3, -i1, -i2] -christoffel[i4, -i1, -j1]*per[LI[1], j1, -i4, -i2] - christoffel[j1, -i4, -i2]*per[LI[1], i4, -i1, -j1] + christoffel[j1, -i1, -i2]*per[LI[1], i4, -i4, -j1] - PD[-i1][per[LI[1], i4, -i4, -i2]] + PD[-i4][per[LI[1], i4, -i1, -i2]];
PertHomotheticCD\[CapitalGamma]=Perturbation[Homothetic[covd][-i1_Symbol,-i2_Symbol]]:>(-christoffel[i4, -i2, -j1])*per[LI[1], j1, -i1, -i4] + christoffel[i4, -i1, -j1]*per[LI[1], j1, -i2, -i4] + 
  christoffel[j1, -i2, -i4]*per[LI[1], i4, -i1, -j1] - christoffel[j1, -i1, -i4]*per[LI[1], i4, -i2, -j1] + 
  PD[-i1][per[LI[1], i4, -i2, -i4]] - PD[-i2][per[LI[1], i4, -i1, -i4]];
PertCoRicciCD\[CapitalGamma]=Perturbation[CoRicci[covd][i1_Symbol,-i2_Symbol]]:>(-christoffel[i1, -i4, -j1])*per[LI[1], j1, -i2, i4] + christoffel[i1, -i2, -j1]*per[LI[1],j1, -i4, i4] + 
  christoffel[j1, -i4, i4]*per[LI[1], i1, -i2, -j1] - christoffel[j1, -i2, i4]*per[LI[1], i1, -i4, -j1] +  metric[i4, j1]*PD[-i2][per[LI[1], i1, -i4, -j1]]- metric[i4, j1]*PD[-i4][per[LI[1], i1, -i2, -j1]];
PertRicciScalar\[CapitalGamma]=Perturbation[RicciScalar[covd][]]:>metric[i1, i2]*((-christoffel[i4, -i3, -i2])*per[LI[1], i3, -i1, -i4] + christoffel[i4, -i1, -i2]*per[LI[1], i3, -i3, -i4] + 
   christoffel[i3, -i3, -i4]*per[LI[1], i4, -i1, -i2] - christoffel[i3, -i1, -i4]*per[LI[1], i4, -i3, -i2] - 
   PD[-i1][per[LI[1], i3, -i3, -i2]] + PD[-i3][per[LI[1],i3, -i1, -i2]]);
PertWeyl\[CapitalGamma]=Perturbation[weyl[-a1_Symbol,-a2_Symbol,-a3_Symbol,a4_Symbol]]:>TracelessProjector[4,1,metric,{i1,i2,i3,-i4,-a1,-a2,-a3,a4}]*(christoffel[i4, -i2, -j1]*per[LI[1], j1, -i1, -i3] -christoffel[i4, -i1, -j1]*per[LI[1], j1, -i2, -i3] - christoffel[j1, -i2, -i3]*per[LI[1], i4, -i1, -j1] + christoffel[j1, -i1, -i3]*per[LI[1], i4, -i2, -j1] - PD[-i1][per[LI[1], i4, -i2, -i3]] + PD[-i2][per[LI[1], i4, -i1, -i3]]);
(*We can now define a total variation (w.r.t.to connection) as follows.Note that we're only varying the connection and hence set variations of any other tensors to zero.*)
VarDt[christoffel,expr_]:=Module[{mod},mod=Expand[Perturbation[SeparateMetric[NoScalar[expr]]]]//.PertRiemannCD\[CapitalGamma]//.PertRicciCD\[CapitalGamma]//.PertHomotheticCD\[CapitalGamma]//.PertCoRicciCD\[CapitalGamma]//.PertRicciScalar\[CapitalGamma]//.PertWeyl\[CapitalGamma];
ExpandPerturbation@SameDummies@mod/. {per[LI[1],inds___]:>var[inds],p:(tensor_[LI[1],___])/;(xTensorQ[tensor]&&tensor=!=per&&PerturbationOrder[p]===1)->0}];
(*The functional derivation is then defined as...*)
VarD[christoffel[inds___],cd][expr_]:=Module[{mod,withvar,novar},mod=Expand@VarDt[christoffel,expr];
novar=mod/. var[__]->0;
withvar=mod-novar;
ToCanonical[ContractMetric[BreakChristoffel[VarD[var[inds],cd][withvar],cd]]/.CurvatureRelations[covd]]
];
(*And finally one handy function that varies Lagrangians,and thus takes care of the square root of the determinant.*)VarL[christoffel[inds___]][L_]:=VarL[christoffel[inds],cd][L];
VarL[christoffel[inds___],cd][L_]:=VarD[christoffel[inds],cd][L];
]
];


(* ::Input::Initialization:: *)
TorsionToDistortion::def="`1` has no torsion.";


(* ::Input::Initialization:: *)
NonMetricityToDistortion::def="`1` is compatible with the metric `2`.";


(* ::Input::Initialization:: *)
HomotheticToRiemann[expr_,PD]:=expr;
HomotheticToRiemann[exp_,covd_?LeviCivitaQ]:=exp;
HomotheticToRiemann[exp_,covd_?(!NonMetricityQ[#]&)]:=exp;
HomotheticToRiemann[exp_,covd_?NonMetricityQ]:=With[{indices=GetIndicesOfVBundle[First@VBundlesOfCovD@covd,2]},With[{i1=First@indices,i2=Last@indices},exp/.{Homothetic[covd][c_,d_]:>Module[{e=DummyIn@First@VBundlesOfCovD@covd},$RiemannSign*Riemann[covd][d,c,-e,e]]}]];
HomotheticToRiemann[expr_]:=Fold[HomotheticToRiemann,expr,$CovDs];


(* ::Input::Initialization:: *)
CoRicciToRiemann[expr_,PD]:=expr;
CoRicciToRiemann[exp_,covd_?LeviCivitaQ]:=exp;
CoRicciToRiemann[exp_,covd_?(!NonMetricityQ[#]&)]:=exp;
CoRicciToRiemann[exp_,covd_?NonMetricityQ]:=With[{indices=GetIndicesOfVBundle[First@VBundlesOfCovD@covd,2]},With[{i1=First@indices,i2=Last@indices},exp/.{CoRicci[covd][c_,d_]:>Module[{e=DummyIn@First@VBundlesOfCovD@covd},-$RicciSign*Riemann[covd][c,-e,e,d]]}]];
CoRicciToRiemann[expr_]:=Fold[CoRicciToRiemann,expr,$CovDs];


(* ::Input::Initialization:: *)
ToRiemann[expr_,covd_?CovDQ/;NonMetricityQ[covd]]:=Composition[If[!CurvatureRelationsQ[covd],
Composition[RicciToRiemann[#,covd]&,CoRicciToRiemann[#,covd]&,HomotheticToRiemann[#,covd]&],Identity],WeylToRiemann[#,covd]&][expr];


(* ::Input::Initialization:: *)
ToRiemann[expr_,cd_?CovDQ/;!NonMetricityQ[cd]]:=Composition[If[!CurvatureRelationsQ[cd],Composition[RicciToRiemann[#,cd]&,ToRicci[#,cd]&],Identity],KretschmannToRiemann[#,cd]&,WeylToRiemann[#,cd]&,SymRiemannToRiemann[#,cd]&,RiemannDownToRiemann[#,cd]&,GradChristoffelToRiemann[#,cd]&][expr];


(* ::Input::Initialization:: *)
BreakDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,vb=VBundleOfMetric[metric],indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],res,crQ=ConnectionRelationsQ[covd]},
With[{i1= indices[[1]],
		i2= indices[[2]],
	i3= indices[[3]],
	distortion=GiveSymbol[Distortion,covd],
	nonmetricity=GiveSymbol[NonMetricity,covd],
		torsion=GiveSymbol[Torsion,covd]
	},
If[crQ,ClearConnectionRelations[covd,Verbose->False]];
	rule=MakeRule[{distortion[i1,-i2,-i3],(1/2)*nonmetricity[i1, -i2, -i3] - (1/2)*nonmetricity[-i2, i1, -i3] 
	- (1/2)*nonmetricity[-i3, i1, -i2] +  (1/2)*torsion[i1, -i2, -i3] + (1/2)*torsion[-i2, i1, -i3] + (1/2)*torsion[-i3, i1, -i2]}];
	res=exp/.(Flatten@(InverseMakeRule/@ConnectionRelations[covd]))/.rule;
If[crQ,SetConnectionRelations[covd,Verbose->False]]
	];
res
]


(* ::Input::Initialization:: *)
BreakContorsion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],res,crQ=ConnectionRelationsQ[covd]},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	torsion=GiveSymbol[Torsion,covd],
	contorsion= GiveSymbol[Contorsion,covd]
	},
If[crQ,ClearConnectionRelations[covd,Verbose->False]];
	rule=MakeRule[{contorsion[a,-b,-c],1/2*torsion[a,-b,-c]+1/2torsion[-b,a,-c]+1/2*torsion[-c,a,-b]}];
	res=exp/.(Flatten@(InverseMakeRule/@ConnectionRelations[covd]))/.rule;
If[crQ,SetConnectionRelations[covd,Verbose->False]]
	];
res
]


(* ::Input::Initialization:: *)
BreakDisformation[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],res,crQ=ConnectionRelationsQ[covd]},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	nonmetricity=GiveSymbol[NonMetricity,covd],
	disformation= GiveSymbol[Disformation,covd]
	},
If[crQ,ClearConnectionRelations[covd,Verbose->False]];
	rule=MakeRule[{disformation[a,-b,-c],1/2*nonmetricity[a,-b,-c]-1/2*nonmetricity[-b,a,-c]-1/2*nonmetricity[-c,a,-b]}];
	res=exp/.(Flatten@(InverseMakeRule/@ConnectionRelations[covd]))/.rule;
If[crQ,SetConnectionRelations[covd,Verbose->False]]
	];
res
]


(* ::Input::Initialization:: *)
DisformationToDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],
nmQ=NonMetricityQ[covd,metric],
torsionQ=TorsionQ[covd]},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	distortion=GiveSymbol[Distortion,covd],
	disformation= GiveSymbol[Disformation,covd]
	},
	If[nmQ, 
	rule=ToRule[disformation[a,-b,-c]==(1/2)*distortion[a, -b, -c] + (1/2)*distortion[a, -c, -b] - (1/2)*distortion[-b, a, -c] 
+ (1/2)*distortion[-b, -c, a] - (1/2)*distortion[-c, a, -b] + (1/2)*distortion[-c, -b, a]];
	];
exp/.rule
]
]


(* ::Input::Initialization:: *)
ContorsionToDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],
nmQ=NonMetricityQ[covd,metric],
torsionQ=TorsionQ[covd]},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	distortion=GiveSymbol[Distortion,covd],
	contorsion= GiveSymbol[Contorsion,covd]
	},
If[torsionQ, rule=ToRule[contorsion[a,-b,-c]==(1/2)*distortion[a, -b, -c] - (1/2)*distortion[a, -c, -b] + (1/2)*distortion[-b, a, -c] - (1/2)*distortion[-b, -c, a] + (1/2)*distortion[-c, a, -b] -  (1/2)*distortion[-c, -b, a]];
];
exp/.rule
]
]


(* ::Input::Initialization:: *)
NonMetricityToDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,vb=VBundleOfMetric[metric],indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],
nmQ=NonMetricityQ[covd,metric],torsionQ=TorsionQ[covd]},
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	nonmetricity=GiveSymbol[NonMetricity,covd],
	disformation=GiveSymbol[Disformation,covd],
	distortion= GiveSymbol[Distortion,covd]
	},
	If[!nmQ,Message[NonMetricityToDistortion::def,covd,metric]];
	If[nmQ&&torsionQ,
	rule=ToRule[nonmetricity[-a, -b, -c] == -distortion[-b, -a, -c] - distortion[-c, -a, -b]];
	];
	If[nmQ&&!torsionQ,
	rule=ToRule[nonmetricity[-a, -b, -c] == -disformation[-b, -a, -c] - disformation[-c, -a, -b]];
	];
	Return[exp/.rule,Module]
	]
]


(* ::Input::Initialization:: *)
NonMetricityToDisformation[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	nonmetricity=GiveSymbol[NonMetricity,covd],
	disformation= GiveSymbol[Disformation,covd]
	},
	rule=ToRule[nonmetricity[-a, -b, -c] == -disformation[-b, -a, -c] - disformation[-c, -a, -b]];
	exp/.rule
	]
]


(* ::Input::Initialization:: *)
TorsionToDistortion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3],
nmQ=NonMetricityQ[covd,metric],
torsionQ=TorsionQ[covd],rule
},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	torsion=GiveSymbol[Torsion,covd],
	distortion= GiveSymbol[Distortion,covd],
	contorsion=GiveSymbol[Contorsion,covd]
	},
	If[!torsionQ,rule={}];
	If[nmQ&&torsionQ,
	rule=ToRule[torsion[a,-b,-c]==2Antisymmetrize[distortion[a,-b,-c],{-b,-c}]];
	];
	If[!nmQ&&torsionQ,
	rule=ToRule[torsion[a,-b,-c]==2Antisymmetrize[contorsion[a,-b,-c],{-b,-c}]];
	];
Return[exp/.rule,Module]
]
]


(* ::Input::Initialization:: *)
TorsionToContorsion[exp_,covd_?CovDQ,metric_?MetricQ]:=Module[
{rule,
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 3]
},
With[{a= indices[[1]],
		b= indices[[2]],
	c= indices[[3]],
	torsion=GiveSymbol[Torsion,covd],
	contorsion= GiveSymbol[Contorsion,covd]
	},
		rule=ToRule[torsion[a,-b,-c]==2Antisymmetrize[contorsion[a,-b,-c],{-b,-c}]];
		exp/.rule
	]
]


(* ::Input::Initialization:: *)
BreakDistortion[exp_,PD,_Symbol]:=exp;
BreakDistortion[exp_,covd_Symbol?LeviCivitaQ]:=exp;
BreakDistortion[exp_,covd_Symbol?(TorsionQ[#]&&NonMetricityQ[#]&)]:=BreakDistortion[exp,covd,MasterOf[covd]];
BreakDistortion[exp_,covd_Symbol?(!TorsionQ[#]&&NonMetricityQ[#]&)]:=BreakDisformation[exp,covd];
BreakDistortion[exp_,covd_Symbol?(TorsionQ[#]&&!NonMetricityQ[#]&)]:=BreakContorsion[exp,covd];
BreakDistortion[exp_]:=BreakDistortion[exp,$CovDs];
BreakDistortion[expr_,list_List]:=Fold[BreakDistortion,expr,list];

BreakDisformation[exp_,PD,_Symbol]:=exp;
BreakDisformation[exp_,covd_Symbol?LeviCivitaQ]:=exp;
BreakDisformation[exp_,covd_Symbol?(!NonMetricityQ[#]&)]:=exp;
BreakDisformation[exp_,covd_Symbol?(NonMetricityQ[#]&)]:=BreakDisformation[exp,covd,MasterOf[covd]];
BreakDisformation[exp_]:=BreakDisformation[exp,$CovDs];
BreakDisformation[expr_,list_List]:=Fold[BreakDisformation,expr,list];

BreakContorsion[exp_,PD,_Symbol]:=exp;
BreakContorsion[exp_,covd_Symbol?(!TorsionQ[#]&)]:=exp;
BreakContorsion[exp_,covd_Symbol?(TorsionQ[#]&)]:=BreakContorsion[exp,covd,MasterOf[covd]];
BreakContorsion[expr_,list_List]:=Fold[BreakContorsion,expr,list];
BreakContorsion[exp_]:=BreakContorsion[exp,$CovDs];

DisformationToDistortion[exp_,covd_]:=DisformationToDistortion[exp,covd,MasterOf[covd]];
DisformationToDistortion[exp_]:=DisformationToDistortion[exp,$CovDs];
ToDistortion[expr_,list_List]:=Fold[ToDistortion,expr,list];
ToDistortion[exp_,PD,_Symbol]:=exp;
ToDistortion[exp_,covd_?LeviCivitaQ]:=exp;

ContorsionToDistortion[exp_,covd_]:=ContorsionToDistortion[exp,covd,MasterOf[covd]];
ContorsionToDistortion[exp_]:=ContorsionToDistortion[exp,$CovDs];
ContorsionToDistortion[expr_,list_List]:=Fold[ContorsionToDistortion,expr,list];
ContorsionToDistortion[exp_,PD,_Symbol]:=exp;
ContorsionToDistortion[exp_,covd_?LeviCivitaQ]:=exp;

NonMetricityToDistortion[exp_,covd_]:=NonMetricityToDistortion[exp,covd,MasterOf[covd]];
NonMetricityToDistortion[exp_]:=NonMetricityToDistortion[exp,$CovDs];
NonMetricityToDistortion[expr_,list_List]:=Fold[NonMetricityToDistortion,expr,list];
NonMetricityToDistortion[exp_,PD,_Symbol]:=exp;
NonMetricityToDistortion[exp_,covd_?LeviCivitaQ]:=exp;

NonMetricityToDisformation[exp_,covd_]:=NonMetricityToDisformation[exp,covd,MasterOf[covd]];
NonMetricityToDisformation[exp_]:=NonMetricityToDisformation[exp,$CovDs];
NonMetricityToDisformation[expr_,list_List]:=Fold[NonMetricityToDisformation,expr,list];
NonMetricityToDisformation[exp_,PD,_Symbol]:=exp;
NonMetricityToDisformation[exp_,covd_?LeviCivitaQ]:=exp;

TorsionToDistortion[exp_,covd_]:=TorsionToDistortion[exp,covd,MasterOf[covd]];
TorsionToDistortion[exp_]:=TorsionToDistortion[exp,$CovDs];
TorsionToDistortion[expr_,list_List]:=Fold[TorsionToDistortion,expr,list];
TorsionToDistortion[exp_,PD,_Symbol]:=exp;
TorsionToDistortion[exp_,covd_?LeviCivitaQ]:=exp;

TorsionToContorsion[exp_,covd_]:=TorsionToContorsion[exp,covd,MasterOf[covd]];
TorsionToContorsion[exp_]:=TorsionToContorsion[exp,$CovDs];
TorsionToContorsion[expr_,list_List]:=Fold[TorsionToContorsion,expr,list];
TorsionToContorsion[exp_,PD,_Symbol]:=exp;
TorsionToContorsion[exp_,covd_?LeviCivitaQ]:=exp;


(* ::Input::Initialization:: *)
Options[ToDistortion]:={Verbose->True}
ToDistortion[exp_,covd_?CovDQ,metric_?MetricQ,Options:OptionsPattern[]]:=Module[
{indices = GetIndicesOfVBundle[VBundleOfMetric[metric],3],covdmetric=CovDOfMetric[metric],
nmQ=NonMetricityQ[covd,metric],torsionQ=TorsionQ[covd],res,verbose,curvQ=CurvatureRelationsQ[covd],conQ=ConnectionRelationsQ[covd]},
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	torsion=GiveSymbol[Torsion,covd],
	contorsion= GiveSymbol[Contorsion,covd]
	},
{verbose}=OptionValue[{Verbose}];
If[!MAGChristoffelQ[covd,metric],MAGChristoffelTensorStart[covd,metric,Verbose->verbose]];
If[conQ,ClearConnectionRelations[covd,Verbose->False];ConnectionRelationsQ[covd]=False];
If[curvQ,ClearCurvatureRelations[covd,Verbose->False],CurvatureRelationsQ[covd]=False];
If[nmQ&&torsionQ,	res=DisformationToDistortion[ContorsionToDistortion[TorsionToDistortion[NonMetricityToDistortion[ChangeCovD[ChangeCurvature[ToRiemann[WeylToRiemann[exp,covd],covd],covd,covdmetric],covd,covdmetric],covd,metric],covd,metric],covd,metric],covd,metric]
];
If[!nmQ&&torsionQ,
res=NoScalar[TorsionToDistortion[ChangeCovD[ChangeCurvature[ToRiemann[exp,covd],covd,covdmetric],covd,covdmetric],covd,metric]]
];
If[nmQ&&!torsionQ,
res=NonMetricityToDistortion[ChangeCovD[ChangeCurvature[ToRiemann[exp,covd],covd,covdmetric],covd,covdmetric],covd,metric]
];
If[curvQ,SetCurvatureRelations[covd,Verbose->False];CurvatureRelationsQ[covd]=True];
If[conQ,SetConnectionRelations[covd,Verbose->False];ConnectionRelationsQ[covd]=True];
Return[res,Module]
]
]


(* ::Input::Initialization:: *)
ToDistortion[exp_,covd_?CovDQ]:=If[(!xTensorQ[GiveSymbol[Contorsion,covd]]&&!xTensorQ[GiveSymbol[Disformation,covd]]),exp,ToDistortion[exp,covd,MasterOf[covd]]];
ToDistortion[exp_]:=ToDistortion[exp,$CovDs];
ToDistortion[expr_,list_List]:=Fold[ToDistortion,expr,list];
ToDistortion[exp_,PD,_Symbol]:=exp;


(* ::Input::Initialization:: *)
ToContorsion[exp_,covd_?(NonMetricityQ[#]&&TorsionQ[#]&),metric_?MetricQ]:=Module[
{indices = GetIndicesOfVBundle[VBundleOfMetric[metric],3],rule},
If[!xTensorQ[GiveSymbol[Distortion,covd]],Return[exp,Module]];
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	distortion=GiveSymbol[Distortion,covd],
	disformation=GiveSymbol[Disformation,covd],
	contorsion= GiveSymbol[Contorsion,covd]
	},
rule=MakeRule[{distortion[a,-b,-c],contorsion[a,-b,-c]+disformation[a,-b,-c]}];
exp/.rule]];
ToContorsion[exp_,covd_?CovDQ,metric_?MetricQ]:=If[(MetricOfCovD[covd]=!=Null&&!TorsionQ[covd])||(MetricOfCovD[covd]===Null&&(!xTensorQ[GiveSymbol[Contorsion,covd]]||!xTensorQ[GiveSymbol[Disformation,covd]]))||!TorsionQ[covd],exp,If[TorsionQ[covd]&&!NonMetricityQ[covd],ToDistortion[exp,covd,metric]]];
ToContorsion[exp_,covd_?CovDQ]:=If[MasterOf[covd]=!=Null,ToContorsion[exp,covd,MasterOf[covd]],exp];
ToContorsion[exp_]:=ToContorsion[exp,$CovDs];
ToContorsion[expr_,list_List]:=Fold[ToContorsion,expr,list];
ToContorsion[exp_,PD,_Symbol]:=exp;


(* ::Input::Initialization:: *)
ToDisformation[exp_,covd_?(NonMetricityQ[#]&&TorsionQ[#]&),metric_?MetricQ]:=ToContorsion[exp,covd,metric];
ToDisformation[exp_,covd_?CovDQ,metric_?MetricQ]:=If[(MetricOfCovD[covd]=!=Null)||(MetricOfCovD[covd]===Null&&!xTensorQ[GiveSymbol[Disformation,covd]]),exp,If[!TorsionQ[covd]&&NonMetricityQ[covd],ToDistortion[exp,covd,metric]]];
ToDisformation[exp_,covd_?CovDQ]:=If[MasterOf[covd]=!=Null,ToDisformation[exp,covd,MasterOf[covd]],exp];
ToDisformation[exp_]:=ToDisformation[exp,$CovDs];
ToDisformation[expr_,list_List]:=Fold[ToDisformation,expr,list];
ToDisformation[exp_,PD,_Symbol]:=exp;


(* ::Input::Initialization:: *)
Options[StartInducedDecomposition]:={PrintAs->{"n","h"},SpaceLikeQ->True,Normalization->-1,InducedConnectionRelations->True,InducedCurvatureRelations->True,InducedProjectiveRelations->False}
StartInducedDecomposition[metric_?MetricQ,covd_?CovDQ,symofcovds_List,{normalvector_Symbol,indmet_Symbol},Options:OptionsPattern[]]:=Module[{M=Sequence@@DependenciesOfTensor[metric],indices = GetIndicesOfVBundle[VBundleOfMetric[metric],4],indcovd=GiveSymbol[CovDOfMetric[metric],indmet],signdet,printas,slq,symbolindcovd=symofcovds[[1]],symbolcovd=symofcovds[[2]],norm,curvrQ,connectionrQ,projectiveQ},
With[{i1= indices[[1]],i2= indices[[2]],i3= indices[[3]],i4= indices[[4]],acc=GiveSymbol[Acceleration,normalvector],covdmet=CovDOfMetric[metric],extrinsicmet=GiveSymbol[ExtrinsicK,indmet],vb=VBundleOfMetric[metric]},
(********** options ***************)
{printas,slq,norm,connectionrQ,curvrQ,projectiveQ}=OptionValue[{PrintAs,SpaceLikeQ,Normalization,InducedConnectionRelations,InducedCurvatureRelations,InducedProjectiveRelations}];
(*** To DO : sign of norm and SpaceLikeQ ???? ***)
(******* Normal Vector and normalization *********)
DefTensor[normalvector[-i1],M];
AutomaticRules[normalvector,MakeRule[{normalvector[i1]normalvector[-i1],norm}]];
AutomaticRules[normalvector,MakeRule[{metric[-i1,-i2]normalvector[i1]normalvector[i2],norm}]];
(****** Sign convention for Extrinsic curvature and Acceleration ***)
$ExtrinsicKSign=-1;$AccelerationSign=-1;PrintAsCharacter[Extrinsic]="\[CapitalKappa]";PrintAsCharacter[Acceleration]="a";
(******************** Definition of the induced metric and related function **************)
If[slq,signdet=1,signdet=-1];
DefMetric[signdet,indmet[-i1,-i2],indcovd,symbolindcovd,InducedFrom->{metric,normalvector},PrintAs->printas[[2]],WeightedWithBasis->AIndex];
indcovd[a_]@(f_?ScalarFunctionQ[args___]):=xAct`xTensor`Private`multiD[indcovd[a],f[args]];
ToFunction[acc[-i2]==normalvector[i1]covdmet[-i1]@normalvector[-i2],AccelerationToGradNormal,MetricOn->All];
PrintAs[extrinsicmet]^=xMAGPrint[Extrinsic,indmet];
(** Automatic Rule for the commutation of induced covariant derivative acting on the acceleration vector **)
AutomaticRules[acc,{indcovd[-b_Symbol][acc[-a_Symbol]]:>indcovd[-a][acc[-b]]/;DisorderedPairQ[-a,-b]}];
AutomaticRules[acc,{indcovd[b_Symbol][acc[a_Symbol]]:>indcovd[a][acc[b]]/;DisorderedPairQ[a,b]}];
AutomaticRules[acc,{indcovd[-b_Symbol][acc[a_Symbol]]:>indcovd[a][acc[-b]]/;DisorderedPairQ[a,-b]}];
AutomaticRules[acc,{indcovd[b_Symbol][acc[-a_Symbol]]:>indcovd[-a][acc[b]]/;DisorderedPairQ[-a,b]}];
(*** Correction of a small bug related to Projector and the function IsIndexOf : Maybe there is a better solution involving a modification of IsIndexOf.. ? ***)
With[{projname=Projector[indmet]},
projname[normalvector[i_]*(expr_.)]=.;
projname[normalvector[i_?AIndexQ]expr_.]:=0/;Not@IsIndexOf[expr,ChangeIndex[i],indmet];
projname[normalvector[i_?(EIndexQ&&Depth[#]>2&)]expr_.]:=0/;Not@IsIndexOf[expr,ChangeIndex[ToExpression[ToString[Evaluate[i[[1,1]]]]<>ToString[Blank[]]]],indmet];
(*** Automatic rule for LieD ***)
Unprotect[LieD];
LieD/:normalvector[-i_Symbol]LieD[normalvector[_Symbol]][expr_]:=-acc[-i]*expr/;xAct`xTensor`Private`HasOrthogonalIndexQ[expr,normalvector[-i]];
Protect[LieD];
With[{riemannh=GiveSymbol[Riemann,indcovd]},
SlotsOfTensor[riemannh]^={-Tangent[M],-Tangent[M],-Tangent[M],Tangent[M]};
]
(*** Automatic rules for curvature tensors ***)
With[{riemann=GiveSymbol[Riemann,covdmet],ricci=GiveSymbol[Ricci,covdmet],ricciscalar=GiveSymbol[RicciScalar,covdmet]},
AutomaticRules[riemann,MakeRule[{normalvector[i1]*normalvector[i2]*riemann[-i1, -i2, -i3, i4],0}]]
];
(*******************************************************************************************)
(*** Definition and rules for the projected curvature tensors associated with the metric ***)
(*******************************************************************************************)
defCurvatureInducedComp[covdmet,indmet];
covdmet/:InducedCurvatureRelations[covdmet,indmet,Projector]=RiemannToInducedrules[covdmet,indmet];
covdmet/:InducedCurvatureRelations[covdmet,indmet,Gauss]=Gaussrule[covdmet,indmet];
covdmet/:InducedCurvatureRelations[covdmet,indmet,Codazzi]=Codazzirules[covdmet,indmet];
covdmet/:InducedCurvatureRelations[covdmet,indmet,Mainardi]=Mainardirules[covdmet,indmet];
If[curvrQ,SetInducedCurvatureRelations[covdmet,indmet]];
RiemannDecompositionRules[covdmet]=curvaturedecompositionrules[covdmet,indmet];
ToInducedCurvatureRules[covdmet,Riemann]=toInducedCurvatureRules[covdmet,indmet,Riemann];
ToInducedCurvatureRules[covdmet,Ricci]=toInducedCurvatureRules[covdmet,indmet,Ricci];
ToInducedCurvatureRules[covdmet,RicciScalar]=toInducedCurvatureRules[covdmet,indmet,RicciScalar];
(****************************************************************)
(*** Induced decomposition of the independent connection covd ***)
(****************************************************************)
If[!SameQ[covd,CovDOfMetric[metric]],
With[{indcovD=GiveSymbol[covd,indmet],torsionQ=TorsionQ[covd],nonmetricityQ=NonMetricityQ[covd,metric],distortion=GiveSymbol[Distortion,covd],disformation=GiveSymbol[Disformation,covd],contorsion=GiveSymbol[Contorsion,covd]},
(*** Definition of induced covariant derivative associated with covd ***)
DefCovD[indcovD[-i1],SymbolOfCovD->symbolcovd,Torsion->torsionQ,FromMetric->MetricOfCovD[covd],OrthogonalTo->{normalvector[i1]},ProjectedWith->{indmet[i1,-i2]},Master->indmet];
ProjectDerivativeRules[indcovD]={indcovD[i_][expr_]:>If[IsIndexOf[expr,-i],
With[{dummy=DummyAs[i]},metric[i,-dummy]projname[covd[dummy][expr]]],
projname[covd[i][expr]]
]};
(*** Definition of projected connection tensors associated with covd ***)
defCovDInducedDecomposition[covd,indmet];
(*** Rules ***)
covd/:InducedConnectionRelations[covd,indmet,Projector]=distortionToInducedrules[covd,indmet];
covd/:InducedConnectionRelations[covd,indmet,Extrinsic]=distortionInducedToExtrinsicrules[covd,indmet];
covd/:InducedConnectionRelations[covd,indmet,Acceleration]=distortionInducedToAcceleration[covd,indmet];
If[connectionrQ,
SetInducedConnectionRelations[covd,indmet]
];
If[torsionQ&& nonmetricityQ,
DistortionDecompositionRules[covd]=MakeRule[{distortion[i1,-i2,-i3],Evaluate[SafeCanonical[InducedDecomposition[distortion[i1,-i2,-i3],{indmet,normalvector}]]/.InducedConnectionRelations[covd,indmet,Projector]]}]
];
If[!torsionQ&& nonmetricityQ,
DistortionDecompositionRules[covd]=MakeRule[{disformation[i1,-i2,-i3],Evaluate[SafeCanonical[InducedDecomposition[disformation[i1,-i2,-i3],{indmet,normalvector}]]/.InducedConnectionRelations[covd,indmet,Projector]]}]
];
If[torsionQ&&!nonmetricityQ,
DistortionDecompositionRules[covd]=MakeRule[{contorsion[i1,-i2,-i3],Evaluate[SafeCanonical[InducedDecomposition[contorsion[i1,-i2,-i3],{indmet,normalvector}]]]}]
];
(*** Definition of projected curvature tensors associated with covd ***)
defCurvatureInducedComp[covd,indmet];
If[nonmetricityQ&&!torsionQ,
covd/:InducedCurvatureRelations[covd,indmet,Projector]=RiemannToInducedrules[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Gauss]=Gaussrule[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Codazzi]=Codazzirules[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Mainardi]=Mainardirules[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Affine]=Affinerules[covd,indmet];
If[curvrQ,SetInducedCurvatureRelations[covd,indmet]];
RiemannDecompositionRules[covd]=curvaturedecompositionrules[covd,indmet];
ToInducedCurvatureRules[covd,Riemann]=toInducedCurvatureRules[covd,indmet,Riemann];
ToInducedCurvatureRules[covd,Ricci]=toInducedCurvatureRules[covd,indmet,Ricci];
ToInducedCurvatureRules[covd,CoRicci]=toInducedCurvatureRules[covd,indmet,CoRicci];
ToInducedCurvatureRules[covd,RicciScalar]=toInducedCurvatureRules[covd,indmet,RicciScalar];
];
If[!nonmetricityQ&&torsionQ,
covd/:InducedCurvatureRelations[covd,indmet,Projector]=RiemannToInducedrules[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Gauss]=Gaussrule[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Codazzi]=Codazzirules[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Mainardi]=Mainardirules[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Affine]=Affinerules[covd,indmet];
If[curvrQ,SetInducedCurvatureRelations[covd,indmet]];
RiemannDecompositionRules[covd]=curvaturedecompositionrules[covd,indmet];
ToInducedCurvatureRules[covd,Riemann]=toInducedCurvatureRules[covd,indmet,Riemann];
ToInducedCurvatureRules[covd,Ricci]=toInducedCurvatureRules[covd,indmet,Ricci];
ToInducedCurvatureRules[covd,RicciScalar]=toInducedCurvatureRules[covd,indmet,RicciScalar];
];
If[nonmetricityQ&&torsionQ,
covd/:InducedCurvatureRelations[covd,indmet,Projector]=RiemannToInducedrules[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Gauss]=Gaussrule[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Codazzi]=Codazzirules[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Mainardi]=Mainardirules[covd,indmet];
covd/:InducedCurvatureRelations[covd,indmet,Affine]=Affinerules[covd,indmet];
If[curvrQ,SetInducedCurvatureRelations[covd,indmet]];
RiemannDecompositionRules[covd]=curvaturedecompositionrules[covd,indmet];
ToInducedCurvatureRules[covd,Riemann]=toInducedCurvatureRules[covd,indmet,Riemann];
ToInducedCurvatureRules[covd,Ricci]=toInducedCurvatureRules[covd,indmet,Ricci];
ToInducedCurvatureRules[covd,CoRicci]=toInducedCurvatureRules[covd,indmet,CoRicci];
ToInducedCurvatureRules[covd,Homothetic]=toInducedCurvatureRules[covd,indmet,Homothetic];
ToInducedCurvatureRules[covd,RicciScalar]=toInducedCurvatureRules[covd,indmet,RicciScalar];
(***** Projective Invariant variables for the distortion tensor ***)
defProjectiveVariables[covd,indmet];
covd/:InducedProjectiveRelations[covd,indmet]=projectiveVariablesRules[covd,indmet];
If[projectiveQ,SetInducedProjectiveRelations[covd,indmet],covd/:InducedProjectiveRelationsQ[covd,indmet]:=False]
];
]
]
]
]
];
StartInducedDecomposition[metric_?MetricQ,symofcovd_List,{normalvector_Symbol,indmet_Symbol},Options:OptionsPattern[]]:=StartInducedDecomposition[metric,CovDOfMetric[metric],{symofcovd,{}},{normalvector,indmet},Options];


(* ::Input::Initialization:: *)
InducedCurvatureRelationsQ[cd_?CovDQ,indmetric_?InducedMetricQ]:={};


(* ::Input::Initialization:: *)
InducedCurvatureRelations[covd_Symbol?LeviCivitaQ,indmetric_?InducedMetricQ,Affine]:={};
InducedCurvatureRelations[covd_Symbol?CovDQ,indmetric_?InducedMetricQ]:=Join[InducedCurvatureRelations[covd,indmetric,Projector],InducedCurvatureRelations[covd,indmetric,Gauss],InducedCurvatureRelations[covd,indmetric,Codazzi],InducedCurvatureRelations[covd,indmetric,Mainardi],InducedCurvatureRelations[covd,indmetric,Affine]];
CurvaturelationsADM[___]:={};


(* ::Input::Initialization:: *)
ClearInducedCurvatureRelations[cd_?CovDQ,indmetric_?InducedMetricQ,options___?OptionQ]:=(
ClearAutomaticRules[Evaluate[GiveSymbol[Projector,indmetric]],InducedCurvatureRelations[cd,indmetric,Projector],options];
cd/:InducedCurvatureRelationsQ[cd,indmetric]:=False;
);


(* ::Input::Initialization:: *)
SetInducedCurvatureRelations[cd_?CovDQ,indmet_?InducedMetricQ,options___?OptionQ]:=
(AutomaticRules[Evaluate[GiveSymbol[Projector,indmet]],InducedCurvatureRelations[cd,indmet,Projector],options];
cd/:InducedCurvatureRelationsQ[cd,indmet]:=True;
);



(* ::Input::Initialization:: *)
InducedConnectionRelationsQ[cd_?CovDQ,indmetric_?InducedMetricQ]:={};


(* ::Input::Initialization:: *)
InducedConnectionRelations[covd_Symbol?CovDQ,indmetric_?InducedMetricQ]:=Join[InducedConnectionRelations[covd,indmetric,Projector],InducedConnectionRelations[covd,indmetric,Extrinsic],InducedConnectionRelations[covd,indmetric,Acceleration]];
InducedConnectionRelations[___]:={};


(* ::Input::Initialization:: *)
ClearInducedConnectionRelations[cd_?CovDQ,indmetric_?InducedMetricQ,options___?OptionQ]:=(
ClearAutomaticRules[Evaluate[GiveSymbol[Projector,indmetric]],InducedConnectionRelations[cd,indmetric,Projector][[1;;19]],options];
ClearAutomaticRules[Evaluate[GiveSymbol[Distortion,cd]],InducedConnectionRelations[cd,indmetric,Projector][[20;;]],options];
cd/: InducedConnectionRelationsQ[cd,indmetric]:=False;
);


(* ::Input::Initialization:: *)
SetInducedConnectionRelations[cd_?CovDQ,indmet_?InducedMetricQ,options___?OptionQ]:=
(AutomaticRules[Evaluate[GiveSymbol[Projector,indmet]],InducedConnectionRelations[cd,indmet,Projector][[1;;19]],options];
AutomaticRules[Evaluate[GiveSymbol[Distortion,cd]],InducedConnectionRelations[cd,indmet,Projector][[20;;]],options];
cd/: InducedConnectionRelationsQ[cd,indmet]:=True;
);



(* ::Input::Initialization:: *)
InducedProjectiveRelationsQ[cd_?CovDQ,indmetric_?InducedMetricQ]:={};


(* ::Input::Initialization:: *)
InducedProjectiveRelations[___]:={};


(* ::Input::Initialization:: *)
ClearInducedProjectiveRelations[cd_?CovDQ,indmetric_?InducedMetricQ,options___?OptionQ]:=(
ClearAutomaticRules[Evaluate[GiveSymbol[Distortion,cd,indmetric]],InducedProjectiveRelations[cd,indmetric][[1]],options];
ClearAutomaticRules[Evaluate[GiveSymbol[Distortion,cd,indmet,Evaluate[(InducedFrom@indmet)[[2]]]]],InducedProjectiveRelations[cd,indmet][[2]],options];
cd/: InducedProjectiveRelationsQ[cd,indmetric]:=False;
);


(* ::Input::Initialization:: *)
SetInducedProjectiveRelations[cd_?CovDQ,indmet_?InducedMetricQ,options___?OptionQ]:=
(AutomaticRules[Evaluate[GiveSymbol[Distortion,cd,indmet]],InducedProjectiveRelations[cd,indmet][[1]],options];
AutomaticRules[Evaluate[GiveSymbol[Distortion,cd,indmet,Evaluate[(InducedFrom@indmet)[[2]]]]],InducedProjectiveRelations[cd,indmet][[2]],options];
cd/: InducedProjectiveRelationsQ[cd,indmet]:=True;
);



(* ::Input::Initialization:: *)
ProjectDerivativeRules[_]:={};
DistortionDecompositionRules[_]:={};
RiemannDecompositionRules[_]:={};

ToInducedCurvatureRules[_,Riemann]:={};
ToInducedCurvatureRules[_,Ricci]:={};
ToInducedCurvatureRules[_,CoRicci]:={};
ToInducedCurvatureRules[_,Homothetic]:={};
ToInducedCurvatureRules[_,RicciScalar]:={};
ToInducedCurvatureRules[_,Riemann]:={};
ToInducedCurvatureRules[_,Ricci]:={};
ToInducedCurvatureRules[_,CoRicci]:={};
ToInducedCurvatureRules[_,Homothetic]:={};
ToInducedCurvatureRules[_,RicciScalar]:={};
ToInducedCurvatureRules[covd_?NonMetricityQ]:=Join[ToInducedCurvatureRules[covd,Riemann],ToInducedCurvatureRules[covd,Ricci],ToInducedCurvatureRules[covd,CoRicci],ToInducedCurvatureRules[covd,Homothetic],ToInducedCurvatureRules[covd,RicciScalar]];
ToInducedCurvatureRules[covd_?CovDQ]:=Join[ToInducedCurvatureRules[covd,Riemann],ToInducedCurvatureRules[covd,Ricci],ToInducedCurvatureRules[covd,RicciScalar]];
ToInducedCurvatureRules[_]:={};


(* ::Input::Initialization:: *)
deflistablexTensorxMAGCovDs[ProjectDerivative];
xAct`xTensor`Private`deflistableCovDs/@{DistortionDecomposition,RiemannDecomposition,ToInducedCurvature};


(* ::Input::Initialization:: *)
defCurvatureInducedComp[covd_,indmetric_?InducedMetricQ]:=Module[
{metric=Part[InducedFrom[indmetric],1],
nv=Part[InducedFrom[indmetric],2],
vb=VBundleOfMetric[indmetric],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],8],
M=ManifoldOfCovD[covd]
},
With[
{
lvQ=LeviCivitaQ[covd,metric],
torsionQ=TorsionQ[covd],
nonmetricityQ=NonMetricityQ[covd,metric],
i1= indices[[1]],
i2= indices[[2]],
i3= indices[[3]],
i4= indices[[4]],
j1= indices[[5]],
j2= indices[[6]],
j3= indices[[7]],
j4= indices[[8]],
tm=TangentBundleOfManifold[M]
},
If[lvQ,
With[{
Rhhhh=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,indmetric],
Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv]
},
Set[CovDTensorQ[#],True]&/@{Rhhhh,Rhhhn,Rhnhn};
PrintAsCharacter[Rhhhh]=xMAGPrint[Riemann,indmetric];
PrintAsCharacter[Rhhhn]=xMAGPrint[N,indmetric];
PrintAsCharacter[Rhnhn]=xMAGPrint[O,indmetric];
DefTensor[Rhhhh[-i1,-i2,-i3,i4],M,RiemannSymmetric[{1,2,3,4}],ForceSymmetries->True,OrthogonalTo->{nv[i1],nv[i2],nv[i3],nv[-i4]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3],indmetric[-i4,j4]},PrintAs->GiveOutputString[Rhhhh,covd]];
DefTensor[Rhhhn[-i1,-i2,-i3],M,Antisymmetric[{-i1,-i2}],OrthogonalTo->{nv[i1],nv[i2],nv[i3]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3]},PrintAs->GiveOutputString[Rhhhn,covd]];
DefTensor[Rhnhn[-i1,-i2],M,Symmetric[{-i1,-i2}],OrthogonalTo->{nv[i1],nv[i2]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2]},PrintAs->GiveOutputString[Rhnhn,covd]]
]
];
(****** Connection with Non Metricity and no Torsion **********)
If[!torsionQ&&nonmetricityQ,
With[{
Rhhhh=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,indmetric],
Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
Rhhnh=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,indmetric],
Rhnhh=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,indmetric],
Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv],
Rhnnh=GiveSymbol[Riemann,covd,indmetric,nv,nv,indmetric],
Rhhnn=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,nv],
Rhnnn=GiveSymbol[Riemann,covd,indmetric,nv,nv,nv]
},
Set[CovDTensorQ[#],True]&/@{Rhhhh,Rhhhn,Rhhnh,Rhnhh,Rhnhn,Rhnnh,Rhhnn,Rhnnn};
PrintAsCharacter[Rhhhh]=xMAGPrint[Riemann,indmetric];
PrintAsCharacter[Rhhhn]=xMAGPrint[N,1];
PrintAsCharacter[Rhhnh]=xMAGPrint[N,3];
PrintAsCharacter[Rhnhh]=xMAGPrint[N,2];
PrintAsCharacter[Rhnhn]=xMAGPrint[O,1];
PrintAsCharacter[Rhnnh]=xMAGPrint[O,3];
PrintAsCharacter[Rhhnn]=xMAGPrint[O,2];
PrintAsCharacter[Rhnnn]="A";
DefTensor[Rhhhh[-i1,-i2,-i3,i4],M,Antisymmetric[{1,2}],ForceSymmetries->True,OrthogonalTo->{nv[i1],nv[i2],nv[i3],nv[-i4]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3],indmetric[-i4,j4]},PrintAs->GiveOutputString[Rhhhh,covd]];
DefTensor[Rhhhn[-i1,-i2,-i3],M,Antisymmetric[{-i1,-i2}],OrthogonalTo->{nv[i1],nv[i2],nv[i3]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3]},PrintAs->GiveOutputString[Rhhhn,covd]];
DefTensor[Rhhnh[-i1,-i2,-i3],M,Antisymmetric[{-i1,-i2}],OrthogonalTo->{nv[i1],nv[i2],nv[i3]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3]},PrintAs->GiveOutputString[Rhhnh,covd]];
DefTensor[Rhnhh[-i1,-i2,-i3],M,OrthogonalTo->{nv[i1],nv[i2],nv[i3]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3]},PrintAs->GiveOutputString[Rhnhh,covd]];
DefTensor[Rhnhn[-i1,-i2],M,OrthogonalTo->{nv[i1],nv[i2]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2]},PrintAs->GiveOutputString[Rhnhn,covd]];
DefTensor[Rhnnh[-i1,i2],M,OrthogonalTo->{nv[i1],nv[-i2]},ProjectedWith->{indmetric[i1,-j1],indmetric[-i2,j2]},PrintAs->GiveOutputString[Rhnnh,covd]];
DefTensor[Rhhnn[-i1,-i2],M,OrthogonalTo->{nv[i1],nv[i2]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2]},PrintAs->GiveOutputString[Rhhnn,covd]];
DefTensor[Rhnnn[-i1],M,OrthogonalTo->{nv[i1]},ProjectedWith->{indmetric[i1,-j1]},PrintAs->GiveOutputString[Rhnnn,covd]]
]
];

(****** Connection with Torsion and no non-metricity **********)
If[torsionQ&&!nonmetricityQ,
With[{
Rhhhh=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,indmetric],
Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
Rhnhh=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,indmetric],
Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv]
},
Set[CovDTensorQ[#],True]&/@{Rhhhh,Rhhhn,Rhhnh,Rhnhh,Rhnhn,Rhnnh,Rhhnn,Rhnnn};
PrintAsCharacter[Rhhhh]=xMAGPrint[Riemann,indmetric];
PrintAsCharacter[Rhhhn]=xMAGPrint[N,1];
PrintAsCharacter[Rhnhh]=xMAGPrint[N,2];
PrintAsCharacter[Rhnhn]=xMAGPrint[O,indmetric];
DefTensor[Rhhhh[-i1,-i2,-i3,i4],M,Antisymmetric[{1,2}],ForceSymmetries->True,OrthogonalTo->{nv[i1],nv[i2],nv[i3],nv[-i4]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3],indmetric[-i4,j4]},PrintAs->GiveOutputString[Rhhhh,covd]];
DefTensor[Rhhhn[-i1,-i2,-i3],M,Antisymmetric[{-i1,-i2}],OrthogonalTo->{nv[i1],nv[i2],nv[i3]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3]},PrintAs->GiveOutputString[Rhhhn,covd]];
DefTensor[Rhnhh[-i1,-i2,-i3],M,OrthogonalTo->{nv[i1],nv[i2],nv[i3]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3]},PrintAs->GiveOutputString[Rhnhh,covd]];
DefTensor[Rhnhn[-i1,-i2],M,OrthogonalTo->{nv[i1],nv[i2]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2]},PrintAs->GiveOutputString[Rhnhn,covd]]
]
];

(****** Connection with Non Metricity and Torsion **********)
If[torsionQ&&nonmetricityQ,
With[{
Rhhhh=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,indmetric],
Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
Rhhnh=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,indmetric],
Rhnhh=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,indmetric],
Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv],
Rhnnh=GiveSymbol[Riemann,covd,indmetric,nv,nv,indmetric],
Rhhnn=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,nv],
Rhnnn=GiveSymbol[Riemann,covd,indmetric,nv,nv,nv]
},
Set[CovDTensorQ[#],True]&/@{Rhhhh,Rhhhn,Rhhnh,Rhnhh,Rhnhn,Rhnnh,Rhhnn,Rhnnn};
PrintAsCharacter[Rhhhh]=xMAGPrint[Riemann,indmetric];
PrintAsCharacter[Rhhhn]=xMAGPrint[N,1];
PrintAsCharacter[Rhhnh]=xMAGPrint[N,3];
PrintAsCharacter[Rhnhh]=xMAGPrint[N,2];
PrintAsCharacter[Rhnhn]=xMAGPrint[O,1];
PrintAsCharacter[Rhnnh]=xMAGPrint[O,3];
PrintAsCharacter[Rhhnn]=xMAGPrint[O,2];
PrintAsCharacter[Rhnnn]="A";
DefTensor[Rhhhh[-i1,-i2,-i3,i4],M,Antisymmetric[{1,2}],ForceSymmetries->True,OrthogonalTo->{nv[i1],nv[i2],nv[i3],nv[-i4]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3],indmetric[-i4,j4]},PrintAs->GiveOutputString[Rhhhh,covd]];
DefTensor[Rhhhn[-i1,-i2,-i3],M,Antisymmetric[{-i1,-i2}],OrthogonalTo->{nv[i1],nv[i2],nv[i3]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3]},PrintAs->GiveOutputString[Rhhhn,covd]];
DefTensor[Rhhnh[-i1,-i2,-i3],M,Antisymmetric[{-i1,-i2}],OrthogonalTo->{nv[i1],nv[i2],nv[i3]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3]},PrintAs->GiveOutputString[Rhhnh,covd]];
DefTensor[Rhnhh[-i1,-i2,-i3],M,OrthogonalTo->{nv[i1],nv[i2],nv[i3]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2],indmetric[i3,-j3]},PrintAs->GiveOutputString[Rhnhh,covd]];
DefTensor[Rhnhn[-i1,-i2],M,OrthogonalTo->{nv[i1],nv[i2]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2]},PrintAs->GiveOutputString[Rhnhn,covd]];
DefTensor[Rhnnh[-i1,i2],M,OrthogonalTo->{nv[i1],nv[-i2]},ProjectedWith->{indmetric[i1,-j1],indmetric[-i2,j2]},PrintAs->GiveOutputString[Rhnnh,covd]];
DefTensor[Rhhnn[-i1,-i2],M,OrthogonalTo->{nv[i1],nv[i2]},ProjectedWith->{indmetric[i1,-j1],indmetric[i2,-j2]},PrintAs->GiveOutputString[Rhhnn,covd]];
DefTensor[Rhnnn[-i1],M,OrthogonalTo->{nv[i1]},ProjectedWith->{indmetric[i1,-j1]},PrintAs->GiveOutputString[Rhnnn,covd]]
]
]
]
];


(* ::Input::Initialization:: *)
defCovDInducedDecomposition[covd_?CovDQ,indmetric_?InducedMetricQ,options:OptionsPattern[]]:=Module[{rulesdistortion,rulesextrinsic,rulesacceleration,cradm},
(*** Options ***)
{cradm}=OptionValue[{StartInducedDecomposition},{options},{InducedConnectionRelations}];
(*** Definitions ***)
defDistortionInducedComp[covd,indmetric];
defMAGExtrinsicTensors[covd,indmetric];
defMAGAccelerationTensors[covd,indmetric];
(**** PrePrint to avoid error messages associated to ScreenDollarIndices***)
(*$PrePrint=.;
Print["** $Preprint changed from ScreenDollarIndices to Null"]*)
];


(* ::Input::Initialization:: *)
defDistortionInducedComp[covd_,indmetric_?InducedMetricQ]:=Module[
{metric=Part[InducedFrom[indmetric],1],
nv=Part[InducedFrom[indmetric],2],
vb=VBundleOfMetric[indmetric],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],6],
M=ManifoldOfCovD[covd]
},
With[
{torsionQ=TorsionQ[covd],
nonmetricityQ=NonMetricityQ[covd,metric],
a= indices[[1]],
b= indices[[2]],
c= indices[[3]],
d= indices[[4]],
i= indices[[5]],
j= indices[[6]],
tm=TangentBundleOfManifold[M]
},
(****** Connection with Non Metricity and zero Torsion **********)
If[nonmetricityQ && !torsionQ,
With[{
Dnhh=GiveSymbol[Disformation,covd,nv,indmetric,indmetric],
Dhnh=GiveSymbol[Disformation,covd,indmetric,nv,indmetric],
Dnhn=GiveSymbol[Disformation,covd,nv,indmetric,nv],
Dhnn=GiveSymbol[Disformation,covd,indmetric,nv,nv],
Dnnn=GiveSymbol[Disformation,covd,nv,nv,nv],
disformation=GiveSymbol[Disformation,covd]
},
DefTensor[Dnhh[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Disformation,1]];
DefTensor[Dhnh[a,-b],M,OrthogonalTo->{nv[-a],nv[b]},ProjectedWith->{indmetric[-a,d],indmetric[b,-i]},PrintAs->xMAGPrint[Disformation,2]];
DefTensor[Dhnn[a],M,OrthogonalTo->{nv[-a]},ProjectedWith->{indmetric[-a,d]},PrintAs->xMAGPrint[Disformation,1]];
DefTensor[Dnhn[-a],M,OrthogonalTo->{nv[a]},ProjectedWith->{indmetric[a,-d]},PrintAs->xMAGPrint[Disformation,2]];
DefTensor[Dnnn[],M,PrintAs->xMAGPrint[Disformation,Null,nv]];
]];


(****** Connection with Torsion and zero Non Metricity **********)

If[torsionQ&&!nonmetricityQ,
With[{
Knhh=GiveSymbol[Contorsion,covd,nv,indmetric,indmetric],
Khnh=GiveSymbol[Contorsion,covd,indmetric,nv,indmetric],
Khnn=GiveSymbol[Contorsion,covd,indmetric,nv,nv],
contorsion=GiveSymbol[Contorsion,covd]
},
DefTensor[Knhh[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Contorsion,1]];
DefTensor[Khnh[a,-b],M,OrthogonalTo->{nv[-a],nv[b]},ProjectedWith->{indmetric[-a,d],indmetric[b,-i]},PrintAs->xMAGPrint[Contorsion,2]];
DefTensor[Khnn[-a],M,OrthogonalTo->{nv[a]},ProjectedWith->{indmetric[a,-d]},PrintAs->xMAGPrint[Contorsion,2]];
]];

(****** Connection with Non Metricity and Torsion **********)
If[torsionQ&&nonmetricityQ,
With[{
Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
Chnh=GiveSymbol[Distortion,covd,indmetric,nv,indmetric],
Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric],
Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
Cnhn=GiveSymbol[Distortion,covd,nv,indmetric,nv],
Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv],
distortion=GiveSymbol[Distortion,covd]
},
DefTensor[Cnhh[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Distortion,1]];
DefTensor[Chnh[a,-b],M,OrthogonalTo->{nv[-a],nv[b]},ProjectedWith->{indmetric[-a,d],indmetric[b,-i]},PrintAs->xMAGPrint[Distortion,2]];
DefTensor[Chhn[a,-b],M,OrthogonalTo->{nv[-a],nv[b]},ProjectedWith->{indmetric[-a,d],indmetric[b,-i]},PrintAs->xMAGPrint[Distortion,3]];
DefTensor[Chnn[a],M,OrthogonalTo->{nv[-a]},ProjectedWith->{indmetric[-a,d]},PrintAs->xMAGPrint[Distortion,1]];
DefTensor[Cnhn[-a],M,OrthogonalTo->{nv[a]},ProjectedWith->{indmetric[a,-d]},PrintAs->xMAGPrint[Distortion,2]];
DefTensor[Cnnh[-a],M,OrthogonalTo->{nv[a]},ProjectedWith->{indmetric[a,-d]},PrintAs->xMAGPrint[Distortion,3]];
DefTensor[Cnnn[],M,PrintAs->xMAGPrint[Distortion,Null,nv]];
]]
]
];


(* ::Input::Initialization:: *)
defMAGExtrinsicTensors[covd_,indmetric_?InducedMetricQ]:=Module[
{metric=Part[InducedFrom[indmetric],1],
vb=VBundleOfMetric[indmetric],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],4],
M=ManifoldOfCovD[covd]
},
With[{torsionQ=TorsionQ[covd],
	nonmetricityQ=NonMetricityQ[covd,metric],
	a= indices[[1]],
	b= indices[[2]],
	d= indices[[3]],
	i= indices[[4]],
	nv=Part[InducedFrom[indmetric],2]
	},

	(****** Connection with Non Metricity and  zero Torsion **********)
	If[nonmetricityQ&&!torsionQ,
	With[{extrinsic1=GiveSymbol[Extrinsic,1,covd],
	extrinsic2=GiveSymbol[Extrinsic,2,covd]},
	DefTensor[extrinsic1[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Extrinsic,1]];
	DefTensor[extrinsic2[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Extrinsic,2]]
	]];

	(****** Connection with Torsion and zero Non metricity **********)
	If[!nonmetricityQ&&torsionQ,
	With[{extrinsic1=GiveSymbol[Extrinsic,1,covd]},
	DefTensor[extrinsic1[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Extrinsic,1]];
	]
	];

	(****** Connection with Non Metricity and Torsion **********)
	If[nonmetricityQ&&torsionQ,
	With[{extrinsic1=GiveSymbol[Extrinsic,1,covd],
	extrinsic3=GiveSymbol[Extrinsic,3,covd]},
	DefTensor[extrinsic1[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Extrinsic,1]];
	DefTensor[extrinsic3[-a,-b],M,OrthogonalTo->{nv[a],nv[b]},ProjectedWith->{indmetric[a,-d],indmetric[b,-i]},PrintAs->xMAGPrint[Extrinsic,3]]
	]]
]
]


(* ::Input::Initialization:: *)
defMAGExtrinsicTensors[covd_]:=DefMAGExtrinsicTensors[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
defMAGExtrinsicTensors[]:=DefMAGExtrinsicTensors[Part[$CovDs,3]]


(* ::Input::Initialization:: *)
defMAGAccelerationTensors[covd_,indmetric_?InducedMetricQ]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
M=ManifoldOfCovD[covd],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],2]
},
With[{
	nv=Part[InducedFrom[indmetric],2],
	a= indices[[1]],
	b= indices[[2]]
	},
(****** Connection with Non Metricity and zero Torsion **********)
	If[nonmetQ&&!torsionQ,
	With[{acceleration1=GiveSymbol[Acceleration,"1",covd],
	acceleration3=GiveSymbol[Acceleration,"2",covd],
	acceleration1h=GiveSymbol[Acceleration,"1",covd,indmetric],
	acceleration3h=GiveSymbol[Acceleration,"2",covd,indmetric],
	accelerationcovdn=GiveSymbol[Acceleration,covd,nv]},

	DefTensor[acceleration1[a],M,PrintAs->xMAGPrint[Acceleration,1]];
	DefTensor[acceleration3[a],M,PrintAs->xMAGPrint[Acceleration,2]];
	DefTensor[acceleration1h[a],M,OrthogonalTo->{nv[-a]},ProjectedWith->{indmetric[-a,b]},PrintAs->xMAGPrint[Acceleration,1,indmetric]];
	DefTensor[acceleration3h[a],M,OrthogonalTo->{nv[-a]},ProjectedWith->{indmetric[-a,b]},PrintAs->xMAGPrint[Acceleration,2,indmetric]];
	DefTensor[accelerationcovdn[],M,PrintAs->xMAGPrint[Acceleration,Null,nv]]
	]
	];

(****** Connection with Torsion and zero Non metricity **********)
	If[!nonmetQ&&torsionQ,
	With[{acceleration1=GiveSymbol[Acceleration,1,covd],
	acceleration1h=GiveSymbol[Acceleration,1,covd,indmetric],
	accelerationcovdn=GiveSymbol[Acceleration,1,covd,nv]},
	DefTensor[acceleration1[a],M,PrintAs->xMAGPrint[Acceleration,1]];
	DefTensor[acceleration1h[a],M,OrthogonalTo->{nv[-a]},ProjectedWith->{indmetric[-a,b]},PrintAs->xMAGPrint[Acceleration,1]];
	DefTensor[accelerationcovdn[],M,PrintAs->xMAGPrint[Acceleration,Null,nv]]
	]
	];


(****** Connection with Non Metricity and Torsion **********)
	If[nonmetQ&&torsionQ,
	With[{
	acceleration1=GiveSymbol[Acceleration,"1",covd],
	acceleration3=GiveSymbol[Acceleration,"3",covd],
	acceleration1h=GiveSymbol[Acceleration,"1",covd,indmetric],
	acceleration3h=GiveSymbol[Acceleration,"3",covd,indmetric],
	accelerationcovdn=GiveSymbol[Acceleration,covd,nv]},

	DefTensor[acceleration1[a],M,PrintAs->xMAGPrint[Acceleration,1]];
	DefTensor[acceleration3[a],M,PrintAs->xMAGPrint[Acceleration,3]];
	DefTensor[acceleration1h[a],M,OrthogonalTo->{nv[-a]},ProjectedWith->{indmetric[-a,b]},PrintAs->xMAGPrint[Acceleration,1,indmetric]];
	DefTensor[acceleration3h[a],M,OrthogonalTo->{nv[-a]},ProjectedWith->{indmetric[-a,b]},PrintAs->xMAGPrint[Acceleration,3,indmetric]];
	DefTensor[accelerationcovdn[],M,PrintAs->xMAGPrint[Acceleration,Null,nv]]
	]
	];
]
]
defMAGAccelerationTensors[covd_]:=defMAGAccelerationTensors[covd,Part[MetricsOfVBundle[Part[VBundlesOfCovD[covd],1]],2]]
defMAGAccelerationTensors[]:=defMAGAccelerationTensors[Part[$CovDs,3]]


(* ::Input::Initialization:: *)
defProjectiveVariables[covd_?CovDQ/;(NonMetricityQ[covd]&&TorsionQ[covd]),indmetric_?InducedMetricQ]:=Module[{indices = GetIndicesOfVBundle[First@VBundlesOfCovD@covd,6],metric=InducedFrom[indmetric][[1]],normalvector=InducedFrom[indmetric][[2]],M=ManifoldOfCovD[covd],rule},
With[{distortionPI3=GiveSymbol[Distortion,covd,indmetric,"PI"],
distortionPI2=GiveSymbol[Distortion,covd,indmetric,normalvector,indmetric,"PI"],
Chnh=GiveSymbol[Distortion,covd,indmetric,normalvector,indmetric],
Ch=GiveSymbol[Distortion,covd,indmetric],
Cnhn=GiveSymbol[Distortion,covd,normalvector,indmetric,normalvector],
acc=GiveSymbol[Acceleration,covd,normalvector],
i1= indices[[1]],
i2= indices[[2]],
i3= indices[[3]],
j1= indices[[4]],
j2= indices[[5]],
j3= indices[[6]]
},
If[!xTensorQ[distortionPI3],
DefTensor[distortionPI3[i1,-i2,-i3],M,OrthogonalTo->{normalvector[-i1],normalvector[i2],normalvector[i3]},ProjectedWith->{indmetric[-i1,j1],indmetric[i2,-j2],indmetric[i3,-j3]},PrintAs->xMAGPrint[Distortion,ToExpression["PI"]]];
DefTensor[distortionPI2[i1,-i2],M,OrthogonalTo->{normalvector[-i1],normalvector[i2]},ProjectedWith->{indmetric[-i1,j1],indmetric[i2,-j2]},PrintAs->xMAGPrint[Distortion,ToExpression["PI"]]];
];
]
]


(* ::Input::Initialization:: *)
RiemannToInducedrules[covd_,indmetric_]:=Module[
	{metric=Part[InducedFrom[indmetric],1],
	vb=VBundleOfMetric[indmetric],
	indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],4],
	M=ManifoldOfCovD[covd],
	rule,
	met=InducedFrom[indmetric][[1]]
	},

With[{nv=InducedFrom[indmetric][[2]],
	torsionQ=TorsionQ[covd],
	nonmetricityQ=NonMetricityQ[covd,metric],
	i1= indices[[1]],
	i2= indices[[2]],
	i3= indices[[3]],
	i4= indices[[4]],
	riemann=GiveSymbol[Riemann,covd],
	projind=GiveSymbol[Projector,indmetric],
	vbQ=VBundleIndexQ[vb],
	lvQ=LeviCivitaQ[covd,met]
	},

								(* Levi Civita connection *)
	If[lvQ,
	With[{
	Rhhhh=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,indmetric],
	Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
	Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv]
	},
	rule=Join[
MakeRule[{projind[riemann[i1,i2,i3,i4]],Rhhhh[i1,i2,i3,i4]}],MakeRule[{projind[nv[-i4]riemann[i1,i2,i3,i4]],Rhhhn[i1 ,i2,i3]}],MakeRule[{projind[nv[-i2]*nv[-i4]*riemann[i1,i2,i3,i4]],Rhnhn[i1,i3]}]]
	]];
											(* Non metricity, zero torsion *)
	If[!torsionQ&&nonmetricityQ,
	With[{
	Rhhhh=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,indmetric],
	Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
	Rhhnh=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,indmetric],
	Rhnhh=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,indmetric],
	Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv],
	Rhnnh=GiveSymbol[Riemann,covd,indmetric,nv,nv,indmetric],
	Rhhnn=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,nv],
	Rhnnn=GiveSymbol[Riemann,covd,indmetric,nv,nv,nv]
	},
	rule=Join[
MakeRule[{projind[riemann[i1,i2,i3,i4]],Rhhhh[i1,i2,i3,i4]}],MakeRule[{projind[nv[-i4]riemann[i1,i2,i3,i4]],Rhhhn[i1 ,i2,i3]}],
MakeRule[{projind[nv[-i3]riemann[i1,i2,i3,i4]],Rhhnh[i1 ,i2,i4]}],
MakeRule[{projind[nv[-i2]riemann[i1,i2,i3,i4]],Rhnhh[i1 ,i3,i4]}],MakeRule[{projind[nv[-i2]*nv[-i4]*riemann[i1,i2,i3,i4]],Rhnhn[i1,i3]}],
MakeRule[{projind[nv[-i2]*nv[-i3]*riemann[i1,i2,i3,i4]],Rhnnh[i1,i4]}],
MakeRule[{projind[nv[-i3]*nv[-i4]*riemann[i1,i2,i3,i4]],Rhhnn[i1,i2]}],
MakeRule[{projind[nv[-i2]*nv[-i3]*nv[-i4]*riemann[i1,i2,i3,i4]],Rhnnn[i1]}]]
	]];
							(* Torsion, zero non-metricity *)
	If[torsionQ&&!nonmetricityQ,
	With[{
	Rhhhh=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,indmetric],
	Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
	Rhnhh=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,indmetric],
	Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv]
	},
	rule=Join[
MakeRule[{projind[riemann[i1,i2,i3,i4]],Rhhhh[i1,i2,i3,i4]}],MakeRule[{projind[nv[-i4]riemann[i1,i2,i3,i4]],Rhhhn[i1 ,i2,i3]}],
MakeRule[{projind[nv[-i3]riemann[i1,i2,i3,i4]],-Rhhhn[i1 ,i2,i4]}],
MakeRule[{projind[nv[-i2]riemann[i1,i2,i3,i4]],Rhnhh[i1 ,i3,i4]}],MakeRule[{projind[nv[-i2]*nv[-i4]*riemann[i1,i2,i3,i4]],Rhnhn[i1,i3]}],
MakeRule[{projind[nv[-i2]*nv[-i3]*riemann[i1,i2,i3,i4]],-Rhnhn[i1,i4]}]]
	]];
											(* General case *)
	If[torsionQ&&nonmetricityQ,
	With[{
	Rhhhh=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,indmetric],
	Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
	Rhhnh=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,indmetric],
	Rhnhh=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,indmetric],
	Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv],
	Rhnnh=GiveSymbol[Riemann,covd,indmetric,nv,nv,indmetric],
	Rhhnn=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,nv],
	Rhnnn=GiveSymbol[Riemann,covd,indmetric,nv,nv,nv]
	},
	rule=Join[
MakeRule[{projind[riemann[i1,i2,i3,i4]],Rhhhh[i1,i2,i3,i4]}],MakeRule[{projind[nv[-i4]riemann[i1,i2,i3,i4]],Rhhhn[i1 ,i2,i3]}],
MakeRule[{projind[nv[-i3]riemann[i1,i2,i3,i4]],Rhhnh[i1 ,i2,i4]}],
MakeRule[{projind[nv[-i2]riemann[i1,i2,i3,i4]],Rhnhh[i1 ,i3,i4]}],MakeRule[{projind[nv[-i2]*nv[-i4]*riemann[i1,i2,i3,i4]],Rhnhn[i1,i3]}],
MakeRule[{projind[nv[-i2]*nv[-i3]*riemann[i1,i2,i3,i4]],Rhnnh[i1,i4]}],
MakeRule[{projind[nv[-i3]*nv[-i4]*riemann[i1,i2,i3,i4]],Rhhnn[i1,i2]}],
MakeRule[{projind[nv[-i2]*nv[-i3]*nv[-i4]*riemann[i1,i2,i3,i4]],Rhnnn[i1]}]]
	]
	]
	];
Return[rule,Module]
]


(* ::Input::Initialization:: *)
curvaturedecompositionrules[covd_,indmetric_]:=Module[
	{metric=Part[InducedFrom[indmetric],1],
	vb=VBundleOfMetric[indmetric],
	indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],4],
	M=ManifoldOfCovD[covd],
	rule,
	met=InducedFrom[indmetric][[1]]
	},

With[{nv=InducedFrom[indmetric][[2]],
	torsionQ=TorsionQ[covd],
	nonmetricityQ=NonMetricityQ[covd,metric],
	i1= indices[[1]],
	i2= indices[[2]],
	i3= indices[[3]],
	i4= indices[[4]],
	riemann=GiveSymbol[Riemann,covd],
	lvQ=LeviCivitaQ[covd,met]
	},
								(* Levi Civita connection *)
	If[lvQ,
	If[!InducedCurvatureRelationsQ[covd,indmetric],SetInducedCurvatureRelations[covd,indmetric]];
	rule=MakeRule[{riemann[-i1,-i2,-i3,i4],Evaluate[InducedDecomposition[riemann[-i1,-i2,-i3,i4],{indmetric,nv}]//SafeCanonical]}]];
											(* General case *)
	If[torsionQ||nonmetricityQ,
	If[!InducedCurvatureRelationsQ[covd,indmetric],SetInducedCurvatureRelations[covd,indmetric]];
	rule=MakeRule[{riemann[-i1,-i2,-i3,i4],Evaluate[InducedDecomposition[riemann[-i1,-i2,-i3,i4],{indmetric,nv}]//SafeCanonical]}]
	]
	];
Return[rule,Module]
]


(* ::Input::Initialization:: *)
toInducedCurvatureRules[covd_,indmet_,curvature_Symbol]:=With[{curv=GiveSymbol[curvature,covd],sot=SlotsOfTensor[GiveSymbol[curvature,covd]],vb=VBundleOfMetric[indmet],curvQ=CurvatureRelationsQ[covd]},
Module[{inds =MapThread[#1/.#2&,{sot,Map[vb->#&,GetIndicesOfVBundle[VBundleOfMetric[indmet],Length[sot]]]}],
	metric=Part[InducedFrom[indmet],1],rule,met=InducedFrom[indmet][[1]]
	},
With[{nv=InducedFrom[indmet][[2]],tens=curv@@inds},
If[curvQ,ClearCurvatureRelations[covd,Verbose->False]];
rule=MakeRule[{tens,Evaluate[RiemannDecomposition[ToRiemann[tens,covd],covd]/.InducedCurvatureRelations[covd,indmet]//NoScalar//SeparateMetric//SafeCanonical//ContractMetric//SafeCanonical]}];
SetCurvatureRelations[covd,Verbose->False];
Return[rule,Module]
]
]
]


(* ::Input::Initialization:: *)
Gaussrule[covd_,indmetric_]:=Module[
	{metric=Part[InducedFrom[indmetric],1],
	vb=VBundleOfMetric[indmetric],
	indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],7],
	M=ManifoldOfCovD[covd],
	rule,
	met=InducedFrom[indmetric][[1]]
	},
With[{nv=InducedFrom[indmetric][[2]],
	torsionQ=TorsionQ[covd],
	(*curvrQ=InducedCurvatureRelationsQ[covd,indmetric],*)
	nonmetricityQ=NonMetricityQ[covd,metric],
	i1= indices[[1]],
	i2= indices[[2]],
	i3= indices[[3]],
	i4= indices[[4]],
	riemann=GiveSymbol[Riemann,covd],
	projind=GiveSymbol[Projector,indmetric],
	vbQ=VBundleIndexQ[vb],
	covdmet=CovDOfMetric[met],
	covdmetind=CovDOfMetric[indmetric],
	covdind=GiveSymbol[covd,indmetric],
	lvQ=LeviCivitaQ[covd,met]
	},
	With[{
	Rhhhh=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,indmetric]
	},
If[lvQ,
rule=MakeRule[{Rhhhh[i1,i2,i3,i4],Evaluate[(GaussCodazzi[projind[riemann[i1,i2,i3,i4]],indmetric])/.projind->ProjectWith[indmetric]//SameDummies//ContractMetric//SafeCanonical]}]
	];
											(* General case *)
If[torsionQ||nonmetricityQ,
MAGChristoffelTensorStart[covdind,indmetric,Verbose->False];
rule=MakeRule[{Rhhhh[-i1,-i2,-i3,i4],Evaluate[GaussCodazzi[ToInducedDerivative[GradNormalToExtrinsicK[DistortionDecomposition[ToDistortion[(projind[riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,met,Verbose->False],covd],indmetric],covdmet,covdmetind],indmetric]//MetricToProjector//ContractMetric//SafeCanonical//SafeCanonical]}]
]
]
];
Return[rule,Module]
]


(* ::Input::Initialization:: *)
Codazzirules[covd_,indmetric_]:=Module[
	{metric=Part[InducedFrom[indmetric],1],
	vb=VBundleOfMetric[indmetric],
	indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],7],
	M=ManifoldOfCovD[covd],
	rule,
	met=InducedFrom[indmetric][[1]]
	},

With[{nv=InducedFrom[indmetric][[2]],
	torsionQ=TorsionQ[covd],
	nonmetricityQ=NonMetricityQ[covd,metric],
	(*curvrQ=InducedCurvatureRelationsQ[covd,indmetric],*)
	i1= indices[[1]],
	i2= indices[[2]],
	i3= indices[[3]],
	i4= indices[[4]],
	riemann=GiveSymbol[Riemann,covd],
	projind=GiveSymbol[Projector,indmetric],
	vbQ=VBundleIndexQ[vb],
	covdmet=CovDOfMetric[met],
	covdmetind=CovDOfMetric[indmetric],
	covdind=GiveSymbol[covd,indmetric],
	lvQ=LeviCivitaQ[covd,met]
	},
If[lvQ,
With[{
	Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv]},
rule=MakeRule[{Rhhhn[-i1,-i2,-i3],Evaluate[(GaussCodazzi[projind[nv[-i4]riemann[-i1,-i2,-i3,i4]],indmetric])/.projind->ProjectWith[indmetric]//ContractMetric//SafeCanonical]}]
]
];

											(* Non metricity, zero torsion *)
If[!torsionQ&&nonmetricityQ,
	With[{
	Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
	Rhhnh=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,indmetric],
	Rhnhh=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,indmetric]
	},
rule=Join[MakeRule[{Rhhnh[-i1,-i2,i4],Evaluate[GaussCodazzi[ToInducedDerivative[GradNormalToExtrinsicK[DistortionDecomposition[ToDistortion[(projind[nv[i3]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd],indmetric]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind],indmetric]//ContractMetric//SafeCanonical]}],
MakeRule[{Rhhhn[-i1,-i2,-i3],Evaluate[GaussCodazzi[ToInducedDerivative[GradNormalToExtrinsicK[DistortionDecomposition[ToDistortion[(projind[nv[-i4]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd],indmetric]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind],indmetric]//ContractMetric//SafeCanonical]}],
MakeRule[{Rhnhh[-i1,-i3,i4],Evaluate[GaussCodazzi[GradNormalToExtrinsicK[ToInducedDerivative[DistortionDecomposition[ToDistortion[(projind[nv[i2]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd]//MetricToProjector//SafeCanonical,covdmet,covdmetind],indmetric],indmetric]//ContractMetric//SafeCanonical]}]
	]
	]
];
							(* Torsion, zero non-metricity *)
If[torsionQ&&!nonmetricityQ,
	With[{
	Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
	Rhnhh=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,indmetric]
	},
	rule=Join[
MakeRule[{Rhhhn[-i1,-i2,-i3],Evaluate[GaussCodazzi[ToInducedDerivative[GradNormalToExtrinsicK[DistortionDecomposition[ToDistortion[(projind[nv[-i4]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd],indmetric]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind],indmetric]//ContractMetric//SafeCanonical]}],
MakeRule[{Rhnhh[-i1,-i3,i4],Evaluate[GaussCodazzi[GradNormalToExtrinsicK[ToInducedDerivative[DistortionDecomposition[ToDistortion[(projind[nv[i2]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd]//MetricToProjector//SafeCanonical,covdmet,covdmetind],indmetric],indmetric]//ContractMetric//SafeCanonical]}]
	]
	]
];
											(* General case *)
If[torsionQ&&nonmetricityQ,
With[{
	Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
	Rhhnh=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,indmetric],
	Rhnhh=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,indmetric]
	},	rule=Join[MakeRule[{Rhhnh[-i1,-i2,i4],Evaluate[GaussCodazzi[ToInducedDerivative[GradNormalToExtrinsicK[DistortionDecomposition[ToDistortion[(projind[nv[i3]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd],indmetric]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind],indmetric]//ContractMetric//SafeCanonical]}],
MakeRule[{Rhhhn[-i1,-i2,-i3],Evaluate[GaussCodazzi[ToInducedDerivative[GradNormalToExtrinsicK[DistortionDecomposition[ToDistortion[(projind[nv[-i4]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd],indmetric]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind],indmetric]//ContractMetric//SafeCanonical]}],
MakeRule[{Rhnhh[-i1,-i3,i4],Evaluate[GaussCodazzi[GradNormalToExtrinsicK[ToInducedDerivative[DistortionDecomposition[ToDistortion[(projind[nv[i2]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd]//MetricToProjector//SafeCanonical,covdmet,covdmetind],indmetric],indmetric]//ContractMetric//SafeCanonical]}]
]
]
]
];
Return[rule,Module]
]


(* ::Input::Initialization:: *)
Mainardirules[covd_,indmetric_]:=Module[
	{metric=Part[InducedFrom[indmetric],1],
	vb=VBundleOfMetric[indmetric],
	indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],4],
	M=ManifoldOfCovD[covd],
	rule,
	met=InducedFrom[indmetric][[1]]
	},

With[{nv=InducedFrom[indmetric][[2]],
	torsionQ=TorsionQ[covd],
	(*curvrQ=InducedCurvatureRelationsQ[covd,indmetric],*)
	nonmetricityQ=NonMetricityQ[covd,metric],
	i1= indices[[1]],
	i2= indices[[2]],
	i3= indices[[3]],
	i4= indices[[4]],
	riemann=GiveSymbol[Riemann,covd],
	projind=GiveSymbol[Projector,indmetric],
	vbQ=VBundleIndexQ[vb],
	covdmet=CovDOfMetric[met],
	covdmetind=CovDOfMetric[indmetric],
	covdind=GiveSymbol[covd,indmetric]
	},

If[LeviCivitaQ[covd,met],
With[{Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv]},rule=MakeRule[{Rhnhn[-i1,-i3],Evaluate[SafeCanonical[ContractMetric[GradNormalToExtrinsicK[ToInducedDerivative[(GaussCodazzi[projind[nv[-i4]nv[i2]riemann[-i1,-i2,-i3,i4]],indmetric])
/.projind->ProjectWith[indmetric],covd,covdmetind],indmetric]]]]}]
]
];
											(*  NonMetricity and zero torsion *)
If[!torsionQ&&nonmetricityQ,
With[{
	Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv],
	Rhnnh=GiveSymbol[Riemann,covd,indmetric,nv,nv,indmetric]
	},rule=Join[MakeRule[{Rhnnh[-i1,-i4],Evaluate[GradNormalToExtrinsicK[ToInducedDerivative[(GaussCodazzi[GradNormalToExtrinsicK[ToInducedDerivative[DistortionDecomposition[ToDistortion[(projind[nv[i2]nv[i3]riemann[-i1,-i2,-i3,-i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind],indmetric],indmetric]//SafeCanonical)/.projind->ProjectWith[indmetric],covdmet,covdmetind],indmetric]//ContractMetric//SafeCanonical]}],MakeRule[{Rhnhn[-i1,-i3],Evaluate[GradNormalToExtrinsicK[ToInducedDerivative[(GaussCodazzi[GradNormalToExtrinsicK[ToInducedDerivative[DistortionDecomposition[ToDistortion[(projind[nv[i2]nv[-i4]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind],indmetric],indmetric]//SafeCanonical)/.projind->ProjectWith[indmetric],covdmet,covdmetind],indmetric]//ContractMetric//SafeCanonical]}]]
	]
	];

						(*  Torsion and zero Non metricity *)
If[torsionQ&&!nonmetricityQ,
With[{
	Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv]
	},rule=Join[MakeRule[{Rhnhn[-i1,-i3],Evaluate[GradNormalToExtrinsicK[ToInducedDerivative[(GaussCodazzi[GradNormalToExtrinsicK[ToInducedDerivative[DistortionDecomposition[ToDistortion[(projind[nv[i2]nv[-i4]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind],indmetric],indmetric]//SafeCanonical)/.projind->ProjectWith[indmetric],covdmet,covdmetind],indmetric]//ContractMetric//SafeCanonical]}]]
	]
	];

											(* General case *)
If[torsionQ&&nonmetricityQ,
With[{
	Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv],
	Rhnnh=GiveSymbol[Riemann,covd,indmetric,nv,nv,indmetric]
	},rule=Join[MakeRule[{Rhnnh[-i1,-i4],Evaluate[GradNormalToExtrinsicK[ToInducedDerivative[(GaussCodazzi[GradNormalToExtrinsicK[ToInducedDerivative[DistortionDecomposition[ToDistortion[(projind[nv[i2]nv[i3]riemann[-i1,-i2,-i3,-i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind],indmetric],indmetric]//SafeCanonical)/.projind->ProjectWith[indmetric],covdmet,covdmetind],indmetric]//ContractMetric//SafeCanonical]}],MakeRule[{Rhnhn[-i1,-i3],Evaluate[GradNormalToExtrinsicK[ToInducedDerivative[(GaussCodazzi[GradNormalToExtrinsicK[ToInducedDerivative[DistortionDecomposition[ToDistortion[(projind[nv[i2]nv[-i4]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind],indmetric],indmetric]//SafeCanonical)/.projind->ProjectWith[indmetric],covdmet,covdmetind],indmetric]//ContractMetric//SafeCanonical]}]]
	]
	]
	];
Return[rule,Module]
]


(* ::Input::Initialization:: *)
Affinerules[covd_,indmetric_]:=Module[
	{metric=Part[InducedFrom[indmetric],1],
	vb=VBundleOfMetric[indmetric],
	indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],4],
	M=ManifoldOfCovD[covd],
	rule={},
	met=InducedFrom[indmetric][[1]]
	},

With[{nv=InducedFrom[indmetric][[2]],
	torsionQ=TorsionQ[covd],
	(*curvrQ=InducedCurvatureRelationsQ[covd,indmetric],*)
	nonmetricityQ=NonMetricityQ[covd,metric],
	i1= indices[[1]],
	i2= indices[[2]],
	i3= indices[[3]],
	i4= indices[[4]],
	riemann=GiveSymbol[Riemann,covd],
	projind=GiveSymbol[Projector,indmetric],
	vbQ=VBundleIndexQ[vb],
	covdmet=CovDOfMetric[met],
	covdmetind=CovDOfMetric[indmetric],
	covdind=GiveSymbol[covd,indmetric]
	},
	With[{
	Rhhnn=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,nv],
	Rhnnn=GiveSymbol[Riemann,covd,indmetric,nv,nv,nv]
	},
											(* General case *)
If[(torsionQ&&nonmetricityQ)||(!torsionQ&&nonmetricityQ),rule=Join[MakeRule[{Rhhnn[-i1,-i2],Evaluate[ToInducedDerivative[GradNormalToExtrinsicK[DistortionDecomposition[ToDistortion[(projind[nv[-i4]nv[i3]riemann[-i1,-i2,-i3,i4]])/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd],indmetric]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind]//ContractMetric//SafeCanonical]}],MakeRule[{Rhnnn[-i1],Evaluate[GradNormalToExtrinsicK[ToInducedDerivative[DistortionDecomposition[ToDistortion[projind[nv[-i4]nv[i3]nv[i2]riemann[-i1,-i2,-i3,i4]]/.projind->ProjectWith[indmetric],covd,metric,Verbose->False],covd]//MetricToProjector//ContractMetric//SafeCanonical,covdmet,covdmetind]//SafeCanonical,indmetric]//ContractMetric//SafeCanonical]}]]
	]
	]
	];
Return[rule,Module]
]


(* ::Input::Initialization:: *)
distortionToInducedrules[covd_,indmetric_]:=Module[
	{metric=Part[InducedFrom[indmetric],1],
	vb=VBundleOfMetric[indmetric],
	indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],3],
	M=ManifoldOfCovD[covd],
	rule
	},

With[{nv=InducedFrom[indmetric][[2]],
	torsionQ=TorsionQ[covd],
	nonmetricityQ=NonMetricityQ[covd,metric],
	i1= indices[[1]],
	i2= indices[[2]],
	i3= indices[[3]],
	projind=GiveSymbol[Projector,indmetric],
	vbQ=VBundleIndexQ[vb]
	},
	(****** Connection with Non Metricity and zero Torsion **********)
	If[!torsionQ&&nonmetricityQ,
	With[{
		Dhhh=GiveSymbol[Disformation,covd,indmetric],
		Dnhh=GiveSymbol[Disformation,covd,nv,indmetric,indmetric],
		Dhnh=GiveSymbol[Disformation,covd,indmetric,nv,indmetric],
		Dnhn=GiveSymbol[Disformation,covd,nv,indmetric,nv],
		Dhnn=GiveSymbol[Disformation,covd,indmetric,nv,nv],
		Dnnn=GiveSymbol[Disformation,covd,nv,nv,nv],
		disformation=GiveSymbol[Disformation,covd]},

	rule=Join[MakeRule[{projind[disformation[i1,i2,i3]],Dhhh[i1,i2,i3]}],MakeRule[{projind[nv[i1]disformation[-i1,i2,i3]],Dnhh[i2 ,i3]}],MakeRule[{projind[nv[i1]*disformation[i2,-i1,i3]],Dhnh[i2,i3]}],MakeRule[{projind[nv[i1]*disformation[i2,i3,-i1]],Dhnh[i2,i3]}],
MakeRule[{projind[nv[i1]*nv[i2]*disformation[-i1,i3,-i2]],Dnhn[i3]}],MakeRule[{projind[nv[i1]*nv[i2]*disformation[-i1,-i2,i3]],Dnhn[i3]}],
MakeRule[{projind[nv[i1]*nv[i2]*disformation[i3,-i2,-i1]],Dhnn[i3]}],
MakeRule[{projind[nv[i1]*nv[i2]*disformation[i3,-i1,-i2]],Dhnn[i3]}],
MakeRule[{disformation[i1, -i2, -i3]*nv[-i1]*nv[i2]*nv[i3], Dnnn[]}]]
	]];
	(****** Connection with Torsion and zero non metricity **********)
	If[torsionQ&&!nonmetricityQ,
	With[{
	Khhh=GiveSymbol[Contorsion,covd,indmetric],
	Knhh=GiveSymbol[Contorsion,covd,nv,indmetric,indmetric],
	Khnh=GiveSymbol[Contorsion,covd,indmetric,nv,indmetric],
	Khnn=GiveSymbol[Contorsion,covd,indmetric,nv,nv],
	contorsion=GiveSymbol[Contorsion,covd]},
	rule=Join[MakeRule[{projind[contorsion[i1,i2,i3]],Khhh[i1,i2,i3]}],MakeRule[{projind[nv[i1]contorsion[-i1,i2,i3]],Knhh[i2 ,i3]}],
MakeRule[{projind[nv[i1]*contorsion[i3,i2,-i1]],-Knhh[i2 ,i3]}],MakeRule[{projind[nv[i1]*contorsion[i2,-i1,i3]],Khnh[i2,i3]}],MakeRule[{projind[nv[i1]*nv[i2]*contorsion[i3,-i1,-i2]],Khnn[i3]}]]
	]];
	(* General case torsion and non metricity *)
	If[torsionQ&&nonmetricityQ,
	With[{distortion=GiveSymbol[Distortion,covd],
		Chhh=GiveSymbol[Distortion,covd,indmetric],
		Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
		Chnh=GiveSymbol[Distortion,covd,indmetric,nv,indmetric],
		Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric],
		Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
		Cnhn=GiveSymbol[Distortion,covd,nv,indmetric,nv],
		Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
		Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv]},

	rule=Join[MakeRule[{projind[distortion[i1,i2,i3]],Chhh[i1,i2,i3]}],MakeRule[{projind[nv[i1]distortion[-i1,i2,i3]],Cnhh[i2 ,i3]}],MakeRule[{projind[nv[i1]*distortion[i2,-i1,i3]],Chnh[i2,i3]}],
MakeRule[{projind[nv[i1]*distortion[i2,i3,-i1]],Chhn[i2,i3]}],MakeRule[{projind[nv[i1]*nv[i2]*distortion[-i1,-i2,i3]],Cnnh[i3]}],
MakeRule[{projind[nv[i1]*nv[i2]*distortion[-i1,i3,-i2]],Cnhn[i3]}],
MakeRule[{projind[nv[i1]*nv[i2]*distortion[i3,-i2,-i1]],Chnn[i3]}],
MakeRule[{distortion[i1, -i2, -i3]*nv[-i1]*nv[i2]*nv[i3], Cnnn[]}]]
	]
]
];
Return[rule,Module]
]


(* ::Input::Initialization:: *)
distortionInducedToExtrinsicrules[covd_,indmetric_]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],2],
autoruleQ=AutomaticDistortionADMToExtrinsicQ[covd,indmetric],
rules
},
With[
{nv=Part[InducedFrom[indmetric],2],
a= indices[[1]],
b= indices[[2]]
},			
	
(****** Connection with Non Metricity and zero Torsion **********)
If[nonmetQ&&!torsionQ,
With[{
	disformation=GiveSymbol[Contorsion,covd],
	extrinsic1=GiveSymbol[Extrinsic,1,covd],
	extrinsic2=GiveSymbol[Extrinsic,2,covd],
	extrinsich=GiveSymbol[ExtrinsicK,indmetric],
	Dhnh=GiveSymbol[Disformation,covd,indmetric,nv,indmetric],
	Dnhh=GiveSymbol[Disformation,covd,nv,indmetric,indmetric]},
	rules=Join[MakeRule[{Dhnh[b, -a],-extrinsic2[-a, b] + extrinsich[-a, b]}],MakeRule[{Dnhh[-a, -b],extrinsic1[-a, -b]-extrinsich[-a, -b]}]];
	]
];
(****** Connection with Torsion and zero non metricity **********)
If[!nonmetQ&&torsionQ,
With[{
	contorsion=GiveSymbol[Contorsion,covd],
	extrinsic1=GiveSymbol[Extrinsic,1,covd],
	extrinsich=GiveSymbol[ExtrinsicK,indmetric],
	Knhh=GiveSymbol[Contorsion,covd,nv,indmetric,indmetric]
	},
	rules=MakeRule[{Knhh[-a, -b],extrinsic1[-a, -b]-extrinsich[-a, -b]}];
	]
];
					(* General case torsion and non metricity *)
If[nonmetQ&&torsionQ,
With[{
	distortion=GiveSymbol[Distortion,covd],
	extrinsic1=GiveSymbol[Extrinsic,1,covd],
	extrinsic3=GiveSymbol[Extrinsic,3,covd],
	extrinsich=GiveSymbol[ExtrinsicK,indmetric],
	Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
	Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric]},

	rules=Join[MakeRule[{Chhn[b, -a],-extrinsic3[-a, b] + extrinsich[-a, b]}],MakeRule[{Cnhh[-a, -b],extrinsic1[-a, -b]-extrinsich[-a, -b]}]];
	]
]
];
Return[rules,Module]
];


(* ::Input::Initialization:: *)
distortionInducedToAcceleration[covd_,indmetric_]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],1],
autoruleQ=AutomaticDistortionADMToAccelerationQ[covd,indmetric],
connectionrQ=InducedConnectionRelationsQ[covd,indmetric],
rules
},
With[{nv=Part[InducedFrom[indmetric],2],
	a= indices[[1]]
	},
(****** Connection with Non Metricity and zero Torsion **********)
If[nonmetQ&&!torsionQ,
With[{
	Dnhn=GiveSymbol[Disformation,covd,nv,indmetric,nv],
	Dhnn=GiveSymbol[Disformation,covd,indmetric,nv,nv],
	Dnnn=GiveSymbol[Disformation,covd,nv,nv,nv],
	acceleration1h=GiveSymbol[Acceleration,"1",covd,indmetric],
	acceleration3h=GiveSymbol[Acceleration,"2",covd,indmetric],
	accelerationcovdn=GiveSymbol[Acceleration,covd,nv],
	accelerationn=GiveSymbol[Acceleration,nv]
		},
		rules=Join[MakeRule[{Dnhn[-a],-acceleration3h[-a]+accelerationn[-a]}],MakeRule[{Dhnn[-a],acceleration1h[-a]-accelerationn[-a]}],MakeRule[{Dnnn[],accelerationcovdn[]}]]
		]
];
(****** Connection with Torsion and zero non metricity **********)
If[!nonmetQ&&torsionQ,
With[{
	Khnn=GiveSymbol[Contorsion,covd,indmetric,nv,nv],
	acceleration1h=GiveSymbol[Acceleration,1,covd,indmetric],
	accelerationcovdn=GiveSymbol[Acceleration,covd,nv],
	accelerationn=GiveSymbol[Acceleration,nv]
	},
		rules=MakeRule[{Khnn[-a],acceleration1h[-a]-accelerationn[-a]}]
	]
];
	(* General case torsion and non metricity *)
If[nonmetQ&&torsionQ,
With[{
	Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
	Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
	Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv],
	acceleration1h=GiveSymbol[Acceleration,"1",covd,indmetric],
	acceleration3h=GiveSymbol[Acceleration,"3",covd,indmetric],
	accelerationcovdn=GiveSymbol[Acceleration,covd,nv],
	accelerationn=GiveSymbol[Acceleration,nv]
		},
		rules=Join[MakeRule[{Cnnh[-a],-acceleration3h[-a]+accelerationn[-a]}],MakeRule[{Chnn[-a],acceleration1h[-a]-accelerationn[-a]}],MakeRule[{Cnnn[],accelerationcovdn[]}]]
		]
]
];
Return[rules,Module]
]


(* ::Input::Initialization:: *)
projectiveVariablesRules[covd_?CovDQ,indmetric_?InducedMetricQ]:=Module[{indices = GetIndicesOfVBundle[First@VBundlesOfCovD@covd,3],metric=InducedFrom[indmetric][[1]],normalvector=InducedFrom[indmetric][[2]],M=ManifoldOfCovD[covd],nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],rule},
With[{distortionPI3=GiveSymbol[Distortion,covd,indmetric,"PI"],
distortionPI2=GiveSymbol[Distortion,covd,indmetric,normalvector,indmetric,"PI"],
Chnh=GiveSymbol[Distortion,covd,indmetric,normalvector,indmetric],
Ch=GiveSymbol[Distortion,covd,indmetric],
Cnhn=GiveSymbol[Distortion,covd,normalvector,indmetric,normalvector],
acc=GiveSymbol[Acceleration,covd,normalvector],
i1= indices[[1]],
i2= indices[[2]],
i3= indices[[3]]
},
If[nonmetQ&&torsionQ,
rule=Join[MakeRule[{Ch[i1,-i2,-i3],distortionPI3[i1,-i2,-i3]-indmetric[i1,-i3]*Cnhn[-i2]}],MakeRule[{Chnh[i1,-i2],distortionPI2[i1,-i2]-indmetric[i1,-i2]*acc[]}]],
rule={}];
Return[rule,Module]
]
]


(* ::Input::Initialization:: *)
ToProjectiveVariables[exp_,covd_?CovDQ/;(!NonMetricityQ[covd]&&TorsionQ[covd]),indmetric_?InducedMetricQ]:=exp;
ToProjectiveVariables[exp_,covd_?CovDQ/;(NonMetricityQ[covd]&&!TorsionQ[covd]),indmetric_?InducedMetricQ]:=exp;
ToProjectiveVariables[exp_,PD,indmetric_?InducedMetricQ]:=exp;
ToProjectiveVariables[exp_,covd_?LeviCivitaQ,indmetric_?InducedMetricQ]:=exp;
ToProjectiveVariables[exp_,covd_?CovDQ]:=ToProjectiveVariables[exp,covd,First@Select[$Metrics,InducedMetricQ]];


(* ::Input::Initialization:: *)
StopInducedDecomposition[covd_,indmetric_]:=Module[{},
undefCurvatureInducedComp[covd,indmetric];
undefDistortionInducedComp[covd,indmetric];
undefMAGExtrinsicTensors[covd,indmetric];
undefMAGAccelerationTensors[covd,indmetric];
undefProjectiveVariables[covd,indmetric];
With[{indcovD=GiveSymbol[covd,indmetric]},
UndefCovD[indcovD];
];
VisitorsOf[indmetric]^={};
UndefMetric[indmetric];
];


(* ::Input::Initialization:: *)
undefCurvatureInducedComp[covd_,indmetric_?InducedMetricQ]:=Module[
{metric=Part[InducedFrom[indmetric],1],
nv=Part[InducedFrom[indmetric],2],
vb=VBundleOfMetric[indmetric],
indices = GetIndicesOfVBundle[VBundleOfMetric[indmetric],8],
M=ManifoldOfCovD[covd]
},
With[
{lvQ=LeviCivitaQ[covd,metric],
torsionQ=TorsionQ[covd],
nonmetricityQ=NonMetricityQ[covd,metric],
i1= indices[[1]],
i2= indices[[2]],
i3= indices[[3]],
i4= indices[[4]],
j1= indices[[5]],
j2= indices[[6]],
j3= indices[[7]],
j4= indices[[8]],
tm=TangentBundleOfManifold[M],
Rhhhh=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,indmetric],
Rhhhn=GiveSymbol[Riemann,covd,indmetric,indmetric,indmetric,nv],
Rhhnh=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,indmetric],
Rhnhh=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,indmetric],
Rhnhn=GiveSymbol[Riemann,covd,indmetric,nv,indmetric,nv],
Rhnnh=GiveSymbol[Riemann,covd,indmetric,nv,nv,indmetric],
Rhhnn=GiveSymbol[Riemann,covd,indmetric,indmetric,nv,nv],
Rhnnn=GiveSymbol[Riemann,covd,indmetric,nv,nv,nv]
},
If[lvQ,
MasterOf[Rhhhh]^={};
MasterOf[Rhhhn]^={};
MasterOf[Rhnhn]^={};
UndefTensor[Rhhhh];
UndefTensor[Rhhhn];
UndefTensor[Rhnhn]
];
If[torsionQ&&nonmetricityQ,
MasterOf[Rhhhh]^={};
MasterOf[Rhhhn]^={};
MasterOf[Rhhnh]^={};
MasterOf[Rhnhh]^={};
MasterOf[Rhnhn]^={};
MasterOf[Rhnnh]^={};
MasterOf[Rhhnn]^={};
MasterOf[Rhnnn]^={};
UndefTensor[Rhhhh];
UndefTensor[Rhhhn];
UndefTensor[Rhhnh];
UndefTensor[Rhnhh];
UndefTensor[Rhnhn];
UndefTensor[Rhnnh];
UndefTensor[Rhhnn];
UndefTensor[Rhnnn]
]
]
];


(* ::Input::Initialization:: *)
undefDistortionInducedComp[covd_,indmetric_]:=Module[
{torsionQ=TorsionQ[covd],
nonmetricityQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
nv=Part[InducedFrom[indmetric],2]
},
With[{
Chhn=GiveSymbol[Distortion,covd,indmetric,indmetric,nv],
Chnh=GiveSymbol[Distortion,covd,indmetric,nv,indmetric],
Cnhh=GiveSymbol[Distortion,covd,nv,indmetric,indmetric],
Cnnh=GiveSymbol[Distortion,covd,nv,nv,indmetric],
Cnhn=GiveSymbol[Distortion,covd,nv,indmetric,nv],
Chnn=GiveSymbol[Distortion,covd,indmetric,nv,nv],
Cnnn=GiveSymbol[Distortion,covd,nv,nv,nv]
},
If[torsionQ&&nonmetricityQ,
MasterOf[Chhn]^={};
MasterOf[Chnh]^={};
MasterOf[Cnhh]^={};
MasterOf[Chnn]^={};
MasterOf[Cnhn]^={};
MasterOf[Cnnh]^={};
MasterOf[Cnnn]^={};
UndefTensor[Chhn];
UndefTensor[Chnh];
UndefTensor[Cnhh];
UndefTensor[Cnnh];
UndefTensor[Cnhn];
UndefTensor[Chnn];
UndefTensor[Cnnn];
];
]
]


(* ::Input::Initialization:: *)
UndefMAGExtrinsicTensors[covd_,indmetric_]:=Module[
{torsionQ=TorsionQ[covd],
nonmetricityQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]]
},
With[{
	extrinsic1=GiveSymbol[Extrinsic,1,covd],
	extrinsic3=GiveSymbol[Extrinsic,3,covd]
	},
If[torsionQ&&nonmetricityQ,
MasterOf[extrinsic1]^={};
MasterOf[extrinsic3]^={};
UndefTensor[extrinsic1];
UndefTensor[extrinsic3];
];
]
]


(* ::Input::Initialization:: *)
UndefMAGAccelerationTensors[covd_,indmetric_]:=Module[
{nonmetQ=NonMetricityQ[covd,Part[InducedFrom[indmetric],1]],
torsionQ=TorsionQ[covd],
M=ManifoldOfCovD[covd]
},
With[
{
nv=Part[InducedFrom[indmetric],2]
},
	With[
	{acceleration1=GiveSymbol[Acceleration,"1",covd],
	acceleration3=GiveSymbol[Acceleration,"3",covd],
	acceleration1h=GiveSymbol[Acceleration,"1",covd,indmetric],
	acceleration3h=GiveSymbol[Acceleration,"3",covd,indmetric],
	accelerationcovdn=GiveSymbol[Acceleration,covd,nv]
	},
	If[nonmetQ&&torsionQ,
	MasterOf[acceleration1h]^={};
	MasterOf[acceleration3h]^={};
	UndefTensor[acceleration1];
	UndefTensor[acceleration3];
	UndefTensor[acceleration1h];
	UndefTensor[acceleration3h];
	UndefTensor[accelerationcovdn]
	];
]
]
]


(* ::Input::Initialization:: *)
undefProjectiveVariables[covd_?CovDQ/;(NonMetricityQ[covd]&&TorsionQ[covd]),indmetric_?InducedMetricQ]:=Module[{indices = GetIndicesOfVBundle[First@VBundlesOfCovD@covd,6],metric=InducedFrom[indmetric][[1]],normalvector=InducedFrom[indmetric][[2]],M=ManifoldOfCovD[covd],rule},
With[{distortionPI3=GiveSymbol[Distortion,covd,indmetric,"PI"],
distortionPI2=GiveSymbol[Distortion,covd,indmetric,normalvector,indmetric,"PI"],
Chnh=GiveSymbol[Distortion,covd,indmetric,normalvector,indmetric],
Ch=GiveSymbol[Distortion,covd,indmetric],
Cnhn=GiveSymbol[Distortion,covd,normalvector,indmetric,normalvector],
acc=GiveSymbol[Acceleration,covd,normalvector],
i1= indices[[1]],
i2= indices[[2]],
i3= indices[[3]],
j1= indices[[4]],
j2= indices[[5]],
j3= indices[[6]]
},
MasterOf[distortionPI3]^={};
MasterOf[distortionPI2]^={};
UndefTensor[distortionPI3];
UndefTensor[distortionPI2];
]
]


(* ::Input::Initialization:: *)
PrintAsCharacter[LinearVector]="\[Xi]";


(* ::Input::Initialization:: *)
LinearVector[int_Integer]:=ToExpression[StringJoin[ToString[LinearVector],ToString[int]]];


(* ::Input::Initialization:: *)
StartLinearTransformations[covd_?CovDQ]:=Module[{M=$Manifolds[[1]],TM=TangentBundleOfManifold[$Manifolds[[1]]],
a},
a=IndicesOfVBundle[TM][[1,1]];
With[{vect1=GiveSymbol[LinearVector,1],vect2=GiveSymbol[LinearVector,2],vect3=GiveSymbol[LinearVector,3]},
If[!xTensorQ[vect1],
DefTensor[vect1[a],M,PrintAs-> xMAGIRDPrint[LinearVector,covd,1]];
DefTensor[vect2[a],M,PrintAs-> xMAGIRDPrint[LinearVector,covd,2]];
DefTensor[vect3[a],M,PrintAs-> xMAGIRDPrint[LinearVector,covd,3]]
];
]
];


(* ::Input::Initialization:: *)
LinearTransformations[covd_?(!LeviCivitaQ[#]&),metric_?MetricQ]:=Module[
{vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric],3],
M=BaseOfVBundle@First@VBundlesOfCovD[covd],nmQ=NonMetricityQ[covd,metric],torsionQ=TorsionQ[covd],
vector1=GiveSymbol[LinearVector,1],vector2=GiveSymbol[LinearVector,2],vector3=GiveSymbol[LinearVector,3],
rules
},
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	distortion=GiveSymbol[Distortion,covd]},
If[!xTensorQ[vector1],StartLinearTransformations[covd]];
If[MasterOf[covd]===$Metrics[[1]],
rules={MakeRule[{distortion[a,b,c],distortion[a,b,c]+metric[a,b]vector1[c]},MetricOn->All],MakeRule[{distortion[a,b,c],distortion[a,b,c]+metric[a,c]vector2[b]},MetricOn->All],MakeRule[{distortion[a,b,c],distortion[a,b,c]+metric[b,c]vector3[a]},MetricOn->All],MakeRule[{distortion[a,b,c],distortion[a,b,c]+metric[a,b]vector1[c]+metric[a,c]vector2[b]+metric[b,c]vector3[a]},MetricOn->All]},
rules={SafeMakeRule[{distortion[a,-b,-c],distortion[a,-b,-c]+delta[a,-b]vector1[-c]}],SafeMakeRule[{distortion[a,-b,-c],distortion[a,-b,-c]+delta[a,-c]vector2[-b]}],SafeMakeRule[{distortion[a,-b,-c],distortion[a,-b,-c]+metric[-b,-c]vector3[a]}],SafeMakeRule[{distortion[a,-b,-c],distortion[a,-b,-c]+delta[a,-b]vector1[-c]+delta[a,-c]vector2[-b]+metric[-b,-c]vector3[a]}]}
]
];
Return[rules,Module]
];
LinearTransformations[covd_?CovDQ]:=LinearTransformations[covd,MasterOf[covd]];
LinearTransformations[]:=LinearTransformations[$CovDs[[3]]];


(* ::Input::Initialization:: *)
LinearTransform[kind___Integer,exp_,covd_?CovDQ,metric_?MetricQ]:=Module[{
vector1=GiveSymbol[LinearVector,1],vector2=GiveSymbol[LinearVector,2],vector3=GiveSymbol[LinearVector,3],distortion=GiveSymbol[Distortion,covd]},
Collect[(ToDistortion[exp,covd,metric])/.LinearTransformations[covd,metric][[kind]],{_metric,_delta,_vector1,_vector2,_vector3,_distortion},Factor]
];
LinearTransform[exp_,covd_?CovDQ,metric_?MetricQ]:=LinearTransform[4,exp,covd,metric];
LinearTransform[kind___Integer,exp_,covd_?CovDQ]:=LinearTransform[kind,exp,covd,$Metrics[[1]]];
LinearTransform[kind___Integer,exp_]:=LinearTransform[kind,exp,$CovDs[[3]]];


(* ::Input::Initialization:: *)
Options[ProjectiveTransformation]:={Symmetric->False}
ProjectiveTransformation[covd_?(!LeviCivitaQ[#]&),metric_?MetricQ,options:OptionsPattern[]]:=Module[{vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric],3],M=BaseOfVBundle@First@VBundlesOfCovD[covd],nmQ=NonMetricityQ[covd,metric],torsionQ=TorsionQ[covd],
vector1=GiveSymbol[LinearVector,1],vector2=GiveSymbol[LinearVector,2],vector3=GiveSymbol[LinearVector,3],sym},
{sym}=OptionValue[{ProjectiveTransformation},{options},{Symmetric}];
With[{a= indices[[1]],b= indices[[2]],c= indices[[3]],
	distortion=GiveSymbol[Distortion,covd]},
If[sym,Return[MakeRule[{distortion[a,b,c],distortion[a,b,c]+metric[a,b]vector2[c]+metric[a,c]vector2[b]},MetricOn->All],Module]];
LinearTransformations[covd,metric][[2]]]
];
ProjectiveTransformation[covd_?CovDQ,options:OptionsPattern[]]:=ProjectiveTransformation[covd,$Metrics[[1]],options];
ProjectiveTransformation[options:OptionsPattern[]]:=ProjectiveTransformation[$CovDs[[3]],options];

Options[ProjectiveTransform]:={Symmetric->False}
ProjectiveTransform[exp_,covd_?(!LeviCivitaQ[#]&),metric_?MetricQ,options:OptionsPattern[]]:=Module[{vector1=GiveSymbol[LinearVector,1],vector2=GiveSymbol[LinearVector,2],vector3=GiveSymbol[LinearVector,3],distortion=GiveSymbol[Distortion,covd],sym},
{sym}=OptionValue[{ProjectiveTransform},{options},{Symmetric}];
If[sym,Return[Collect[(ToDistortion[exp,covd,metric])/.ProjectiveTransformation[covd,metric,Symmetric->sym],{_metric,_delta,_vector2,_distortion},Factor],Module]
];
LinearTransform[2,exp,covd,metric]
];

ProjectiveTransform[exp_,covd_?(!LeviCivitaQ[#]&),options:OptionsPattern[]]:=ProjectiveTransform[exp,covd,MasterOf[covd],options];
ProjectiveTransform[exp_,options:OptionsPattern[]]:=ProjectiveTransform[exp,$CovDs[[3]],options];


(* ::Input::Initialization:: *)
WeylTransformation[covd1_?CovDQ,covd2_?CovDQ,met1_?MetricQ,met2_?MetricQ]:=Module[{
vb=VBundleOfMetric[met1],
indices = GetIndicesOfVBundle[VBundleOfMetric[met1], 4],
ruledistortion,
covdmet1=CovDOfMetric[met1],
covdmet2=CovDOfMetric[met2],
conf=ConformalFactor[met1,met2],
imet=Inv[met2],
iconf=ConformalFactor[met2,met1],
rulechris,
riemann1=GiveSymbol[Riemann,covd1],ricci1=GiveSymbol[Ricci,covd1],coricci1=GiveSymbol[CoRicci,covd1],homothetic1=GiveSymbol[Homothetic,covd1],ricciscalar1=GiveSymbol[RicciScalar,covd1],
riemann2=GiveSymbol[Riemann,covd2],ricci2=GiveSymbol[Ricci,covd2],coricci2=GiveSymbol[CoRicci,covd2],homothetic2=GiveSymbol[Homothetic,covd2],ricciscalar2=GiveSymbol[RicciScalar,covd2],
rulescurvature
},
With[{i1= indices[[1]],
		i2= indices[[2]],
	i3= indices[[3]],
	i4= indices[[4]],
	distortion1=GiveSymbol[Distortion,covd1],
	distortion2=GiveSymbol[Distortion,covd2],
	rulemetric=ConformalRules[met1,met2][[;;3]],
	vect1=GiveSymbol[LinearVector,1],
	vect2=GiveSymbol[LinearVector,2],
	vect3=GiveSymbol[LinearVector,3],
	chris1=GiveSymbol[Christoffel,covd1],
	chris2=GiveSymbol[Christoffel,covd2]
},
ruledistortion=With[{dummy=DummyAs[i1]},SafeMakeRule[{distortion1[i1,-i2,-i3],(distortion2[i1,-i2,-i3]/.LinearTransformations[covd2,met2][[4]])/.vect1[a_]:>-1/2*iconf*covdmet2[a][conf]/.vect2[a_]:>-1/2*iconf*covdmet2[a][conf]/.vect3[a_]:>1/2*iconf*imet[dummy,a]*covdmet2[-dummy][conf]}]];
rulechris=SafeMakeRule[{chris1[i1,-i2,-i3],chris2[i1,-i2,-i3]}];
rulescurvature=Join[SafeMakeRule[{riemann1[-i1,-i2,-i3,i4],riemann2[-i1,-i2,-i3,i4]}],SafeMakeRule[{ricci1[-i1,-i2],ricci2[-i1,-i2]}],SafeMakeRule[{homothetic1[-i1,-i2],homothetic2[-i1,-i2]}],SafeMakeRule[{coricci1[i1,-i2],iconf*coricci2[i1,-i2]}],SafeMakeRule[{ricciscalar1[],iconf*ricciscalar2[]}]];
Join[ruledistortion,rulechris,rulemetric,rulescurvature]
]
]
WeylTransformation[covd1_?CovDQ,covd2_?CovDQ]:=WeylTransformation[covd1,covd2,MasterOf[covd1],MasterOf[covd2]];


(* ::Input::Initialization:: *)
WeylTransform[exp_,covd1_?CovDQ,covd2_?CovDQ]:=Module[{met1=MasterOf[covd1],met2=MasterOf[covd2],res},With[{covdmet=CovDOfMetric[met2]},
res=(exp//WeylToRiemann//SeparateMetric)/.WeylTransformation[covd1,covd2]//ContractMetric;
Return[res,Module]
]];


(* ::Input::Initialization:: *)
(***** Old 
WeylTransform[exp_,covd1_?CovDQ,covd2_?CovDQ]:=Module[{met1=MasterOf[covd1],met2=MasterOf[covd2],res},With[{covdmet=CovDOfMetric[met2]},
MAGChristoffelTensorStop[covd1,met1,Verbose\[Rule]False];
res=(ChangeCurvature[exp//WeylToRiemann,covd1,covd2]//SeparateMetric//BreakChristoffel)/.WeylTransformation[covd1,covd2];
res=ToDistortion[res,covd1,met1,Verbose\[Rule]False];
res=CollectTensors[ChangeCovD[SeparateMetric[][(ConformalTransform[res,met1,met2]//SeparateMetric)/.WeylTransformation[covd1,covd2]],covd2,covdmet],{CollectMethod\[Rule]SafeCanonical}];
MAGChristoffelTensorStart[covd1,met1,Verbose\[Rule]False];
MAGChristoffelTensorStart[covd2,met2,Verbose\[Rule]False];
Return[res,Module]
]];*****)


(* ::Input::Initialization:: *)
End[];
EndPackage[];



